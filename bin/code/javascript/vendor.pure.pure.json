{
  "code": "/*!\n\tPURE Unobtrusive Rendering Engine for HTML\n\n\tLicensed under the MIT licenses.\n\tMore information at: http://www.opensource.org\n\n\tCopyright (c) 2013 Michael Cvilic - BeeBole.com\n\n\tThanks to Rog Peppe for the functional JS jump\n\trevision: 2.85\n*/\n\nvar $p = function(){\n\tvar args = arguments,\n\t\tsel = args[0],\n\t\tctxt = false;\n\n\tif(typeof sel === 'string'){\n\t\tctxt = args[1] || false;\n\t}else if(sel && !sel[0] && !sel.length){\n\t\tsel = [sel];\n\t}\n\treturn $p.core(sel, ctxt);\n},\npure = $p;\n\n\n$p.core = function(sel, ctxt, plugins){\n\t//get an instance of the plugins\n\tvar templates = [], i, ii,\n\t\t// set the signature string that will be replaced at render time\n\t\tSig = '_s' + Math.floor( Math.random() * 1000000 ) + '_',\n\t\t// another signature to prepend to attributes and avoid checks: style, height, on[events]...\n\t\tattPfx = '_a' + Math.floor( Math.random() * 1000000 ) + '_',\n\t\t// rx to parse selectors, e.g. \"+tr.foo[class]\"\n\t\tselRx = /^(\\+)?([^\\@\\+]+)?\\@?([^\\+]+)?(\\+)?$/,\n\t\t// set automatically attributes for some tags\n\t\tautoAttr = {\n\t\t\tIMG:'src',\n\t\t\tINPUT:'value'\n\t\t},\n\t\t// check if the argument is an array - thanks salty-horse (Ori Avtalion)\n\t\tisArray = Array.isArray ?\n\t\t\tfunction(o) {\n\t\t\t\treturn Array.isArray(o);\n\t\t\t} :\n\t\t\tfunction(o) {\n\t\t\t\treturn Object.prototype.toString.call(o) === \"[object Array]\";\n\t\t\t};\n\n\tplugins = plugins || getPlugins();\n\n\t//search for the template node(s)\n\tswitch(typeof sel){\n\t\tcase 'string':\n\t\t\ttemplates = plugins.find(ctxt || document, sel);\n\t\t\tif(templates.length === 0) {\n\t\t\t\terror('The template \"' + sel + '\" was not found');\n\t\t\t}\n\t\tbreak;\n\t\tcase 'undefined':\n\t\t\terror('The root of the template is undefined, check your selector');\n\t\tbreak;\n\t\tdefault:\n\t\t\ttemplates = sel;\n\t}\n\n\tfor( i = 0, ii = templates.length; i < ii; i++){\n\t\tplugins[i] = templates[i];\n\t}\n\tplugins.length = ii;\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * *\n\t\tcore functions\n\t * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\n\t// error utility\n\tfunction error(e){\n\t\tif(typeof console !== 'undefined'){\n\t\t\tconsole.log(e);\n\t\t\t//debugger;\n\t\t}\n\t\tthrow 'pure error: ' + e;\n\t}\n\n\t//return a new instance of plugins\n\tfunction getPlugins(){\n\t\tvar plugins = $p.plugins,\n\t\t\tf = function(){};\n\t\tf.prototype = plugins;\n\n\t\t// do not overwrite functions if external definition\n\t\tf.prototype.compile    = plugins.compile || compile;\n\t\tf.prototype.render     = plugins.render || render;\n\t\tf.prototype.autoRender = plugins.autoRender || autoRender;\n\t\tf.prototype.find       = plugins.find || find;\n\n\t\t// give the compiler and the error handling to the plugin context\n\t\tf.prototype._compiler  = compiler;\n\t\tf.prototype._error     = error;\n\n\t\treturn new f();\n\t}\n\n\t// returns the outer HTML of a node\n\tfunction outerHTML(node){\n\t\t// if IE, Chrome take the internal method otherwise build one\n\t\treturn /*node.outerHTML || */(\n\t\t\tfunction(n){\n\t\t\t\treturn document.createElement('div').appendChild( n.cloneNode(true) ).parentNode.innerHTML;\n\t\t\t/*var div = document.createElement('div'), h;\n\t\t\tdiv.appendChild( n.cloneNode(true) );\n\t\t\t\th = div.innerHTML;\n\t\t\t\tdiv = null;\n\t\t\t\treturn h;*/\n\t\t\t}(node));\n\t}\n\n\t// returns the string generator function\n\tfunction wrapquote(qfn, f){\n\t\treturn function(ctxt){\n\t\t\treturn qfn( String( f.call(ctxt.item || ctxt.context, ctxt) ) ) ;\n\t\t};\n\t}\n\n\t// default find using querySelector when available on the browser\n\tfunction find(n, sel){\n\t\tif(typeof n === 'string'){\n\t\t\tsel = n;\n\t\t\tn = false;\n\t\t}\n\t\treturn (n||document).querySelectorAll( sel );\n\t}\n\n\t// create a function that concatenates constant string\n\t// sections (given in parts) and the results of called\n\t// functions to fill in the gaps between parts (fns).\n\t// fns[n] fills in the gap between parts[n-1] and parts[n];\n\t// fns[0] is unused.\n\t// this is the inner template evaluation loop.\n\tfunction concatenator(parts, fns){\n\t\treturn function(ctxt){\n\t\t\tvar strs = [ parts[ 0 ] ],\n\t\t\t\tn = parts.length,\n\t\t\t\tfnVal, pVal, attLine, pos, i;\n\t\t\ttry{\n\t\t\t\tfor(i = 1; i < n; i++){\n\t\t\t\t\tfnVal = fns[i].call( this, ctxt );\n\t\t\t\t\tpVal = parts[i];\n\n\t\t\t\t\t// if the value is empty and attribute, remove it\n\t\t\t\t\tif(fnVal === ''){\n\t\t\t\t\t\tattLine = strs[ strs.length - 1 ];\n\t\t\t\t\t\tif( ( pos = attLine.search( /[^\\s]+=\\\"?$/ ) ) > -1){\n\t\t\t\t\t\t\tstrs[ strs.length - 1 ] = attLine.substring( 0, pos );\n\t\t\t\t\t\t\tpVal = pVal.substr( 1 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tstrs[ strs.length ] = fnVal;\n\t\t\t\t\tstrs[ strs.length ] = pVal;\n\t\t\t\t}\n\t\t\t\treturn strs.join('');\n\t\t\t}catch(e){\n\t\t\t\tif(console && console.log){\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\te.stack ||\n\t\t\t\t\t\te.message + ' (' + e.type + ( e['arguments'] ? ', ' + e['arguments'].join('-') : '' ) + '). Use Firefox or Chromium/Chrome to get a full stack of the error. ' );\n\t\t\t\t}\n\t\t\t\treturn '';\n\t\t\t}\n\t\t};\n\t}\n\n\t// parse and check the loop directive\n\tfunction parseloopspec(p){\n\t\tvar m = p.match( /^(\\w+)\\s*<-\\s*(\\S+)?$/ );\n\t\tif(m === null){\n\t\t\terror('bad loop spec: \"' + p + '\"');\n\t\t}\n\t\tif(m[1] === 'item'){\n\t\t\terror('\"item<-...\" is a reserved word for the current running iteration.\\n\\nPlease choose another name for your loop.');\n\t\t}\n\t\tif( !m[2] || m[2].toLowerCase() === 'context' ){ //undefined or space(IE)\n\t\t\tm[2] = function(ctxt){return ctxt.context;};\n\t\t}else if( m[2] && m[2].indexOf('context') === 0 ){ //undefined or space(IE)\n\t\t\tm[2] = dataselectfn( m[2].replace(/^context\\.?/, '') );\n\t\t}\n\t\treturn {name: m[1], sel: m[2]};\n\t}\n\n\t// parse a data selector and return a function that\n\t// can traverse the data accordingly, given a context.\n\tfunction dataselectfn (sel){\n\t\tif( typeof(sel) === 'function' ){\n\t\t\t//handle false values in function directive\n\t\t\treturn function ( ctxt ){\n\t\t\t\tvar r = sel.call( ctxt.item || ctxt.context || ctxt, ctxt );\n\t\t\t\treturn !r && r !== 0 ? '' : r;\n\t\t\t};\n\t\t}\n\t\t//check for a valid js variable name with hyphen(for properties only), $, _ and :\n\t\tvar m = sel.match(/^[\\da-zA-Z\\$_\\@\\#][\\w\\$:\\-\\#]*(\\.[\\w\\$:\\-\\#]*[^\\.])*$/),\n\t\t\tfound = false, s = sel, parts = [], pfns = [], i = 0, retStr;\n\n\t\tif(m === null){\n\t\t\t// check if literal\n\t\t\tif(/\\'|\\\"/.test( s.charAt(0) )){\n\t\t\t\tif(/\\'|\\\"/.test( s.charAt(s.length-1) )){\n\t\t\t\t\tretStr = s.substring(1, s.length-1);\n\t\t\t\t\treturn function(){ return retStr; };\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// check if literal + #{var}\n\t\t\t\twhile((m = s.match(/#\\{([^{}]+)\\}/)) !== null){\n\t\t\t\t\tfound = true;\n\t\t\t\t\tparts[i++] = s.slice(0, m.index);\n\t\t\t\t\tpfns[i] = dataselectfn(m[1]);\n\t\t\t\t\ts = s.slice(m.index + m[0].length, s.length);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!found){ //constant, return it\n\t\t\t\treturn function(){ return sel; };\n\t\t\t}\n\t\t\tparts[i] = s;\n\t\t\treturn concatenator(parts, pfns);\n\t\t}\n\t\tm = sel.split('.');\n\t\treturn function(ctxt){\n\t\t\tvar data = ctxt.context || ctxt,\n\t\t\t\tv = ctxt[m[0]],\n\t\t\t\ti = 0,\n\t\t\t\tn,\n\t\t\t\tdm;\n\n\t\t\tif(v && typeof v.item !== 'undefined'){\n\t\t\t\ti += 1;\n\t\t\t\tif(m[i] === 'pos'){\n\t\t\t\t\t//allow pos to be kept by string. Tx to Adam Freidin\n\t\t\t\t\treturn v.pos;\n\t\t\t\t}\n\t\t\t\tdata = v.item;\n\t\t\t}\n\t\t\tn = m.length;\n\n\t\t\twhile( i < n ){\n\t\t\t\tif(!data){break;}\n\t\t\t\tdm = data[ m[i] ];\n\t\t\t\t//if it is a function call it\n\t\t\t\tdata = typeof dm === 'function' ? dm.call( data ) : dm;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\treturn !data && data !== 0 ? '':data;\n\t\t};\n\t}\n\n\t// wrap in an object the target node/attr and their properties\n\tfunction gettarget(dom, sel, isloop){\n\t\tvar osel, prepend, selector, attr, append, target = [], m,\n\t\t\tsetstr, getstr, quotefn, isStyle, isClass, attName, setfn;\n\t\tif( typeof sel === 'string' ){\n\t\t\tosel = sel;\n\t\t\tm = sel.match(selRx);\n\t\t\tif( !m ){\n\t\t\t\terror( 'bad selector syntax: ' + sel );\n\t\t\t}\n\n\t\t\tprepend = m[1];\n\t\t\tselector = m[2];\n\t\t\tattr = m[3];\n\t\t\tappend = m[4];\n\n\t\t\tif(selector === '.' || !selector && attr ){\n\t\t\t\ttarget[0] = dom;\n\t\t\t}else{\n\t\t\t\ttarget = plugins.find(dom, selector);\n\t\t\t}\n\t\t\tif(!target || target.length === 0){\n\t\t\t\t// the target doesn't exist, let the receiving method handle that\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}else{\n\t\t\t// autoRender node\n\t\t\tprepend = sel.prepend;\n\t\t\tattr = sel.attr;\n\t\t\tappend = sel.append;\n\t\t\ttarget = [dom];\n\t\t}\n\n\t\tif( prepend || append ){\n\t\t\tif( prepend && append ){\n\t\t\t\terror('append/prepend cannot take place at the same time');\n\t\t\t}else if( isloop ){\n\t\t\t\terror('no append/prepend/replace modifiers allowed for loop target');\n\t\t\t}else if( append && isloop ){\n\t\t\t\terror('cannot append with loop (sel: ' + osel + ')');\n\t\t\t}\n\t\t}\n\n\t\tif(attr){\n\t\t\tisStyle = /^style$/i.test(attr);\n\t\t\tisClass = /^class$/i.test(attr);\n\t\t\tattName = isClass ? 'className' : attr;\n\t\t\tsetstr = function(node, s) {\n\t\t\t\tnode.setAttribute(attPfx + attr, s);\n\t\t\t\tif ( node[attName] && !isStyle) {\n\t\t\t\t\ttry{node[attName] = '';}catch(e){} //FF4 gives an error sometimes\n\t\t\t\t}\n\t\t\t\tif (node.nodeType === 1) {\n\t\t\t\t\tnode.removeAttribute(attr);\n\t\t\t\t\tif(isClass){\n\t\t\t\t\t\tnode.removeAttribute(attName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (isStyle || isClass) {//IE no quotes special care\n\t\t\t\tif(isStyle){\n\t\t\t\t\tgetstr = function(n){ return n.style.cssText; };\n\t\t\t\t}else{\n\t\t\t\t\tgetstr = function(n){ return n.className;\t};\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\tgetstr = function(n){ return n.getAttribute(attr); };\n\t\t\t}\n\t\t\tquotefn = function(s){ return s.replace(/\\\"/g, '&quot;'); };\n\t\t\tif(prepend){\n\t\t\t\tsetfn = function(node, s){ setstr( node, s + getstr( node )); };\n\t\t\t}else if(append){\n\t\t\t\tsetfn = function(node, s){ setstr( node, getstr( node ) + s); };\n\t\t\t}else{\n\t\t\t\tsetfn = function(node, s){ setstr( node, s ); };\n\t\t\t}\n\t\t}else{\n\t\t\tif (isloop) {\n\t\t\t\tsetfn = function(node, s) {\n\t\t\t\t\tvar pn = node.parentNode;\n\t\t\t\t\tif (pn) {\n\t\t\t\t\t\t//replace node with s\n\t\t\t\t\t\tpn.insertBefore(document.createTextNode(s), node.nextSibling);\n\t\t\t\t\t\tpn.removeChild(node);\n\t\t\t\t\t}else{\n\t\t\t\t\t\terror('The template root, can\\'t be looped.');\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tif (prepend) {\n\t\t\t\t\tsetfn = function(node, s) { node.insertBefore(document.createTextNode(s), node.firstChild);\t};\n\t\t\t\t} else if (append) {\n\t\t\t\t\tsetfn = function(node, s) { node.appendChild(document.createTextNode(s));};\n\t\t\t\t} else {\n\t\t\t\t\tsetfn = function(node, s) {\n\t\t\t\t\t\twhile (node.firstChild) { node.removeChild(node.firstChild); }\n\t\t\t\t\t\tnode.appendChild(document.createTextNode(s));\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\tquotefn = function(s) { return s; };\n\t\t}\n\t\treturn { attr: attr, nodes: target, set: setfn, sel: osel, quotefn: quotefn };\n\t}\n\n\tfunction setsig(target, n){\n\t\tvar sig = Sig + n + ':', i;\n\t\tfor(i = 0; i < target.nodes.length; i++){\n\t\t\t// could check for overlapping targets here.\n\t\t\ttarget.set( target.nodes[i], sig );\n\t\t}\n\t}\n\n\t// read de loop data, and pass it to the inner rendering function\n\tfunction loopfn(name, dselect, inner, sorter, filter){\n\t\treturn function(ctxt){\n\t\t\tvar a = dselect(ctxt),\n\t\t\t\told = ctxt[name],\n\t\t\t\ttemp = { items : a },\n\t\t\t\tfiltered = 0,\n\t\t\t\tlength,\n\t\t\t\tstrs = [],\n\t\t\t\tbuildArg = function(idx, temp, ftr, len){\n\t\t\t\t\t//keep the current loop. Tx to Adam Freidin\n\t\t\t\t\tvar save_pos = ctxt.pos,\n\t\t\t\t\t\tsave_item = ctxt.item,\n\t\t\t\t\t\tsave_items = ctxt.items;\n\t\t\t\t\tctxt.pos = temp.pos = idx;\n\t\t\t\t\tctxt.item = temp.item = a[ idx ];\n\t\t\t\t\tctxt.items = a;\n\t\t\t\t\t//if array, set a length property - filtered items\n\t\t\t\t\tif(typeof len !== 'undefined'){ ctxt.length = len; }\n\t\t\t\t\t//if filter directive\n\t\t\t\t\tif(typeof ftr === 'function' && ftr.call(ctxt.item, ctxt) === false){\n\t\t\t\t\t\tfiltered++;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tstrs.push( inner.call(ctxt.item, ctxt ) );\n\t\t\t\t\t//restore the current loop\n\t\t\t\t\tctxt.pos = save_pos;\n\t\t\t\t\tctxt.item = save_item;\n\t\t\t\t\tctxt.items = save_items;\n\t\t\t\t},\n\t\t\t\tcmv = function(p){\n\t\t\t\t\tif( ctxt[ p ] ){\n\t\t\t\t\t\tdelete ctxt[ p ];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tprop, i, ii;\n\t\t\tctxt[name] = temp;\n\t\t\tif( isArray(a) ){\n\t\t\t\tlength = a.length || 0;\n\t\t\t\t// if sort directive\n\t\t\t\tif(typeof sorter === 'function'){\n\t\t\t\t\ta.sort(function(a, b){\n\t\t\t\t\t\treturn sorter.call(ctxt, a, b);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t//loop on array\n\t\t\t\tfor(i = 0, ii = length; i < ii; i++){\n\t\t\t\t\tbuildArg(i, temp, filter, length - filtered);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(a && typeof sorter !== 'undefined'){\n\t\t\t\t\terror('sort is only available on arrays, not objects');\n\t\t\t\t}\n\t\t\t\t//loop on collections\n\t\t\t\tfor( prop in a ){\n\t\t\t\t\tif( a.hasOwnProperty( prop ) ){\n\t\t\t\t\t\tbuildArg(prop, temp, filter);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( typeof old !== 'undefined'){\n\t\t\t\tctxt[ name ] = old;\n\t\t\t}else{\n\t\t\t\tcmv( name );\n\t\t\t}\n\t\t\treturn strs.join('');\n\t\t};\n\t}\n\t// generate the template for a loop node\n\tfunction loopgen(dom, sel, loop, fns){\n\t\tvar already = false, ls, sorter, filter, prop, dsel, spec, itersel, target, nodes, node, inner;\n\t\tfor(prop in loop){\n\t\t\tif(loop.hasOwnProperty(prop)){\n\t\t\t\tif(prop === 'sort'){\n\t\t\t\t\tsorter = loop.sort;\n\t\t\t\t}else if(prop === 'filter'){\n\t\t\t\t\tfilter = loop.filter;\n\t\t\t\t}else if(already){\n\t\t\t\t\terror('cannot have more than one loop on a target');\n\t\t\t\t}else{\n\t\t\t\t\tls = prop;\n\t\t\t\t\talready = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ls){\n\t\t\terror('Error in the selector: ' + sel + '\\nA directive action must be a string, a function or a loop(<-)');\n\t\t}\n\t\tdsel = loop[ls];\n\t\t// if it's a simple data selector then we default to contents, not replacement.\n\t\tif(typeof dsel === 'string' || typeof dsel === 'function'){\n\t\t\tloop = {};\n\t\t\tloop[ls] = {root: dsel};\n\t\t\treturn loopgen(dom, sel, loop, fns);\n\t\t}\n\n\t\tspec = parseloopspec(ls);\n\t\titersel = dataselectfn(spec.sel);\n\t\ttarget = gettarget(dom, sel, true);\n\n\t\t// If the target doesn't exist, move on\n\t\tif(target == null) { return; }\n\n\t\tnodes = target.nodes;\n\n\t\tfor(i = 0; i < nodes.length; i++){\n\t\t\tnode = nodes[i];\n\t\t\tinner = compiler(node, dsel);\n\t\t\tfns[fns.length] = wrapquote(target.quotefn, loopfn(spec.name, itersel, inner, sorter, filter));\n\t\t\ttarget.nodes = [node];\t\t// N.B. side effect on target.\n\t\t\tsetsig(target, fns.length - 1);\n\t\t}\n\t\treturn target;\n\t}\n\n\tfunction getAutoNodes(n, data){\n\t\tvar ns = n.getElementsByTagName('*'),\n\t\t\tan = [],\n\t\t\topenLoops = {a:[],l:{}},\n\t\t\tcspec,\n\t\t\tisNodeValue,\n\t\t\ti, ii, j, jj, ni, cs, cj;\n\t\t//for each node found in the template\n\t\tfor(i = -1, ii = ns.length; i < ii; i++){\n\t\t\tni = i > -1 ?ns[i]:n;\n\t\t\tif(ni.nodeType === 1 && ni.className !== ''){\n\t\t\t\t//when a className is found\n\t\t\t\tcs = ni.className.split(' ');\n\t\t\t\t// for each className\n\t\t\t\tfor(j = 0, jj=cs.length;j<jj;j++){\n\t\t\t\t\tcj = cs[j];\n\t\t\t\t\t// check if it is related to a context property\n\t\t\t\t\tcspec = checkClass(cj, ni.tagName);\n\t\t\t\t\t// if so, store the node, plus the type of data\n\t\t\t\t\tif(cspec !== false){\n\t\t\t\t\t\tisNodeValue = /nodevalue/i.test(cspec.attr);\n\t\t\t\t\t\tif(cspec.sel.indexOf('@') > -1 || isNodeValue){\n\t\t\t\t\t\t\tni.className = ni.className.replace('@'+cspec.attr, '');\n\t\t\t\t\t\t\tif(isNodeValue){\n\t\t\t\t\t\t\t\tcspec.attr = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tan.push({n:ni, cspec:cspec});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction checkClass(c, tagName){\n\t\t\t// read the class\n\t\t\tvar ca = c.match(selRx),\n\t\t\t\tattr = ca[3] || autoAttr[tagName],\n\t\t\t\tcspec = {prepend:!!ca[1], prop:ca[2], attr:attr, append:!!ca[4], sel:c},\n\t\t\t\ti, ii, loopi, loopil, val;\n\t\t\t// check in existing open loops\n\t\t\tfor(i = openLoops.a.length-1; i >= 0; i--){\n\t\t\t\tloopi = openLoops.a[i];\n\t\t\t\tloopil = loopi.l[0];\n\t\t\t\tval = loopil && loopil[cspec.prop];\n\t\t\t\tif(typeof val !== 'undefined'){\n\t\t\t\t\tcspec.prop = loopi.p + '.' + cspec.prop;\n\t\t\t\t\tif(openLoops.l[cspec.prop] === true){\n\t\t\t\t\t\tval = val[0];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// not found check first level of data\n\t\t\tif(typeof val === 'undefined'){\n\t\t\t\tval = dataselectfn(cspec.prop)(isArray(data) ? data[0] : data);\n\t\t\t\t// nothing found return\n\t\t\t\tif(val === ''){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// set the spec for autoNode\n\t\t\tif(isArray(val)){\n\t\t\t\topenLoops.a.push( {l:val, p:cspec.prop} );\n\t\t\t\topenLoops.l[cspec.prop] = true;\n\t\t\t\tcspec.t = 'loop';\n\t\t\t}else{\n\t\t\t\tcspec.t = 'str';\n\t\t\t}\n\t\t\treturn cspec;\n\t\t}\n\n\t\treturn an;\n\n\t}\n\n\t// returns a function that, given a context argument,\n\t// will render the template defined by dom and directive.\n\tfunction compiler(dom, directive, data, ans){\n\t\tvar fns = [], j, jj, iii, cspec, n, target, nodes, itersel, node, inner, h, parts,  pfns = [], p, classes = {},\n\t\tdoDirective = function( psel, pdirective ){\n\t\t\tvar ii = 0,\n\t\t\t\tdsel = pdirective[psel],\n\t\t\t\tsels = psel.split(/\\s*,\\s*/), //allow selector separation by quotes\n\t\t\t\tsl = sels.length;\n\t\t\tdo{\n\t\t\t\tif(typeof dsel === 'function' || typeof dsel === 'string'){\n\t\t\t\t\t// set the value for the node/attr\n\t\t\t\t\tpsel = sels[ii];\n\t\t\t\t\ttarget = gettarget(dom, psel, false);\n\t\t\t\t\t// If the target doesn't exist, move on\n\t\t\t\t\tif(target == null) { continue; }\n\n\t\t\t\t\tsetsig(target, fns.length);\n\t\t\t\t\tfns[fns.length] = wrapquote(target.quotefn, dataselectfn(dsel));\n\t\t\t\t}else{\n\t\t\t\t\t// loop on node\n\t\t\t\t\tloopgen(dom, psel, dsel, fns);\n\t\t\t\t}\n\t\t\t}while(++ii < sl);\n\t\t};\n\t\t// autoRendering nodes parsing -> auto-nodes\n\t\tans = ans || data && getAutoNodes(dom, data);\n\t\tif(data){\n\t\t\t// for each auto-nodes\n\t\t\twhile(ans.length > 0){\n\t\t\t\tcspec = ans[0].cspec;\n\t\t\t\tn = ans[0].n;\n\t\t\t\tans.splice(0, 1);\n\t\t\t\tif(cspec.t === 'str'){\n\t\t\t\t\t// if the target is a value\n\t\t\t\t\ttarget = gettarget(n, cspec, false);\n\t\t\t\t\t// If the target doesn't exist, move on\n\t\t\t\t\tif(target == null) { continue; }\n\n\t\t\t\t\tsetsig(target, fns.length);\n\t\t\t\t\tfns[fns.length] = wrapquote(target.quotefn, dataselectfn(cspec.prop));\n\t\t\t\t}else{\n\t\t\t\t\t// if the target is a loop\n\t\t\t\t\titersel = dataselectfn(cspec.sel);\n\t\t\t\t\ttarget = gettarget(n, cspec, true);\n\t\t\t\t\t// If the target doesn't exist, move on\n\t\t\t\t\tif(target == null) { continue; }\n\n\t\t\t\t\tnodes = target.nodes;\n\t\t\t\t\tfor(j = 0, jj = nodes.length; j < jj; j++){\n\t\t\t\t\t\tnode = nodes[j];\n\t\t\t\t\t\tinner = compiler(node, false, data, ans);\n\t\t\t\t\t\tfns[fns.length] = wrapquote(target.quotefn, loopfn(cspec.sel, itersel, inner));\n\t\t\t\t\t\ttarget.nodes = [node];\n\t\t\t\t\t\tsetsig(target, fns.length - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// read directives\n\t\tfor(sel in directive){\n\t\t\tif( sel.indexOf('@class') >= 0 ){\n\t\t\t\t//skip the classes and do it at the end to avoid selector errors of class not found\n\t\t\t\tclasses[sel] = directive[sel];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdoDirective( sel, directive );\n\t\t}\n\n\t\tfor( sel in classes ){\n\t\t\tdoDirective( sel, classes );\n\t\t}\n\t\t// convert node to a string\n\t\th = outerHTML(dom);\n\t\t\t// IE adds an unremovable \"selected, value\" attribute\n\t\t\t// hard replace while waiting for a better solution\n\t\th = h.replace(/<([^>]+)\\s(value\\=\"\"|selected)\\s?([^>]*)>/ig, \"<$1 $3>\");\n\n\t\t// remove attribute prefix\n\t\th = h.split(attPfx).join('');\n\n\t\t// slice the html string at \"Sig\"\n\t\tparts = h.split( Sig );\n\t\t// for each slice add the return string of\n\t\tfor(iii = 1; iii < parts.length; iii++){\n\t\t\tp = parts[iii];\n\t\t\t// part is of the form \"fn-number:...\" as placed there by setsig.\n\t\t\tpfns[iii] = fns[ parseInt(p, 10) ];\n\t\t\tparts[iii] = p.substring( p.indexOf(':') + 1 );\n\t\t}\n\t\treturn concatenator(parts, pfns);\n\t}\n\t// compile the template with directive\n\t// if a context is passed, the autoRendering is triggered automatically\n\t// return a function waiting the data as argument\n\tfunction compile(directive, ctxt, template){\n\t\tvar rfn = compiler( ( template || this[0] ).cloneNode(true), directive, ctxt);\n\t\treturn function(context){\n\t\t\treturn rfn({context:context});\n\t\t};\n\t}\n\t//compile with the directive as argument\n\t// run the template function on the context argument\n\t// return an HTML string\n\t// should replace the template and return this\n\tfunction render(ctxt, directive){\n\t\tvar fn = typeof directive === 'function' && directive, i, ii;\n\t\tfor(i = 0, ii = this.length; i < ii; i++){\n\t\t\tthis[i] = replaceWith( this[i], (fn || plugins.compile( directive, false, this[i] ))( ctxt, false ));\n\t\t}\n\t\treturn this;\n\t}\n\n\t// compile the template with autoRender\n\t// run the template function on the context argument\n\t// return an HTML string\n\tfunction autoRender(ctxt, directive){\n\t\tvar fn = plugins.compile( directive, ctxt, this[0] ), i, ii;\n\t\tfor(i = 0, ii = this.length; i < ii; i++){\n\t\t\tthis[i] = replaceWith( this[i], fn( ctxt, false));\n\t\t}\n\t\treturn this;\n\t}\n\n\tfunction replaceWith(elm, html) {\n\t\tvar ne,\n\t\t\tep = elm.parentNode,\n\t\t\tdepth = 0,\n\t\t\ttmp,\n\t\t\tdb = document.body || document.getElementsByTagNameNS( 'http://www.w3.org/1999/xhtml', 'body')[0];//DOM or XML body, thanks to https://github.com/peter-kehl\n\t\tif(!ep){ //if no parents\n\t\t\tep = document.createElement('DIV');\n\t\t\tep.appendChild(elm);\n\t\t}\n\t\tswitch (elm.tagName) {\n\t\t\tcase 'BODY': //thanks to milan.adamovsky@gmail.com\n\t\t\t\tep.removeChild(elm);\n\t\t\t\tep.innerHTML += html;\n\t\t\t\treturn ep.getElementsByTagName('BODY')[0];\n\t\t\tcase 'TBODY': case 'THEAD': case 'TFOOT':\n\t\t\t\thtml = '<TABLE>' + html + '</TABLE>';\n\t\t\t\tdepth = 1;\n\t\t\tbreak;\n\t\t\tcase 'TR':\n\t\t\t\thtml = '<TABLE><TBODY>' + html + '</TBODY></TABLE>';\n\t\t\t\tdepth = 2;\n\t\t\tbreak;\n\t\t\tcase 'TD': case 'TH':\n\t\t\t\thtml = '<TABLE><TBODY><TR>' + html + '</TR></TBODY></TABLE>';\n\t\t\t\tdepth = 3;\n\t\t\tbreak;\n\t\t\tcase 'OPTGROUP': case 'OPTION':\n\t\t\t\thtml = '<SELECT>' + html + '</SELECT>';\n\t\t\t\tdepth = 1;\n\t\t\tbreak;\n\t\t}\n\t\ttmp = document.createElement('SPAN');\n\t\tif( tmp.style ){ //check if XML document\n\t\t\ttmp.style.display = 'none';\n\t\t}\n\t\tdb.appendChild(tmp);\n\t\ttmp.innerHTML = html;\n\t\tne = tmp.firstChild;\n\t\twhile (depth--) {\n\t\t\tne = ne.firstChild;\n\t\t}\n\t\tep.insertBefore(ne, elm);\n\t\tep.removeChild(elm);\n\t\tdb.removeChild(tmp);\n\t\telm = ne;\n\n\t\tne = ep = null;\n\t\treturn elm;\n\t}\n\n\treturn plugins;\n};\n\n$p.plugins = {};\n\n$p.libs = {\n\tdojo:function(){\n\t\treturn function(n, sel){\n\t\t\treturn dojo.query(sel, n);\n\t\t};\n\t},\n\tdomassistant:function(){\n\t\tDOMAssistant.attach({\n\t\t\tpublicMethods : [ 'compile', 'render', 'autoRender'],\n\t\t\tcompile:function(directive, ctxt){\n\t\t\t\treturn $p([this]).compile(directive, ctxt);\n\t\t\t},\n\t\t\trender:function(ctxt, directive){\n\t\t\t\treturn $( $p([this]).render(ctxt, directive) )[0];\n\t\t\t},\n\t\t\tautoRender:function(ctxt, directive){\n\t\t\t\treturn $( $p([this]).autoRender(ctxt, directive) )[0];\n\t\t\t}\n\t\t});\n\t\treturn function(n, sel){\n\t\t\treturn $(n).cssSelect(sel);\n\t\t};\n\t},\n\text:function(){//Thanks to Greg Steirer\n\t\treturn function(n, sel){\n\t\t\treturn Ext.query(sel, n);\n\t\t};\n\t},\n\tjquery:function(){\n\t\tjQuery.fn.extend({\n\t\t\tdirectives:function(directive){\n\t\t\t\tthis._pure_d = directive; return this;\n\t\t\t},\n\t\t\tcompile:function(directive, ctxt){\n\t\t\t\treturn $p(this).compile(this._pure_d || directive, ctxt);\n\t\t\t},\n\t\t\trender:function(ctxt, directive){\n\t\t\t\treturn jQuery( $p( this ).render( ctxt, this._pure_d || directive ) );\n\t\t\t},\n\t\t\tautoRender:function(ctxt, directive){\n\t\t\t\treturn jQuery( $p( this ).autoRender( ctxt, this._pure_d || directive ) );\n\t\t\t}\n\t\t});\n\t\treturn function(n, sel){\n\t\t\treturn jQuery(n).find(sel);\n\t\t};\n\t},\n\tmootools:function(){\n\t\tElement.implement({\n\t\t\tcompile:function(directive, ctxt){\n\t\t\t\treturn $p(this).compile(directive, ctxt);\n\t\t\t},\n\t\t\trender:function(ctxt, directive){\n\t\t\t\treturn $p([this]).render(ctxt, directive);\n\t\t\t},\n\t\t\tautoRender:function(ctxt, directive){\n\t\t\t\treturn $p([this]).autoRender(ctxt, directive);\n\t\t\t}\n\t\t});\n\t\treturn function(n, sel){\n\t\t\treturn $(n).getElements(sel);\n\t\t};\n\t},\n\tprototype:function(){\n\t\tElement.addMethods({\n\t\t\tcompile:function(element, directive, ctxt){\n\t\t\t\treturn $p([element]).compile(directive, ctxt);\n\t\t\t},\n\t\t\trender:function(element, ctxt, directive){\n\t\t\t\treturn $p([element]).render(ctxt, directive);\n\t\t\t},\n\t\t\tautoRender:function(element, ctxt, directive){\n\t\t\t\treturn $p([element]).autoRender(ctxt, directive);\n\t\t\t}\n\t\t});\n\t\treturn function(n, sel){\n\t\t\tn = n === document ? n.body : n;\n\t\t\treturn typeof n === 'string' ? $$(n) : $(n).select(sel);\n\t\t};\n\t},\n\tsizzle:function(){\n\t\treturn function(n, sel){\n\t\t\treturn Sizzle(sel, n);\n\t\t};\n\t},\n\tsly:function(){\n\t\treturn function(n, sel){\n\t\t\treturn Sly(sel, n);\n\t\t};\n\t},\n\tyui:function(){ //Thanks to https://github.com/soljin\n\t\tif(typeof document.querySelector === 'undefined'){\n\t\t\tYUI().use(\"node\",function(Y){\n\t\t\t\t$p.plugins.find = function(n, sel){\n\t\t\t\t\treturn Y.NodeList.getDOMNodes(Y.one(n).all(sel));\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t\tYUI.add(\"pure-yui\",function(Y){\n\t\t\tY.Node.prototype.directives = function(directive){\n\t\t\t\tthis._pure_d = directive; return this;\n\t\t\t};\n\t\t\tY.Node.prototype.compile = function(directive, ctxt){\n\t\t\t\treturn $p([this._node]).compile(this._pure_d || directive, ctxt);\n\t\t\t};\n\t\t\tY.Node.prototype.render = function(ctxt, directive){\n\t\t\t\treturn Y.one($p([this._node]).render(ctxt, this._pure_d || directive));\n\t\t\t};\n\t\t\tY.Node.prototype.autoRender = function(ctxt, directive){\n\t\t\t\treturn Y.one($p([this._node]).autoRender(ctxt, this._pure_d || directive));\n\t\t\t};\n\t\t},\"0.1\",{requires:[\"node\"]});\n\n\t\treturn true;\n\t}\n};\n\n// get lib specifics if available\n(function(){\n\tvar libSel,\n\t\tlibkey =\n\t\t\ttypeof dojo         !== 'undefined' && 'dojo' ||\n\t\t\ttypeof DOMAssistant !== 'undefined' && 'domassistant' ||\n\t\t\ttypeof Ext          !== 'undefined' && 'ext' ||\n\t\t\ttypeof jQuery       !== 'undefined' && 'jquery' ||\n\t\t\ttypeof MooTools     !== 'undefined' && 'mootools' ||\n\t\t\ttypeof Prototype    !== 'undefined' && 'prototype' ||\n\t\t\ttypeof Sizzle       !== 'undefined' && 'sizzle' ||\n\t\t\ttypeof Sly          !== 'undefined' && 'sly' ||\n\t\t\ttypeof YUI          !== 'undefined' && 'yui';\n\n\t//add library methods\n\tif(libkey){\n\t\tlibSel = $p.libs[libkey]();\n\t}\n\n\t//if no native selector available\n\tif( typeof document.querySelector === 'undefined' ){\n\t\t//take it from the JS lib\n\t\tif( typeof libSel === 'function' ){\n\t\t\t$p.plugins.find = libSel;\n\t\t//if nothing throw an error\n\t\t}else if( !libSel ){\n\t\t\tthrow 'you need a JS library with a CSS selector engine';\n\t\t}\n\t}\n\n\t//for node.js\n\tif(typeof exports !== 'undefined'){\n\t\texports.$p = $p;\n\t}\n}());\n",
  "name": "idontknow",
  "interpreter": "javascript",
  "extension": "js"
}