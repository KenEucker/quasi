{
  "code": "/*\n\tCopyright (c) 2004-2011, The Dojo Foundation All Rights Reserved.\n\tAvailable via Academic Free License >= 2.1 OR the modified BSD license.\n\tsee: http://dojotoolkit.org/license for details\n*/\n\n/*\n\tThis is an optimized version of Dojo, built for deployment and not for\n\tdevelopment. To get sources and documentation, please visit:\n\n\t\thttp://dojotoolkit.org\n*/\n\n(function(\n\tuserConfig,\n\tdefaultConfig\n){\n\t// summary:\n\t//\t\tThis is the \"source loader\" and is the entry point for Dojo during development. You may also load Dojo with\n\t//\t\tany AMD-compliant loader via the package main module dojo/main.\n\t// description:\n\t//\t\tThis is the \"source loader\" for Dojo. It provides an AMD-compliant loader that can be configured\n\t//\t\tto operate in either synchronous or asynchronous modes. After the loader is defined, dojo is loaded\n\t//\t\tIAW the package main module dojo/main. In the event you wish to use a foreign loader, you may load dojo as a package\n\t//\t\tvia the package main module dojo/main and this loader is not required; see dojo/package.json for details.\n\t//\n\t//\t\tIn order to keep compatibility with the v1.x line, this loader includes additional machinery that enables\n\t//\t\tthe dojo.provide, dojo.require et al API. This machinery is loaded by default, but may be dynamically removed\n\t//\t\tvia the has.js API and statically removed via the build system.\n\t//\n\t//\t\tThis loader includes sniffing machinery to determine the environment; the following environments are supported:\n\t//\n\t//\t\t\t* browser\n\t//\t\t\t* node.js\n\t//\t\t\t* rhino\n\t//\n\t//\t\tThis is the so-called \"source loader\". As such, it includes many optional features that may be discadred by\n\t//\t\tbuilding a customized verion with the build system.\n\n\t// Design and Implementation Notes\n\t//\n\t// This is a dojo-specific adaption of bdLoad, donated to the dojo foundation by Altoviso LLC.\n\t//\n\t// This function defines an AMD-compliant (http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition)\n\t// loader that can be configured to operate in either synchronous or asynchronous modes.\n\t//\n\t// Since this machinery implements a loader, it does not have the luxury of using a load system and/or\n\t// leveraging a utility library. This results in an unpleasantly long file; here is a road map of the contents:\n\t//\n\t//\t 1. Small library for use implementing the loader.\n\t//\t 2. Define the has.js API; this is used throughout the loader to bracket features.\n\t//\t 3. Define the node.js and rhino sniffs and sniff.\n\t//\t 4. Define the loader's data.\n\t//\t 5. Define the configuration machinery.\n\t//\t 6. Define the script element sniffing machinery and sniff for configuration data.\n\t//\t 7. Configure the loader IAW the provided user, default, and sniffing data.\n\t//\t 8. Define the global require function.\n\t//\t 9. Define the module resolution machinery.\n\t//\t10. Define the module and plugin module definition machinery\n\t//\t11. Define the script injection machinery.\n\t//\t12. Define the window load detection.\n\t//\t13. Define the logging API.\n\t//\t14. Define the tracing API.\n\t//\t16. Define the AMD define function.\n\t//\t17. Define the dojo v1.x provide/require machinery--so called \"legacy\" modes.\n\t//\t18. Publish global variables.\n\t//\n\t// Language and Acronyms and Idioms\n\t//\n\t// moduleId: a CJS module identifier, (used for public APIs)\n\t// mid: moduleId (used internally)\n\t// packageId: a package identifier (used for public APIs)\n\t// pid: packageId (used internally); the implied system or default package has pid===\"\"\n\t// pack: package is used internally to reference a package object (since javascript has reserved words including \"package\")\n\t// prid: plugin resource identifier\n\t// The integer constant 1 is used in place of true and 0 in place of false.\n\n\t// define a minimal library to help build the loader\n\tvar\tnoop = function(){\n\t\t},\n\n\t\tisEmpty = function(it){\n\t\t\tfor(var p in it){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t},\n\n\t\ttoString = {}.toString,\n\n\t\tisFunction = function(it){\n\t\t\treturn toString.call(it) == \"[object Function]\";\n\t\t},\n\n\t\tisString = function(it){\n\t\t\treturn toString.call(it) == \"[object String]\";\n\t\t},\n\n\t\tisArray = function(it){\n\t\t\treturn toString.call(it) == \"[object Array]\";\n\t\t},\n\n\t\tforEach = function(vector, callback){\n\t\t\tif(vector){\n\t\t\t\tfor(var i = 0; i < vector.length;){\n\t\t\t\t\tcallback(vector[i++]);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tmix = function(dest, src){\n\t\t\tfor(var p in src){\n\t\t\t\tdest[p] = src[p];\n\t\t\t}\n\t\t\treturn dest;\n\t\t},\n\n\t\tmakeError = function(error, info){\n\t\t\treturn mix(new Error(error), {src:\"dojoLoader\", info:info});\n\t\t},\n\n\t\tuidSeed = 1,\n\n\t\tuid = function(){\n\t\t\t// Returns a unique indentifier (within the lifetime of the document) of the form /_d+/.\n\t\t\treturn \"_\" + uidSeed++;\n\t\t},\n\n\t\t// FIXME: how to doc window.require() api\n\n\t\t// this will be the global require function; define it immediately so we can start hanging things off of it\n\t\treq = function(\n\t\t\tconfig,       //(object, optional) hash of configuration properties\n\t\t\tdependencies, //(array of commonjs.moduleId, optional) list of modules to be loaded before applying callback\n\t\t\tcallback      //(function, optional) lamda expression to apply to module values implied by dependencies\n\t\t){\n\t\t\treturn contextRequire(config, dependencies, callback, 0, req);\n\t\t},\n\n\t\t// the loader uses the has.js API to control feature inclusion/exclusion; define then use throughout\n\t\tglobal = this,\n\n\t\tdoc = global.document,\n\n\t\telement = doc && doc.createElement(\"DiV\"),\n\n\t\thas = req.has = function(name){\n\t\t\treturn hasCache[name] = isFunction(hasCache[name]) ? hasCache[name](global, doc, element) : hasCache[name];\n\t\t},\n\n\t\thasCache = has.cache = defaultConfig.hasCache;\n\n\thas.add = function(name, test, now, force){\n\t\t(hasCache[name]===undefined || force) && (hasCache[name] = test);\n\t\treturn now && has(name);\n\t};\n\n\tfalse && has.add(\"host-node\", typeof process == \"object\" && /node(\\.exe)?$/.test(process.execPath));\n\tif(0){\n\t\t// fixup the default config for node.js environment\n\t\trequire(\"./_base/configNode.js\").config(defaultConfig);\n\t\t// remember node's require (with respect to baseUrl==dojo's root)\n\t\tdefaultConfig.loaderPatch.nodeRequire = require;\n\t}\n\n\tfalse && has.add(\"host-rhino\", typeof load == \"function\" && (typeof Packages == \"function\" || typeof Packages == \"object\"));\n\tif(0){\n\t\t// owing to rhino's lame feature that hides the source of the script, give the user a way to specify the baseUrl...\n\t\tfor(var baseUrl = userConfig.baseUrl || \".\", arg, rhinoArgs = this.arguments, i = 0; i < rhinoArgs.length;){\n\t\t\targ = (rhinoArgs[i++] + \"\").split(\"=\");\n\t\t\tif(arg[0] == \"baseUrl\"){\n\t\t\t\tbaseUrl = arg[1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tload(baseUrl + \"/_base/configRhino.js\");\n\t\trhinoDojoConfig(defaultConfig, baseUrl, rhinoArgs);\n\t}\n\n\t// userConfig has tests override defaultConfig has tests; do this after the environment detection because\n\t// the environment detection usually sets some has feature values in the hasCache.\n\tfor(var p in userConfig.has){\n\t\thas.add(p, userConfig.has[p], 0, 1);\n\t}\n\n\t//\n\t// define the loader data\n\t//\n\n\t// the loader will use these like symbols if the loader has the traceApi; otherwise\n\t// define magic numbers so that modules can be provided as part of defaultConfig\n\tvar\trequested = 1,\n\t\tarrived = 2,\n\t\tnonmodule = 3,\n\t\texecuting = 4,\n\t\texecuted = 5;\n\n\tif(0){\n\t\t// these make debugging nice; but using strings for symbols is a gross rookie error; don't do it for production code\n\t\trequested = \"requested\";\n\t\tarrived = \"arrived\";\n\t\tnonmodule = \"not-a-module\";\n\t\texecuting = \"executing\";\n\t\texecuted = \"executed\";\n\t}\n\n\tvar legacyMode = 0,\n\t\tsync = \"sync\",\n\t\txd = \"xd\",\n\t\tsyncExecStack = [],\n\t\tdojoRequirePlugin = 0,\n\t\tcheckDojoRequirePlugin = noop,\n\t\ttransformToAmd = noop,\n\t\tgetXhr;\n\tif(1){\n\t\treq.isXdUrl = noop;\n\n\t\treq.initSyncLoader = function(dojoRequirePlugin_, checkDojoRequirePlugin_, transformToAmd_){\n\t\t\tif(!dojoRequirePlugin){\n\t\t\t\tdojoRequirePlugin = dojoRequirePlugin_;\n\t\t\t\tcheckDojoRequirePlugin = checkDojoRequirePlugin_;\n\t\t\t\ttransformToAmd = transformToAmd_;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tsync:sync,\n\t\t\t\txd:xd,\n\t\t\t\tarrived:arrived,\n\t\t\t\tnonmodule:nonmodule,\n\t\t\t\texecuting:executing,\n\t\t\t\texecuted:executed,\n\t\t\t\tsyncExecStack:syncExecStack,\n\t\t\t\tmodules:modules,\n\t\t\t\texecQ:execQ,\n\t\t\t\tgetModule:getModule,\n\t\t\t\tinjectModule:injectModule,\n\t\t\t\tsetArrived:setArrived,\n\t\t\t\tsignal:signal,\n\t\t\t\tfinishExec:finishExec,\n\t\t\t\texecModule:execModule,\n\t\t\t\tdojoRequirePlugin:dojoRequirePlugin,\n\t\t\t\tgetLegacyMode:function(){return legacyMode;},\n\t\t\t\tholdIdle:function(){checkCompleteGuard++;},\n\t\t\t\treleaseIdle:function(){checkIdle();}\n\t\t\t};\n\t\t};\n\n\t\tif(1){\n\t\t\t// in legacy sync mode, the loader needs a minimal XHR library to load dojo/_base/loader and ojo/_base/xhr;\n\t\t\t// when dojo/_base/loader pushes the sync loader machinery into the loader (via initSyncLoader), getText is\n\t\t\t// replaced by dojo.getXhr() which allows for both sync and async op(and other features. It is not a problem\n\t\t\t// depending on dojo for the sync loader since the sync loader will never be used without dojo.\n\n\t\t\tvar locationProtocol = location.protocol,\n\t\t\t\tlocationHost = location.host,\n\t\t\t\tfileProtocol = !locationHost;\n\t\t\treq.isXdUrl = function(url){\n\t\t\t\tif(fileProtocol || /^\\./.test(url)){\n\t\t\t\t\t// begins with a dot is always relative to page URL; therefore not xdomain\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif(/^\\/\\//.test(url)){\n\t\t\t\t\t// for v1.6- backcompat, url starting with // indicates xdomain\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// get protocol and host\n\t\t\t\tvar match = url.match(/^([^\\/\\:]+\\:)\\/\\/([^\\/]+)/);\n\t\t\t\treturn match && (match[1] != locationProtocol || match[2] != locationHost);\n\t\t\t};\n\n\t\t\t// note: to get the file:// protocol to work in FF, you must set security.fileuri.strict_origin_policy to false in about:config\n\t\t\ttrue || has.add(\"dojo-xhr-factory\", 1);\n\t\t\thas.add(\"dojo-force-activex-xhr\", 1 && !doc.addEventListener && window.location.protocol == \"file:\");\n\t\t\thas.add(\"native-xhr\", typeof XMLHttpRequest != \"undefined\");\n\t\t\tif(has(\"native-xhr\") && !has(\"dojo-force-activex-xhr\")){\n\t\t\t\tgetXhr = function(){\n\t\t\t\t\treturn new XMLHttpRequest();\n\t\t\t\t};\n\t\t\t}else{\n\t\t\t\t// if in the browser an old IE; find an xhr\n\t\t\t\tfor(var XMLHTTP_PROGIDS = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'], progid, i = 0; i < 3;){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tprogid = XMLHTTP_PROGIDS[i++];\n\t\t\t\t\t\tif(new ActiveXObject(progid)){\n\t\t\t\t\t\t\t// this progid works; therefore, use it from now on\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}catch(e){\n\t\t\t\t\t\t// squelch; we're just trying to find a good ActiveX progid\n\t\t\t\t\t\t// if they all fail, then progid ends up as the last attempt and that will signal the error\n\t\t\t\t\t\t// the first time the client actually tries to exec an xhr\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgetXhr = function(){\n\t\t\t\t\treturn new ActiveXObject(progid);\n\t\t\t\t};\n\t\t\t}\n\t\t\treq.getXhr = getXhr;\n\n\t\t\thas.add(\"dojo-gettext-api\", 1);\n\t\t\treq.getText = function(url, async, onLoad){\n\t\t\t\tvar xhr = getXhr();\n\t\t\t\txhr.open('GET', fixupUrl(url), false);\n\t\t\t\txhr.send(null);\n\t\t\t\tif(xhr.status == 200 || (!location.host && !xhr.status)){\n\t\t\t\t\tif(onLoad){\n\t\t\t\t\t\tonLoad(xhr.responseText, async);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tthrow makeError(\"xhrFailed\", xhr.status);\n\t\t\t\t}\n\t\t\t\treturn xhr.responseText;\n\t\t\t};\n\t\t}\n\t}else{\n\t\treq.async = 1;\n\t}\n\n\t//\n\t// loader eval\n\t//\n\tvar eval_ =\n\t\t// use the function constructor so our eval is scoped close to (but not in) in the global space with minimal pollution\n\t\tnew Function(\"__text\", 'return eval(__text);');\n\n\treq.eval =\n\t\tfunction(text, hint){\n\t\t\treturn eval_(text + \"\\r\\n////@ sourceURL=\" + hint);\n\t\t};\n\n\t//\n\t// loader micro events API\n\t//\n\tvar listenerQueues = {},\n\t\terror = \"error\",\n\t\tsignal = req.signal = function(type, args){\n\t\t\tvar queue = listenerQueues[type];\n\t\t\t// notice we run a copy of the queue; this allows listeners to add/remove\n\t\t\t// other listeners without affecting this particular signal\n\t\t\tforEach(queue && queue.slice(0), function(listener){\n\t\t\t\tlistener.apply(null, isArray(args) ? args : [args]);\n\t\t\t});\n\t\t},\n\t\ton = req.on = function(type, listener){\n\t\t\t// notice a queue is not created until a client actually connects\n\t\t\tvar queue = listenerQueues[type] || (listenerQueues[type] = []);\n\t\t\tqueue.push(listener);\n\t\t\treturn {\n\t\t\t\tremove:function(){\n\t\t\t\t\tfor(var i = 0; i<queue.length; i++){\n\t\t\t\t\t\tif(queue[i]===listener){\n\t\t\t\t\t\t\tqueue.splice(i, 1);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t// configuration machinery; with an optimized/built defaultConfig, all configuration machinery can be discarded\n\t// lexical variables hold key loader data structures to help with minification; these may be completely,\n\t// one-time initialized by defaultConfig for optimized/built versions\n\tvar\n\t\taliases\n\t\t\t// a vector of pairs of [regexs or string, replacement] => (alias, actual)\n\t\t\t= [],\n\n\t\tpaths\n\t\t\t// CommonJS paths\n\t\t\t= {},\n\n\t\tpathsMapProg\n\t\t\t// list of (from-path, to-path, regex, length) derived from paths;\n\t\t\t// a \"program\" to apply paths; see computeMapProg\n\t\t\t= [],\n\n\t\tpacks\n\t\t\t// a map from packageId to package configuration object; see fixupPackageInfo\n\t\t\t= {},\n\n\t\tpackageMap\n\t\t\t// map from package name to local-installed package name\n\t\t\t= {},\n\n\t\tpackageMapProg\n\t\t\t// list of (from-package, to-package, regex, length) derived from packageMap;\n\t\t\t// a \"program\" to apply paths; see computeMapProg\n\t\t\t= [],\n\n\t\tmodules\n\t\t\t// A hash:(mid) --> (module-object) the module namespace\n\t\t\t//\n\t\t\t// pid: the package identifier to which the module belongs (e.g., \"dojo\"); \"\" indicates the system or default package\n\t\t\t// mid: the fully-resolved (i.e., mappings have been applied) module identifier without the package identifier (e.g., \"dojo/io/script\")\n\t\t\t// url: the URL from which the module was retrieved\n\t\t\t// pack: the package object of the package to which the module belongs\n\t\t\t// executed: 0 => not executed; executing => in the process of tranversing deps and running factory; executed => factory has been executed\n\t\t\t// deps: the dependency vector for this module (vector of modules objects)\n\t\t\t// def: the factory for this module\n\t\t\t// result: the result of the running the factory for this module\n\t\t\t// injected: (requested | arrived | nonmodule) the status of the module; nonmodule means the resource did not call define\n\t\t\t// load: plugin load function; applicable only for plugins\n\t\t\t//\n\t\t\t// Modules go through several phases in creation:\n\t\t\t//\n\t\t\t// 1. Requested: some other module's definition or a require application contained the requested module in\n\t\t\t//    its dependency vector or executing code explicitly demands a module via req.require.\n\t\t\t//\n\t\t\t// 2. Injected: a script element has been appended to the insert-point element demanding the resource implied by the URL\n\t\t\t//\n\t\t\t// 3. Loaded: the resource injected in [2] has been evalated.\n\t\t\t//\n\t\t\t// 4. Defined: the resource contained a define statement that advised the loader about the module. Notice that some\n\t\t\t//    resources may just contain a bundle of code and never formally define a module via define\n\t\t\t//\n\t\t\t// 5. Evaluated: the module was defined via define and the loader has evaluated the factory and computed a result.\n\t\t\t= {},\n\n\t\tcacheBust\n\t\t\t// query string to append to module URLs to bust browser cache\n\t\t\t= \"\",\n\n\t\tcache\n\t\t\t// hash:(mid)-->(function)\n\t\t\t//\n\t\t\t// Gives the contents of a cached resource; function should cause the same actions as if the given mid was downloaded\n\t\t\t// and evaluated by the host environment\n\t\t\t = {},\n\n\t\tpendingCacheInsert\n\t\t\t// hash:(mid)-->(function)\n\t\t\t//\n\t\t\t// Gives a set of cache modules pending entry into cache. When cached modules are published to the loader, they are\n\t\t\t// entered into pendingCacheInsert; modules are then pressed into cache upon (1) AMD define or (2) upon receiving another\n\t\t\t// independent set of cached modules. (1) is the usual case, and this case allows normalizing mids given in the pending\n\t\t\t// cache for the local configuration, possibly relocating modules.\n\t\t\t = {},\n\n\t\tdojoSniffConfig\n\t\t\t// map of configuration variables\n\t\t\t// give the data-dojo-config as sniffed from the document (if any)\n\t\t\t= {};\n\n\tif(1){\n\t\tvar consumePendingCacheInsert = function(referenceModule){\n\t\t\t\tfor(var p in pendingCacheInsert){\n\t\t\t\t\tvar match = p.match(/^url\\:(.+)/);\n\t\t\t\t\tif(match){\n\t\t\t\t\t\tcache[toUrl(match[1], referenceModule)] =  pendingCacheInsert[p];\n\t\t\t\t\t}else if(p!=\"*noref\"){\n\t\t\t\t\t\tcache[getModuleInfo(p, referenceModule).mid] = pendingCacheInsert[p];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpendingCacheInsert = {};\n\t\t\t},\n\n\t\t\tcomputeMapProg = function(map, dest, packName){\n\t\t\t\t// This routine takes a map target-prefix(string)-->replacement(string) into a vector\n\t\t\t\t// of quads (target-prefix, replacement, regex-for-target-prefix, length-of-target-prefix)\n\t\t\t\t//\n\t\t\t\t// The loader contains processes that map one string prefix to another. These\n\t\t\t\t// are encountered when applying the requirejs paths configuration and when mapping\n\t\t\t\t// package names. We can make the mapping and any replacement easier and faster by\n\t\t\t\t// replacing the map with a vector of quads and then using this structure in the simple machine runMapProg.\n\t\t\t\tdest.splice(0, dest.length);\n\t\t\t\tvar p, i, item, reverseName = 0;\n\t\t\t\tfor(p in map){\n\t\t\t\t\tdest.push([p, map[p]]);\n\t\t\t\t\tif(map[p]==packName){\n\t\t\t\t\t\treverseName = p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdest.sort(function(lhs, rhs){\n\t\t\t\t\treturn rhs[0].length - lhs[0].length;\n\t\t\t\t});\n\t\t\t\tfor(i = 0; i < dest.length;){\n\t\t\t\t\titem = dest[i++];\n\t\t\t\t\titem[2] = new RegExp(\"^\" + item[0].replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, function(c){ return \"\\\\\" + c; }) + \"(\\/|$)\");\n\t\t\t\t\titem[3] = item[0].length + 1;\n\t\t\t\t}\n\t\t\t\treturn reverseName;\n\t\t\t},\n\n\t\t\tfixupPackageInfo = function(packageInfo, baseUrl){\n\t\t\t\t// calculate the precise (name, baseUrl, main, mappings) for a package\n\t\t\t\tvar name = packageInfo.name;\n\t\t\t\tif(!name){\n\t\t\t\t\t// packageInfo must be a string that gives the name\n\t\t\t\t\tname = packageInfo;\n\t\t\t\t\tpackageInfo = {name:name};\n\t\t\t\t}\n\t\t\t\tpackageInfo = mix({main:\"main\", mapProg:[]}, packageInfo);\n\t\t\t\tpackageInfo.location = (baseUrl || \"\") + (packageInfo.location ? packageInfo.location : name);\n\t\t\t\tpackageInfo.reverseName = computeMapProg(packageInfo.packageMap, packageInfo.mapProg, name);\n\n\t\t\t\tif(!packageInfo.main.indexOf(\"./\")){\n\t\t\t\t\tpackageInfo.main = packageInfo.main.substring(2);\n\t\t\t\t}\n\n\t\t\t\t// allow paths to be specified in the package info\n\t\t\t\t// TODO: this is not supported; remove\n\t\t\t\tmix(paths, packageInfo.paths);\n\n\t\t\t\t// now that we've got a fully-resolved package object, push it into the configuration\n\t\t\t\tpacks[name] = packageInfo;\n\t\t\t\tpackageMap[name] = name;\n\t\t\t},\n\n\t\t\tconfig = function(config, booting){\n\t\t\t\tfor(var p in config){\n\t\t\t\t\tif(p==\"waitSeconds\"){\n\t\t\t\t\t\treq.waitms = (config[p] || 0) * 1000;\n\t\t\t\t\t}\n\t\t\t\t\tif(p==\"cacheBust\"){\n\t\t\t\t\t\tcacheBust = config[p] ? (isString(config[p]) ? config[p] : (new Date()).getTime() + \"\") : \"\";\n\t\t\t\t\t}\n\t\t\t\t\tif(p==\"baseUrl\" || p==\"combo\"){\n\t\t\t\t\t\treq[p] = config[p];\n\t\t\t\t\t}\n\t\t\t\t\tif(1 && p==\"async\"){\n\t\t\t\t\t\t// falsy or \"sync\" => legacy sync loader\n\t\t\t\t\t\t// \"xd\" => sync but loading xdomain tree and therefore loading asynchronously (not configurable, set automatically by the loader)\n\t\t\t\t\t\t// \"legacyAsync\" => permanently in \"xd\" by choice\n\t\t\t\t\t\t// \"debugAtAllCosts\" => trying to load everything via script injection (not implemented)\n\t\t\t\t\t\t// otherwise, must be truthy => AMD\n\t\t\t\t\t\tvar mode = config[p];\n\t\t\t\t\t\treq.legacyMode = legacyMode = (isString(mode) && /sync|legacyAsync/.test(mode) ? mode : (!mode ? \"sync\" : false));\n\t\t\t\t\t\treq.async = !legacyMode;\n\t\t\t\t\t}\n\t\t\t\t\tif(config[p]!==hasCache){\n\t\t\t\t\t\t// accumulate raw config info for client apps which can use this to pass their own config\n\t\t\t\t\t\treq.rawConfig[p] = config[p];\n\t\t\t\t\t\tp!=\"has\" && has.add(\"config-\"+p, config[p], 0, booting);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// make sure baseUrl exists\n\t\t\t\tif(!req.baseUrl){\n\t\t\t\t\treq.baseUrl = \"./\";\n\t\t\t\t}\n\t\t\t\t// make sure baseUrl ends with a slash\n\t\t\t\tif(!/\\/$/.test(req.baseUrl)){\n\t\t\t\t\treq.baseUrl += \"/\";\n\t\t\t\t}\n\n\t\t\t\t// now do the special work for has, packages, packagePaths, paths, aliases, and cache\n\n\t\t\t\tfor(p in config.has){\n\t\t\t\t\thas.add(p, config.has[p], 0, booting);\n\t\t\t\t}\n\n\t\t\t\t// for each package found in any packages config item, augment the packs map owned by the loader\n\t\t\t\tforEach(config.packages, fixupPackageInfo);\n\n\t\t\t\t// for each packagePath found in any packagePaths config item, augment the packs map owned by the loader\n\t\t\t\tfor(baseUrl in config.packagePaths){\n\t\t\t\t\tforEach(config.packagePaths[baseUrl], function(packageInfo){\n\t\t\t\t\t\tfixupPackageInfo(packageInfo, baseUrl + \"/\");\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// push in any paths and recompute the internal pathmap\n\t\t\t\t// warning: this cann't be done until the package config is processed since packages may include path info\n\t\t\t\tcomputeMapProg(mix(paths, config.paths), pathsMapProg);\n\n\t\t\t\t// aliases\n\t\t\t\tforEach(config.aliases, function(pair){\n\t\t\t\t\tif(isString(pair[0])){\n\t\t\t\t\t\tpair[0] = new RegExp(\"^\" + pair[0].replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, function(c){return \"\\\\\" + c;}) + \"$\");\n\t\t\t\t\t}\n\t\t\t\t\taliases.push(pair);\n\t\t\t\t});\n\n\t\t\t\t// mix any packageMap config item and recompute the internal packageMapProg\n\t\t\t\tcomputeMapProg(mix(packageMap, config.packageMap), packageMapProg);\n\n\t\t\t\t// push in any new cache values\n\t\t\t\tif(config.cache){\n\t\t\t\t\tconsumePendingCacheInsert();\n\t\t\t\t\tpendingCacheInsert = config.cache;\n\t\t\t\t\tif(config.cache[\"*noref\"]){\n\t\t\t\t\t\tconsumePendingCacheInsert();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsignal(\"config\", [config, req.rawConfig]);\n\t\t\t};\n\n\t\t//\n\t\t// execute the various sniffs\n\t\t//\n\n\t\tif(1){\n\t\t\tfor(var src, match, scripts = doc.getElementsByTagName(\"script\"), i = 0; i < scripts.length && !match; i++){\n\t\t\t\tif((src = scripts[i].getAttribute(\"src\")) && (match = src.match(/(.*)\\/?dojo\\.js(\\W|$)/i))){\n\t\t\t\t\t// if baseUrl wasn't explicitly set, set it here to the dojo directory; this is the 1.6- behavior\n\t\t\t\t\tuserConfig.baseUrl = userConfig.baseUrl || defaultConfig.baseUrl || match[1];\n\n\t\t\t\t\t// see if there's a dojo configuration stuffed into the node\n\t\t\t\t\tsrc = (scripts[i].getAttribute(\"data-dojo-config\") || scripts[i].getAttribute(\"djConfig\"));\n\t\t\t\t\tif(src){\n\t\t\t\t\t\tdojoSniffConfig = req.eval(\"({ \" + src + \" })\", \"data-dojo-config\");\n\t\t\t\t\t}\n\t\t\t\t\tif(0){\n\t\t\t\t\t\tvar dataMain = scripts[i].getAttribute(\"data-main\");\n\t\t\t\t\t\tif(dataMain){\n\t\t\t\t\t\t\tdojoSniffConfig.deps = dojoSniffConfig.deps || [dataMain];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(0){\n\t\t\t// pass down doh.testConfig from parent as if it were a data-dojo-config\n\t\t\ttry{\n\t\t\t\tif(window.parent != window && window.parent.require){\n\t\t\t\t\tvar doh = window.parent.require(\"doh\");\n\t\t\t\t\tdoh && mix(dojoSniffConfig, doh.testConfig);\n\t\t\t\t}\n\t\t\t}catch(e){}\n\t\t}\n\n\t\t// configure the loader; let the user override defaults\n\t\treq.rawConfig = {};\n\t\tconfig(defaultConfig, 1);\n\t\tconfig(userConfig, 1);\n\t\tconfig(dojoSniffConfig, 1);\n\t}else{\n\t\t// no config API, assume defaultConfig has everything the loader needs...for the entire lifetime of the application\n\t\tpaths = defaultConfig.paths;\n\t\tpathsMapProg = defaultConfig.pathsMapProg;\n\t\tpacks = defaultConfig.packs;\n\t\taliases = defaultConfig.aliases;\n\t\tpackageMap = defaultConfig.packageMap;\n\t\tpackageMapProg = defaultConfig.packageMapProg;\n\t\tmodules = defaultConfig.modules;\n\t\tcache = defaultConfig.cache;\n\t\tcacheBust = defaultConfig.cacheBust;\n\n\t\t// remember the default config for other processes (e.g., dojo/config)\n\t\treq.rawConfig = defaultConfig;\n\t}\n\n\n\tif(0){\n\t\treq.combo = req.combo || {add:noop};\n\t\tvar\tcomboPending = 0,\n\t\t\tcombosPending = [],\n\t\t\tcomboPendingTimer = null;\n\t}\n\n\n\t// build the loader machinery iaw configuration, including has feature tests\n\tvar\tinjectDependencies = function(module){\n\t\t\t// checkComplete!=0 holds the idle signal; we're not idle if we're injecting dependencies\n\t\t\tcheckCompleteGuard++;\n\t\t\tforEach(module.deps, injectModule);\n\t\t\tif(0 && comboPending && !comboPendingTimer){\n\t\t\t\tcomboPendingTimer = setTimeout(function() {\n\t\t\t\t\tcomboPending = 0;\n\t\t\t\t\tcomboPendingTimer = null;\n\t\t\t\t\treq.combo.done(function(mids, url) {\n\t\t\t\t\t\tvar onLoadCallback= function(){\n\t\t\t\t\t\t\t// defQ is a vector of module definitions 1-to-1, onto mids\n\t\t\t\t\t\t\trunDefQ(0, mids);\n\t\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t\t};\n\t\t\t\t\t\tcombosPending.push(mids);\n\t\t\t\t\t\tinjectingModule = mids;\n\t\t\t\t\t\treq.injectUrl(url, onLoadCallback, mids);\n\t\t\t\t\t\tinjectingModule = 0;\n\t\t\t\t\t}, req);\n\t\t\t\t}, 0);\n\t\t\t}\n\t\t\tcheckIdle();\n\t\t},\n\n\t\tcontextRequire = function(a1, a2, a3, referenceModule, contextRequire){\n\t\t\tvar module, syntheticMid;\n\t\t\tif(isString(a1)){\n\t\t\t\t// signature is (moduleId)\n\t\t\t\tmodule = getModule(a1, referenceModule, true);\n\t\t\t\tif(module && module.executed){\n\t\t\t\t\treturn module.result;\n\t\t\t\t}\n\t\t\t\tthrow makeError(\"undefinedModule\", a1);\n\t\t\t}\n\t\t\tif(!isArray(a1)){\n\t\t\t\t// a1 is a configuration\n\t\t\t\tconfig(a1);\n\n\t\t\t\t// juggle args; (a2, a3) may be (dependencies, callback)\n\t\t\t\ta1 = a2;\n\t\t\t\ta2 = a3;\n\t\t\t}\n\t\t\tif(isArray(a1)){\n\t\t\t\t// signature is (requestList [,callback])\n\n\t\t\t\tsyntheticMid = \"require*\" + uid();\n\n\t\t\t\t// resolve the request list with respect to the reference module\n\t\t\t\tfor(var mid, deps = [], i = 0; i < a1.length;){\n\t\t\t\t\tmid = a1[i++];\n\t\t\t\t\tif(mid in {exports:1, module:1}){\n\t\t\t\t\t\tthrow makeError(\"illegalModuleId\", mid);\n\t\t\t\t\t}\n\t\t\t\t\tdeps.push(getModule(mid, referenceModule));\n\t\t\t\t}\n\n\t\t\t\t// construct a synthetic module to control execution of the requestList, and, optionally, callback\n\t\t\t\tmodule = mix(makeModuleInfo(\"\", syntheticMid, 0, \"\"), {\n\t\t\t\t\tinjected: arrived,\n\t\t\t\t\tdeps: deps,\n\t\t\t\t\tdef: a2 || noop,\n\t\t\t\t\trequire: referenceModule ? referenceModule.require : req\n\t\t\t\t});\n\t\t\t\tmodules[module.mid] = module;\n\n\t\t\t\t// checkComplete!=0 holds the idle signal; we're not idle if we're injecting dependencies\n\t\t\t\tinjectDependencies(module);\n\n\t\t\t\t// try to immediately execute\n\t\t\t\t// if already traversing a factory tree, then strict causes circular dependency to abort the execution; maybe\n\t\t\t\t// it's possible to execute this require later after the current traversal completes and avoid the circular dependency.\n\t\t\t\t// ...but *always* insist on immediate in synch mode\n\t\t\t\tvar strict = checkCompleteGuard && req.async;\n\t\t\t\tcheckCompleteGuard++;\n\t\t\t\texecModule(module, strict);\n\t\t\t\tcheckIdle();\n\t\t\t\tif(!module.executed){\n\t\t\t\t\t// some deps weren't on board or circular dependency detected and strict; therefore, push into the execQ\n\t\t\t\t\texecQ.push(module);\n\t\t\t\t}\n\t\t\t\tcheckComplete();\n\t\t\t}\n\t\t\treturn contextRequire;\n\t\t},\n\n\t\tcreateRequire = function(module){\n\t\t\tif(!module){\n\t\t\t\treturn req;\n\t\t\t}\n\t\t\tvar result = module.require;\n\t\t\tif(!result){\n\t\t\t\tresult = function(a1, a2, a3){\n\t\t\t\t\treturn contextRequire(a1, a2, a3, module, result);\n\t\t\t\t};\n\t\t\t\tmodule.require = mix(result, req);\n\t\t\t\tresult.module = module;\n\t\t\t\tresult.toUrl = function(name){\n\t\t\t\t\treturn toUrl(name, module);\n\t\t\t\t};\n\t\t\t\tresult.toAbsMid = function(mid){\n\t\t\t\t\treturn toAbsMid(mid, module);\n\t\t\t\t};\n\t\t\t\tif(0){\n\t\t\t\t\tresult.undef = function(mid){\n\t\t\t\t\t\treq.undef(mid, module);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\n\t\texecQ =\n\t\t\t// The list of modules that need to be evaluated.\n\t\t\t[],\n\n\t\tdefQ =\n\t\t\t// The queue of define arguments sent to loader.\n\t\t\t[],\n\n\t\twaiting =\n\t\t\t// The set of modules upon which the loader is waiting for definition to arrive\n\t\t\t{},\n\n\t\tsetRequested = function(module){\n\t\t\tmodule.injected = requested;\n\t\t\twaiting[module.mid] = 1;\n\t\t\tif(module.url){\n\t\t\t\twaiting[module.url] = module.pack || 1;\n\t\t\t}\n\t\t},\n\n\t\tsetArrived = function(module){\n\t\t\tmodule.injected = arrived;\n\t\t\tdelete waiting[module.mid];\n\t\t\tif(module.url){\n\t\t\t\tdelete waiting[module.url];\n\t\t\t}\n\t\t\tif(isEmpty(waiting)){\n\t\t\t\tclearTimer();\n\t\t\t\t1 && legacyMode==xd && (legacyMode = sync);\n\t\t\t}\n\t\t},\n\n\t\texecComplete = req.idle =\n\t\t\t// says the loader has completed (or not) its work\n\t\t\tfunction(){\n\t\t\t\treturn !defQ.length && isEmpty(waiting) && !execQ.length && !checkCompleteGuard;\n\t\t\t},\n\n\t\trunMapProg = function(targetMid, map){\n\t\t\t// search for targetMid in map; return the map item if found; falsy otherwise\n\t\t\tfor(var i = 0; i < map.length; i++){\n\t\t\t\tif(map[i][2].test(targetMid)){\n\t\t\t\t\treturn map[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\n\t\tcompactPath = function(path){\n\t\t\tvar result = [],\n\t\t\t\tsegment, lastSegment;\n\t\t\tpath = path.replace(/\\\\/g, '/').split('/');\n\t\t\twhile(path.length){\n\t\t\t\tsegment = path.shift();\n\t\t\t\tif(segment==\"..\" && result.length && lastSegment!=\"..\"){\n\t\t\t\t\tresult.pop();\n\t\t\t\t\tlastSegment = result[result.length - 1];\n\t\t\t\t}else if(segment!=\".\"){\n\t\t\t\t\tresult.push(lastSegment= segment);\n\t\t\t\t} // else ignore \".\"\n\t\t\t}\n\t\t\treturn result.join(\"/\");\n\t\t},\n\n\t\tmakeModuleInfo = function(pid, mid, pack, url, cacheId){\n\t\t\tif(1){\n\t\t\t\tvar xd= req.isXdUrl(url);\n\t\t\t\treturn {pid:pid, mid:mid, pack:pack, url:url, executed:0, def:0, isXd:xd, isAmd:!!(xd || (packs[pid] && packs[pid].isAmd)), cacheId:cacheId};\n\t\t\t}else{\n\t\t\t\treturn {pid:pid, mid:mid, pack:pack, url:url, executed:0, def:0, cacheId:cacheId};\n\t\t\t}\n\t\t},\n\n\t\tgetModuleInfo_ = function(mid, referenceModule, packs, modules, baseUrl, packageMapProg, pathsMapProg, alwaysCreate){\n\t\t\t// arguments are passed instead of using lexical variables so that this function my be used independent of the loader (e.g., the builder)\n\t\t\t// alwaysCreate is useful in this case so that getModuleInfo never returns references to real modules owned by the loader\n\t\t\tvar pid, pack, midInPackage, mapProg, mapItem, path, url, result, isRelative, requestedMid, cacheId=0;\n\t\t\trequestedMid = mid;\n\t\t\tisRelative = /^\\./.test(mid);\n\t\t\tif(/(^\\/)|(\\:)|(\\.js$)/.test(mid) || (isRelative && !referenceModule)){\n\t\t\t\t// absolute path or protocol of .js filetype, or relative path but no reference module and therefore relative to page\n\t\t\t\t// whatever it is, it's not a module but just a URL of some sort\n\t\t\t\treturn makeModuleInfo(0, mid, 0, mid);\n\t\t\t}else{\n\t\t\t\t// relative module ids are relative to the referenceModule; get rid of any dots\n\t\t\t\tmid = compactPath(isRelative ? (referenceModule.mid + \"/../\" + mid) : mid);\n\t\t\t\tif(/^\\./.test(mid)){\n\t\t\t\t\tthrow makeError(\"irrationalPath\", mid);\n\t\t\t\t}\n\t\t\t\t// find the package indicated by the mid, if any\n\t\t\t\tmapProg = referenceModule && referenceModule.pack && referenceModule.pack.mapProg;\n\t\t\t\tmapItem = (mapProg && runMapProg(mid, mapProg)) || runMapProg(mid, packageMapProg);\n\t\t\t\tif(mapItem){\n\t\t\t\t\t// mid specified a module that's a member of a package; figure out the package id and module id\n\t\t\t\t\t// notice we expect pack.main to be valid with no pre or post slash\n\t\t\t\t\tpid = mapItem[1];\n\t\t\t\t\tmid = mid.substring(mapItem[3]);\n\t\t\t\t\tpack = packs[pid];\n\t\t\t\t\tif(!mid){\n\t\t\t\t\t\tmid= pack.main;\n\t\t\t\t\t}\n\t\t\t\t\tmidInPackage = mid;\n\t\t\t\t\tcacheId = pack.reverseName + \"/\" + mid;\n\t\t\t\t\tmid = pid + \"/\" + mid;\n\t\t\t\t}else{\n\t\t\t\t\tpid = \"\";\n\t\t\t\t}\n\n\t\t\t\t// search aliases\n\t\t\t\tvar candidateLength = 0,\n\t\t\t\t\tcandidate = 0;\n\t\t\t\tforEach(aliases, function(pair){\n\t\t\t\t\tvar match = mid.match(pair[0]);\n\t\t\t\t\tif(match && match.length>candidateLength){\n\t\t\t\t\t\tcandidate = isFunction(pair[1]) ? mid.replace(pair[0], pair[1]) : pair[1];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif(candidate){\n\t\t\t\t\treturn getModuleInfo_(candidate, 0, packs, modules, baseUrl, packageMapProg, pathsMapProg, alwaysCreate);\n\t\t\t\t}\n\n\t\t\t\tresult = modules[mid];\n\t\t\t\tif(result){\n\t\t\t\t\treturn alwaysCreate ? makeModuleInfo(result.pid, result.mid, result.pack, result.url, cacheId) : modules[mid];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// get here iff the sought-after module does not yet exist; therefore, we need to compute the URL given the\n\t\t\t// fully resolved (i.e., all relative indicators and package mapping resolved) module id\n\n\t\t\tmapItem = runMapProg(mid, pathsMapProg);\n\t\t\tif(mapItem){\n\t\t\t\turl = mapItem[1] + mid.substring(mapItem[3] - 1);\n\t\t\t}else if(pid){\n\t\t\t\turl = pack.location + \"/\" + midInPackage;\n\t\t\t}else if(has(\"config-tlmSiblingOfDojo\")){\n\t\t\t\turl = \"../\" + mid;\n\t\t\t}else{\n\t\t\t\turl = mid;\n\t\t\t}\n\t\t\t// if result is not absolute, add baseUrl\n\t\t\tif(!(/(^\\/)|(\\:)/.test(url))){\n\t\t\t\turl = baseUrl + url;\n\t\t\t}\n\t\t\turl += \".js\";\n\t\t\treturn makeModuleInfo(pid, mid, pack, compactPath(url), cacheId);\n\t\t},\n\n\t\tgetModuleInfo = function(mid, referenceModule){\n\t\t\treturn getModuleInfo_(mid, referenceModule, packs, modules, req.baseUrl, packageMapProg, pathsMapProg);\n\t\t},\n\n\t\tresolvePluginResourceId = function(plugin, prid, referenceModule){\n\t\t\treturn plugin.normalize ? plugin.normalize(prid, function(mid){return toAbsMid(mid, referenceModule);}) : toAbsMid(prid, referenceModule);\n\t\t},\n\n\t\tdynamicPluginUidGenerator = 0,\n\n\t\tgetModule = function(mid, referenceModule, immediate){\n\t\t\t// compute and optionally construct (if necessary) the module implied by the mid with respect to referenceModule\n\t\t\tvar match, plugin, prid, result;\n\t\t\tmatch = mid.match(/^(.+?)\\!(.*)$/);\n\t\t\tif(match){\n\t\t\t\t// name was <plugin-module>!<plugin-resource-id>\n\t\t\t\tplugin = getModule(match[1], referenceModule, immediate);\n\n\t\t\t\tif(1 && legacyMode == sync && !plugin.executed){\n\t\t\t\t\tinjectModule(plugin);\n\t\t\t\t\tif(plugin.injected===arrived && !plugin.executed){\n\t\t\t\t\t\tcheckCompleteGuard++;\n\t\t\t\t\t\texecModule(plugin);\n\t\t\t\t\t\tcheckIdle();\n\t\t\t\t\t}\n\t\t\t\t\tif(plugin.executed){\n\t\t\t\t\t\tpromoteModuleToPlugin(plugin);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// we are in xdomain mode for some reason\n\t\t\t\t\t\texecQ.unshift(plugin);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\n\t\t\t\tif(plugin.executed === executed && !plugin.load){\n\t\t\t\t\t// executed the module not knowing it was a plugin\n\t\t\t\t\tpromoteModuleToPlugin(plugin);\n\t\t\t\t}\n\n\t\t\t\t// if the plugin has not been loaded, then can't resolve the prid and  must assume this plugin is dynamic until we find out otherwise\n\t\t\t\tif(plugin.load){\n\t\t\t\t\tprid = resolvePluginResourceId(plugin, match[2], referenceModule);\n\t\t\t\t\tmid = (plugin.mid + \"!\" + (plugin.dynamic ? ++dynamicPluginUidGenerator + \"!\" : \"\") + prid);\n\t\t\t\t}else{\n\t\t\t\t\tprid = match[2];\n\t\t\t\t\tmid = plugin.mid + \"!\" + (++dynamicPluginUidGenerator) + \"!waitingForPlugin\";\n\t\t\t\t}\n\t\t\t\tresult = {plugin:plugin, mid:mid, req:createRequire(referenceModule), prid:prid};\n\t\t\t}else{\n\t\t\t\tresult = getModuleInfo(mid, referenceModule);\n\t\t\t}\n\t\t\treturn modules[result.mid] || (!immediate && (modules[result.mid] = result));\n\t\t},\n\n\t\ttoAbsMid = req.toAbsMid = function(mid, referenceModule){\n\t\t\treturn getModuleInfo(mid, referenceModule).mid;\n\t\t},\n\n\t\ttoUrl = req.toUrl = function(name, referenceModule){\n\t\t\t// name must include a filetype; fault tolerate to allow no filetype (but things like \"path/to/version2.13\" will assume filetype of \".13\")\n\t\t\tvar\tmatch = name.match(/(.+)(\\.[^\\/\\.]+?)$/),\n\t\t\t\troot = (match && match[1]) || name,\n\t\t\t\text = (match && match[2]) || \"\",\n\t\t\t\tmoduleInfo = getModuleInfo(root, referenceModule),\n\t\t\t\turl= moduleInfo.url;\n\t\t\t// recall, getModuleInfo always returns a url with a \".js\" suffix iff pid; therefore, we've got to trim it\n\t\t\turl= typeof moduleInfo.pid == \"string\" ? url.substring(0, url.length - 3) : url;\n\t\t\treturn fixupUrl(url + ext);\n\t\t},\n\n\t\tnonModuleProps = {\n\t\t\tinjected: arrived,\n\t\t\texecuted: executed,\n\t\t\tdef: nonmodule,\n\t\t\tresult: nonmodule\n\t\t},\n\n\t\tmakeCjs = function(mid){\n\t\t\treturn modules[mid] = mix({mid:mid}, nonModuleProps);\n\t\t},\n\n\t\tcjsRequireModule = makeCjs(\"require\"),\n\t\tcjsExportsModule = makeCjs(\"exports\"),\n\t\tcjsModuleModule = makeCjs(\"module\"),\n\n\t\trunFactory = function(module, args){\n\t\t\treq.trace(\"loader-run-factory\", [module.mid]);\n\t\t\tvar factory = module.def,\n\t\t\t\tresult;\n\t\t\t1 && syncExecStack.unshift(module);\n\t\t\tif(has(\"config-dojo-loader-catches\")){\n\t\t\t\ttry{\n\t\t\t\t\tresult= isFunction(factory) ? factory.apply(null, args) : factory;\n\t\t\t\t}catch(e){\n\t\t\t\t\tsignal(error, module.result = makeError(\"factoryThrew\", [module, e]));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tresult= isFunction(factory) ? factory.apply(null, args) : factory;\n\t\t\t}\n\t\t\tmodule.result = result===undefined && module.cjs ? module.cjs.exports : result;\n\t\t\t1 && syncExecStack.shift(module);\n\t\t},\n\n\t\tabortExec = {},\n\n\t\tdefOrder = 0,\n\n\t\tpromoteModuleToPlugin = function(pluginModule){\n\t\t\tvar plugin = pluginModule.result;\n\t\t\tpluginModule.dynamic = plugin.dynamic;\n\t\t\tpluginModule.normalize = plugin.normalize;\n\t\t\tpluginModule.load = plugin.load;\n\t\t\treturn pluginModule;\n\t\t},\n\n\t\tresolvePluginLoadQ = function(plugin){\n\t\t\t// plugins is a newly executed module that has a loadQ waiting to run\n\n\t\t\t// step 1: traverse the loadQ and fixup the mid and prid; remember the map from original mid to new mid\n\t\t\t// recall the original mid was created before the plugin was on board and therefore it was impossible to\n\t\t\t// compute the final mid; accordingly, prid may or may not change, but the mid will definitely change\n\t\t\tvar map = {};\n\t\t\tforEach(plugin.loadQ, function(pseudoPluginResource){\n\t\t\t\t// manufacture and insert the real module in modules\n\t\t\t\tvar pseudoMid = pseudoPluginResource.mid,\n\t\t\t\t\tprid = resolvePluginResourceId(plugin, pseudoPluginResource.prid, pseudoPluginResource.req.module),\n\t\t\t\t\tmid = plugin.dynamic ? pseudoPluginResource.mid.replace(/waitingForPlugin$/, prid) : (plugin.mid + \"!\" + prid),\n\t\t\t\t\tpluginResource = mix(mix({}, pseudoPluginResource), {mid:mid, prid:prid, injected:0});\n\t\t\t\tif(!modules[mid]){\n\t\t\t\t\t// create a new (the real) plugin resource and inject it normally now that the plugin is on board\n\t\t\t\t\tinjectPlugin(modules[mid] = pluginResource);\n\t\t\t\t} // else this was a duplicate request for the same (plugin, rid) for a nondynamic plugin\n\n\t\t\t\t// pluginResource is really just a placeholder with the wrong mid (because we couldn't calculate it until the plugin was on board)\n\t\t\t\t// mark is as arrived and delete it from modules; the real module was requested above\n\t\t\t\tmap[pseudoPluginResource.mid] = modules[mid];\n\t\t\t\tsetArrived(pseudoPluginResource);\n\t\t\t\tdelete modules[pseudoPluginResource.mid];\n\t\t\t});\n\t\t\tplugin.loadQ = 0;\n\n\t\t\t// step2: replace all references to any placeholder modules with real modules\n\t\t\tvar substituteModules = function(module){\n\t\t\t\tfor(var replacement, deps = module.deps || [], i = 0; i<deps.length; i++){\n\t\t\t\t\treplacement = map[deps[i].mid];\n\t\t\t\t\tif(replacement){\n\t\t\t\t\t\tdeps[i] = replacement;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tfor(var p in modules){\n\t\t\t\tsubstituteModules(modules[p]);\n\t\t\t}\n\t\t\tforEach(execQ, substituteModules);\n\t\t},\n\n\t\tfinishExec = function(module){\n\t\t\treq.trace(\"loader-finish-exec\", [module.mid]);\n\t\t\tmodule.executed = executed;\n\t\t\tmodule.defOrder = defOrder++;\n\t\t\t1 && forEach(module.provides, function(cb){ cb(); });\n\t\t\tif(module.loadQ){\n\t\t\t\t// the module was a plugin\n\t\t\t\tpromoteModuleToPlugin(module);\n\t\t\t\tresolvePluginLoadQ(module);\n\t\t\t}\n\t\t\t// remove all occurences of this module from the execQ\n\t\t\tfor(i = 0; i < execQ.length;){\n\t\t\t\tif(execQ[i] === module){\n\t\t\t\t\texecQ.splice(i, 1);\n\t\t\t\t}else{\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tcircleTrace = [],\n\n\t\texecModule = function(module, strict){\n\t\t\t// run the dependency vector, then run the factory for module\n\t\t\tif(module.executed === executing){\n\t\t\t\treq.trace(\"loader-circular-dependency\", [circleTrace.concat(mid).join(\"->\")]);\n\t\t\t\treturn (!module.def || strict) ? abortExec :  (module.cjs && module.cjs.exports);\n\t\t\t}\n\t\t\t// at this point the module is either not executed or fully executed\n\n\n\t\t\tif(!module.executed){\n\t\t\t\tif(!module.def){\n\t\t\t\t\treturn abortExec;\n\t\t\t\t}\n\t\t\t\tvar mid = module.mid,\n\t\t\t\t\tdeps = module.deps || [],\n\t\t\t\t\targ, argResult,\n\t\t\t\t\targs = [],\n\t\t\t\t\ti = 0;\n\n\t\t\t\tif(0){\n\t\t\t\t\tcircleTrace.push(mid);\n\t\t\t\t\treq.trace(\"loader-exec-module\", [\"exec\", circleTrace.length, mid]);\n\t\t\t\t}\n\n\t\t\t\t// for circular dependencies, assume the first module encountered was executed OK\n\t\t\t\t// modules that circularly depend on a module that has not run its factory will get\n\t\t\t\t// the premade cjs.exports===module.result. They can take a reference to this object and/or\n\t\t\t\t// add properties to it. When the module finally runs its factory, the factory can\n\t\t\t\t// read/write/replace this object. Notice that so long as the object isn't replaced, any\n\t\t\t\t// reference taken earlier while walking the deps list is still valid.\n\t\t\t\tmodule.executed = executing;\n\t\t\t\twhile(i < deps.length){\n\t\t\t\t\targ = deps[i++];\n\t\t\t\t\targResult = ((arg === cjsRequireModule) ? createRequire(module) :\n\t\t\t\t\t\t\t\t\t((arg === cjsExportsModule) ? module.cjs.exports :\n\t\t\t\t\t\t\t\t\t\t((arg === cjsModuleModule) ? module.cjs :\n\t\t\t\t\t\t\t\t\t\t\texecModule(arg, strict))));\n\t\t\t\t\tif(argResult === abortExec){\n\t\t\t\t\t\tmodule.executed = 0;\n\t\t\t\t\t\treq.trace(\"loader-exec-module\", [\"abort\", mid]);\n\t\t\t\t\t\t0 && circleTrace.pop();\n\t\t\t\t\t\treturn abortExec;\n\t\t\t\t\t}\n\t\t\t\t\targs.push(argResult);\n\t\t\t\t}\n\t\t\t\trunFactory(module, args);\n\t\t\t\tfinishExec(module);\n\t\t\t}\n\t\t\t// at this point the module is guaranteed fully executed\n\n\t\t\t0 && circleTrace.pop();\n\t\t\treturn module.result;\n\t\t},\n\n\n\t\tcheckCompleteGuard =  0,\n\n\t\tcheckComplete = function(){\n\t\t\t// keep going through the execQ as long as at least one factory is executed\n\t\t\t// plugins, recursion, cached modules all make for many execution path possibilities\n\t\t\tif(checkCompleteGuard){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcheckCompleteGuard++;\n\t\t\tcheckDojoRequirePlugin();\n\t\t\tfor(var currentDefOrder, module, i = 0; i < execQ.length;){\n\t\t\t\tcurrentDefOrder = defOrder;\n\t\t\t\tmodule = execQ[i];\n\t\t\t\texecModule(module);\n\t\t\t\tif(currentDefOrder!=defOrder){\n\t\t\t\t\t// defOrder was bumped one or more times indicating something was executed (note, this indicates\n\t\t\t\t\t// the execQ was modified, maybe a lot (for example a later module causes an earlier module to execute)\n\t\t\t\t\tcheckDojoRequirePlugin();\n\t\t\t\t\ti = 0;\n\t\t\t\t}else{\n\t\t\t\t\t// nothing happened; check the next module in the exec queue\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckIdle();\n\t\t},\n\n\t\tcheckIdle = function(){\n\t\t\tcheckCompleteGuard--;\n\t\t\tif(execComplete()){\n\t\t\t\tsignal(\"idle\", []);\n\t\t\t}\n\t\t};\n\n\n\tif(0){\n\t\treq.undef = function(moduleId, referenceModule){\n\t\t\t// In order to reload a module, it must be undefined (this routine) and then re-requested.\n\t\t\t// This is useful for testing frameworks (at least).\n\t\t\tvar module = getModule(moduleId, referenceModule);\n\t\t\tsetArrived(module);\n\t\t\tdelete modules[module.mid];\n\t\t};\n\t}\n\n\tif(1){\n\t\tvar fixupUrl= function(url){\n\t\t\t\turl += \"\"; // make sure url is a Javascript string (some paths may be a Java string)\n\t\t\t\treturn url + (cacheBust ? ((/\\?/.test(url) ? \"&\" : \"?\") + cacheBust) : \"\");\n\t\t\t},\n\n\t\t\tinjectPlugin = function(\n\t\t\t\tmodule\n\t\t\t){\n\t\t\t\t// injects the plugin module given by module; may have to inject the plugin itself\n\t\t\t\tvar plugin = module.plugin;\n\n\t\t\t\tif(plugin.executed === executed && !plugin.load){\n\t\t\t\t\t// executed the module not knowing it was a plugin\n\t\t\t\t\tpromoteModuleToPlugin(plugin);\n\t\t\t\t}\n\n\t\t\t\tvar onLoad = function(def){\n\t\t\t\t\t\tmodule.result = def;\n\t\t\t\t\t\tsetArrived(module);\n\t\t\t\t\t\tfinishExec(module);\n\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t};\n\n\t\t\t\tsetRequested(module);\n\t\t\t\tif(plugin.load){\n\t\t\t\t\tplugin.load(module.prid, module.req, onLoad);\n\t\t\t\t}else if(plugin.loadQ){\n\t\t\t\t\tplugin.loadQ.push(module);\n\t\t\t\t}else{\n\t\t\t\t\t// the unshift instead of push is important: we don't want plugins to execute as\n\t\t\t\t\t// dependencies of some other module because this may cause circles when the plugin\n\t\t\t\t\t// loadQ is run; also, generally, we want plugins to run early since they may load\n\t\t\t\t\t// several other modules and therefore can potentially unblock many modules\n\t\t\t\t\texecQ.unshift(plugin);\n\t\t\t\t\tinjectModule(plugin);\n\n\t\t\t\t\t// maybe the module was cached and is now defined...\n\t\t\t\t\tif(plugin.load){\n\t\t\t\t\t\tplugin.load(module.prid, module.req, onLoad);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// nope; queue up the plugin resource to be loaded after the plugin module is loaded\n\t\t\t\t\t\tplugin.loadQ = [module];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// for IE, injecting a module may result in a recursive execution if the module is in the cache\n\n\t\t\tcached = 0,\n\n\t\t\tinjectingModule = 0,\n\n\t\t\tinjectingCachedModule = 0,\n\n\t\t\tevalModuleText = function(text, module){\n\t\t\t\t// see def() for the injectingCachedModule bracket; it simply causes a short, safe curcuit\n\t\t\t\tinjectingCachedModule = 1;\n\t\t\t\tif(has(\"config-dojo-loader-catches\")){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tif(text===cached){\n\t\t\t\t\t\t\tcached.call(null);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\treq.eval(text, module.mid);\n\t\t\t\t\t\t}\n\t\t\t\t\t}catch(e){\n\t\t\t\t\t\tsignal(error, makeError(\"evalModuleThrew\", module));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(text===cached){\n\t\t\t\t\t\tcached.call(null);\n\t\t\t\t\t}else{\n\t\t\t\t\t\treq.eval(text, module.mid);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinjectingCachedModule = 0;\n\t\t\t},\n\n\t\t\tinjectModule = function(module){\n\t\t\t\t// Inject the module. In the browser environment, this means appending a script element into\n\t\t\t\t// the document; in other environments, it means loading a file.\n\t\t\t\t//\n\t\t\t\t// If in synchronous mode, then get the module synchronously if it's not xdomainLoading.\n\n\t\t\t\tvar mid = module.mid,\n\t\t\t\t\turl = module.url;\n\t\t\t\tif(module.executed || module.injected || waiting[mid] || (module.url && ((module.pack && waiting[module.url]===module.pack) || waiting[module.url]==1))){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif(0){\n\t\t\t\t\tvar viaCombo = 0;\n\t\t\t\t\tif(module.plugin && module.plugin.isCombo){\n\t\t\t\t\t\t// a combo plugin; therefore, must be handled by combo service\n\t\t\t\t\t\t// the prid should have already been converted to a URL (if required by the plugin) during\n\t\t\t\t\t\t// the normalze process; in any event, there is no way for the loader to know how to\n\t\t\t\t\t\t// to the conversion; therefore the third argument is zero\n\t\t\t\t\t\treq.combo.add(module.plugin.mid, module.prid, 0, req);\n\t\t\t\t\t\tviaCombo = 1;\n\t\t\t\t\t}else if(!module.plugin){\n\t\t\t\t\t\tviaCombo = req.combo.add(0, module.mid, module.url, req);\n\t\t\t\t\t}\n\t\t\t\t\tif(viaCombo){\n\t\t\t\t\t\tsetRequested(module);\n\t\t\t\t\t\tcomboPending= 1;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(module.plugin){\n\t\t\t\t\tinjectPlugin(module);\n\t\t\t\t\treturn;\n\t\t\t\t} // else a normal module (not a plugin)\n\n\t\t\t\tsetRequested(module);\n\n\t\t\t\tvar onLoadCallback = function(){\n\t\t\t\t\trunDefQ(module);\n\t\t\t\t\tif(module.injected !== arrived){\n\t\t\t\t\t\t// the script that contained the module arrived and has been executed yet\n\t\t\t\t\t\t// nothing was added to the defQ (so it wasn't an AMD module) and the module\n\t\t\t\t\t\t// wasn't marked as arrived by dojo.provide (so it wasn't a v1.6- module);\n\t\t\t\t\t\t// therefore, it must not have been a module; adjust state accordingly\n\t\t\t\t\t\tsetArrived(module);\n\t\t\t\t\t\tmix(module, nonModuleProps);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(1 && legacyMode){\n\t\t\t\t\t\t// must call checkComplete even in for sync loader because we may be in xdomainLoading mode;\n\t\t\t\t\t\t// but, if xd loading, then don't call checkComplete until out of the current sync traversal\n\t\t\t\t\t\t// in order to preserve order of execution of the dojo.required modules\n\t\t\t\t\t\t!syncExecStack.length && checkComplete();\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tcached = cache[mid] || cache[module.cacheId];\n\t\t\t\tif(cached){\n\t\t\t\t\treq.trace(\"loader-inject\", [\"cache\", module.mid, url]);\n\t\t\t\t\tevalModuleText(cached, module);\n\t\t\t\t\tonLoadCallback();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(1 && legacyMode){\n\t\t\t\t\tif(module.isXd){\n\t\t\t\t\t\t// switch to async mode temporarily?\n\t\t\t\t\t\tlegacyMode==sync && (legacyMode = xd);\n\t\t\t\t\t\t// fall through and load via script injection\n\t\t\t\t\t}else if(module.isAmd && legacyMode!=sync){\n\t\t\t\t\t\t// fall through and load via script injection\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// mode may be sync, xd, or async; module may be AMD or legacy; but module is always located on the same domain\n\t\t\t\t\t\tvar xhrCallback = function(text){\n\t\t\t\t\t\t\tif(legacyMode==sync){\n\t\t\t\t\t\t\t\t// the top of syncExecStack gives the current synchronously executing module; the loader needs\n\t\t\t\t\t\t\t\t// to know this if it has to switch to async loading in the middle of evaluating a legacy module\n\t\t\t\t\t\t\t\t// this happens when a modules dojo.require's a module that must be loaded async because it's xdomain\n\t\t\t\t\t\t\t\t// (using unshift/shift because there is no back() methods for Javascript arrays)\n\t\t\t\t\t\t\t\tsyncExecStack.unshift(module);\n\t\t\t\t\t\t\t\tevalModuleText(text, module);\n\t\t\t\t\t\t\t\tsyncExecStack.shift();\n\n\t\t\t\t\t\t\t\t// maybe the module was an AMD module\n\t\t\t\t\t\t\t\trunDefQ(module);\n\n\t\t\t\t\t\t\t\t// legacy modules never get to defineModule() => cjs and injected never set; also evaluation implies executing\n\t\t\t\t\t\t\t\tif(!module.cjs){\n\t\t\t\t\t\t\t\t\tsetArrived(module);\n\t\t\t\t\t\t\t\t\tfinishExec(module);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif(module.finish){\n\t\t\t\t\t\t\t\t\t// while synchronously evaluating this module, dojo.require was applied referencing a module\n\t\t\t\t\t\t\t\t\t// that had to be loaded async; therefore, the loader stopped answering all dojo.require\n\t\t\t\t\t\t\t\t\t// requests so they could be answered completely in the correct sequence; module.finish gives\n\t\t\t\t\t\t\t\t\t// the list of dojo.requires that must be re-applied once all target modules are available;\n\t\t\t\t\t\t\t\t\t// make a synthetic module to execute the dojo.require's in the correct order\n\n\t\t\t\t\t\t\t\t\t// compute a guarnateed-unique mid for the synthetic finish module; remember the finish vector; remove it from the reference module\n\t\t\t\t\t\t\t\t\t// TODO: can we just leave the module.finish...what's it hurting?\n\t\t\t\t\t\t\t\t\tvar finishMid = mid + \"*finish\",\n\t\t\t\t\t\t\t\t\t\tfinish = module.finish;\n\t\t\t\t\t\t\t\t\tdelete module.finish;\n\n\t\t\t\t\t\t\t\t\tdef(finishMid, [\"dojo\", (\"dojo/require!\" + finish.join(\",\")).replace(/\\./g, \"/\")], function(dojo){\n\t\t\t\t\t\t\t\t\t\tforEach(finish, function(mid){ dojo.require(mid); });\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t// unshift, not push, which causes the current traversal to be reattempted from the top\n\t\t\t\t\t\t\t\t\texecQ.unshift(getModule(finishMid));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tonLoadCallback();\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ttext = transformToAmd(module, text);\n\t\t\t\t\t\t\t\tif(text){\n\t\t\t\t\t\t\t\t\tevalModuleText(text, module);\n\t\t\t\t\t\t\t\t\tonLoadCallback();\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t// if transformToAmd returned falsy, then the module was already AMD and it can be script-injected\n\t\t\t\t\t\t\t\t\t// do so to improve debugability(even though it means another download...which probably won't happen with a good browser cache)\n\t\t\t\t\t\t\t\t\tinjectingModule = module;\n\t\t\t\t\t\t\t\t\treq.injectUrl(fixupUrl(url), onLoadCallback, module);\n\t\t\t\t\t\t\t\t\tinjectingModule = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\treq.trace(\"loader-inject\", [\"xhr\", module.mid, url, legacyMode!=sync]);\n\t\t\t\t\t\tif(has(\"config-dojo-loader-catches\")){\n\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\treq.getText(url, legacyMode!=sync, xhrCallback);\n\t\t\t\t\t\t\t}catch(e){\n\t\t\t\t\t\t\t\tsignal(error, makeError(\"xhrInjectFailed\", [module, e]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\treq.getText(url, legacyMode!=sync, xhrCallback);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} // else async mode or fell through in xdomain loading mode; either way, load by script injection\n\t\t\t\treq.trace(\"loader-inject\", [\"script\", module.mid, url]);\n\t\t\t\tinjectingModule = module;\n\t\t\t\treq.injectUrl(fixupUrl(url), onLoadCallback, module);\n\t\t\t\tinjectingModule = 0;\n\t\t\t},\n\n\t\t\tdefineModule = function(module, deps, def){\n\t\t\t\treq.trace(\"loader-define-module\", [module.mid, deps]);\n\n\t\t\t\tif(0 && module.plugin && module.plugin.isCombo){\n\t\t\t\t\t// the module is a plugin resource loaded by the combo service\n\t\t\t\t\t// note: check for module.plugin should be enough since normal plugin resources should\n\t\t\t\t\t// not follow this path; module.plugin.isCombo is future-proofing belt and suspenders\n\t\t\t\t\tmodule.result = isFunction(def) ? def() : def;\n\t\t\t\t\tsetArrived(module);\n\t\t\t\t\tfinishExec(module);\n\t\t\t\t\treturn module;\n\t\t\t\t};\n\n\t\t\t\tvar mid = module.mid;\n\t\t\t\tif(module.injected === arrived){\n\t\t\t\t\tsignal(error, makeError(\"multipleDefine\", module));\n\t\t\t\t\treturn module;\n\t\t\t\t}\n\t\t\t\tmix(module, {\n\t\t\t\t\tdeps: deps,\n\t\t\t\t\tdef: def,\n\t\t\t\t\tcjs: {\n\t\t\t\t\t\tid: module.mid,\n\t\t\t\t\t\turi: module.url,\n\t\t\t\t\t\texports: (module.result = {}),\n\t\t\t\t\t\tsetExports: function(exports){\n\t\t\t\t\t\t\tmodule.cjs.exports = exports;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// resolve deps with respect to this module\n\t\t\t\tfor(var i = 0; i < deps.length; i++){\n\t\t\t\t\tdeps[i] = getModule(deps[i], module);\n\t\t\t\t}\n\n\t\t\t\tif(1 && legacyMode && !waiting[mid]){\n\t\t\t\t\t// the module showed up without being asked for; it was probably in a <script> element\n\t\t\t\t\tinjectDependencies(module);\n\t\t\t\t\texecQ.push(module);\n\t\t\t\t\tcheckComplete();\n\t\t\t\t}\n\t\t\t\tsetArrived(module);\n\n\t\t\t\tif(!isFunction(def) && !deps.length){\n\t\t\t\t\tmodule.result = def;\n\t\t\t\t\tfinishExec(module);\n\t\t\t\t}\n\n\t\t\t\treturn module;\n\t\t\t},\n\n\t\t\trunDefQ = function(referenceModule, mids){\n\t\t\t\t// defQ is an array of [id, dependencies, factory]\n\t\t\t\t// mids (if any) is a vector of mids given by a combo service\n\t\t\t\tconsumePendingCacheInsert(referenceModule);\n\t\t\t\tvar definedModules = [],\n\t\t\t\t\tmodule, args;\n\t\t\t\twhile(defQ.length){\n\t\t\t\t\targs = defQ.shift();\n\t\t\t\t\tmids && (args[0]= mids.shift());\n\t\t\t\t\t// explicit define indicates possible multiple modules in a single file; delay injecting dependencies until defQ fully\n\t\t\t\t\t// processed since modules earlier in the queue depend on already-arrived modules that are later in the queue\n\t\t\t\t\t// TODO: what if no args[0] and no referenceModule\n\t\t\t\t\tmodule = args[0] && getModule(args[0]) || referenceModule;\n\t\t\t\t\tdefinedModules.push(defineModule(module, args[1], args[2]));\n\t\t\t\t}\n\t\t\t\tforEach(definedModules, injectDependencies);\n\t\t\t};\n\t}\n\n\tvar timerId = 0,\n\t\tclearTimer = noop,\n\t\tstartTimer = noop;\n\tif(1){\n\t\t// Timer machinery that monitors how long the loader is waiting and signals an error when the timer runs out.\n\t\tclearTimer = function(){\n\t\t\ttimerId && clearTimeout(timerId);\n\t\t\ttimerId = 0;\n\t\t},\n\n\t\tstartTimer = function(){\n\t\t\tclearTimer();\n\t\t\treq.waitms && (timerId = setTimeout(function(){\n\t\t\t\tclearTimer();\n\t\t\t\tsignal(error, makeError(\"timeout\", waiting));\n\t\t\t}, req.waitms));\n\t\t};\n\t}\n\n\tif(1){\n\t\thas.add(\"ie-event-behavior\", doc.attachEvent && (typeof opera === \"undefined\" || opera.toString() != \"[object Opera]\"));\n\t}\n\n\tif(1 && (1 || 1)){\n\t\tvar domOn = function(node, eventName, ieEventName, handler){\n\t\t\t\t// Add an event listener to a DOM node using the API appropriate for the current browser;\n\t\t\t\t// return a function that will disconnect the listener.\n\t\t\t\tif(!has(\"ie-event-behavior\")){\n\t\t\t\t\tnode.addEventListener(eventName, handler, false);\n\t\t\t\t\treturn function(){\n\t\t\t\t\t\tnode.removeEventListener(eventName, handler, false);\n\t\t\t\t\t};\n\t\t\t\t}else{\n\t\t\t\t\tnode.attachEvent(ieEventName, handler);\n\t\t\t\t\treturn function(){\n\t\t\t\t\t\tnode.detachEvent(ieEventName, handler);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t},\n\t\t\twindowOnLoadListener = domOn(window, \"load\", \"onload\", function(){\n\t\t\t\treq.pageLoaded = 1;\n\t\t\t\tdoc.readyState!=\"complete\" && (doc.readyState = \"complete\");\n\t\t\t\twindowOnLoadListener();\n\t\t\t});\n\n\t\tif(1){\n\t\t\t// if the loader is on the page, there must be at least one script element\n\t\t\t// getting its parent and then doing insertBefore solves the \"Operation Aborted\"\n\t\t\t// error in IE from appending to a node that isn't properly closed; see\n\t\t\t// dojo/tests/_base/loader/requirejs/simple-badbase.html for an example\n\t\t\tvar sibling = doc.getElementsByTagName(\"script\")[0],\n\t\t\t\tinsertPoint= sibling.parentNode;\n\t\t\treq.injectUrl = function(url, callback, owner){\n\t\t\t\t// insert a script element to the insert-point element with src=url;\n\t\t\t\t// apply callback upon detecting the script has loaded.\n\n\t\t\t\tstartTimer();\n\t\t\t\tvar node = owner.node = doc.createElement(\"script\"),\n\t\t\t\t\tonLoad = function(e){\n\t\t\t\t\t\te = e || window.event;\n\t\t\t\t\t\tvar node = e.target || e.srcElement;\n\t\t\t\t\t\tif(e.type === \"load\" || /complete|loaded/.test(node.readyState)){\n\t\t\t\t\t\t\tdisconnector();\n\t\t\t\t\t\t\tcallback && callback();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tdisconnector = domOn(node, \"load\", \"onreadystatechange\", onLoad);\n\t\t\t\tnode.type = \"text/javascript\";\n\t\t\t\tnode.charset = \"utf-8\";\n\t\t\t\tnode.src = url;\n\t\t\t\tinsertPoint.insertBefore(node, sibling);\n\t\t\t\treturn node;\n\t\t\t};\n\t\t}\n\t}\n\n\tif(1){\n\t\treq.log = function(){\n\t\t\ttry{\n\t\t\t\tfor(var i = 0; i < arguments.length; i++){\n\t\t\t\t\tconsole.log(arguments[i]);\n\t\t\t\t}\n\t\t\t}catch(e){}\n\t\t};\n\t}else{\n\t\treq.log = noop;\n\t}\n\n\tif(0){\n\t\tvar trace = req.trace = function(\n\t\t\tgroup,\t// the trace group to which this application belongs\n\t\t\targs\t// the contents of the trace\n\t\t){\n\t\t\t///\n\t\t\t// Tracing interface by group.\n\t\t\t//\n\t\t\t// Sends the contents of args to the console iff (req.trace.on && req.trace[group])\n\n\t\t\tif(trace.on && trace.group[group]){\n\t\t\t\tsignal(\"trace\", [group, args]);\n\t\t\t\tfor(var arg, dump = [], text= \"trace:\" + group + (args.length ? (\":\" + args[0]) : \"\"), i= 1; i<args.length;){\n\t\t\t\t\targ = args[i++];\n\t\t\t\t\tif(isString(arg)){\n\t\t\t\t\t\ttext += \", \" + arg;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdump.push(arg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treq.log(text);\n\t\t\t\tdump.length && dump.push(\".\");\n\t\t\t\treq.log.apply(req, dump);\n\t\t\t}\n\t\t};\n\t\tmix(trace, {\n\t\t\ton:1,\n\t\t\tgroup:{},\n\t\t\tset:function(group, value){\n\t\t\t\tif(isString(group)){\n\t\t\t\t\ttrace.group[group]= value;\n\t\t\t\t}else{\n\t\t\t\t\tmix(trace.group, group);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\ttrace.set(mix(mix(mix({}, defaultConfig.trace), userConfig.trace), dojoSniffConfig.trace));\n\t\ton(\"config\", function(config){\n\t\t\tconfig.trace && trace.set(config.trace);\n\t\t});\n\t}else{\n\t\treq.trace = noop;\n\t}\n\n\tvar def = function(\n\t\tmid,\t\t  //(commonjs.moduleId, optional) list of modules to be loaded before running factory\n\t\tdependencies, //(array of commonjs.moduleId, optional)\n\t\tfactory\t\t  //(any)\n\t){\n\t\t///\n\t\t// Advises the loader of a module factory. //Implements http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition.\n\t\t///\n\t\t//note\n\t\t// CommonJS factory scan courtesy of http://requirejs.org\n\n\t\tvar arity = arguments.length,\n\t\t\targs = 0,\n\t\t\tdefaultDeps = [\"require\", \"exports\", \"module\"];\n\n\t\tif(0){\n\t\t\tif(arity == 1 && isFunction(mid)){\n\t\t\t\tdependencies = [];\n\t\t\t\tmid.toString()\n\t\t\t\t\t.replace(/(\\/\\*([\\s\\S]*?)\\*\\/|\\/\\/(.*)$)/mg, \"\")\n\t\t\t\t\t.replace(/require\\([\"']([\\w\\!\\-_\\.\\/]+)[\"']\\)/g, function (match, dep){\n\t\t\t\t\tdependencies.push(dep);\n\t\t\t\t});\n\t\t\t\targs = [0, defaultDeps.concat(dependencies), mid];\n\t\t\t}\n\t\t}\n\t\tif(!args){\n\t\t\targs = arity == 1 ? [0, defaultDeps, mid] :\n\t\t\t\t(arity == 2 ? (isArray(mid) ? [0, mid, dependencies] : (isFunction(dependencies) ? [mid, defaultDeps, dependencies] : [mid, [], dependencies])) :\n\t\t\t\t\t[mid, dependencies, factory]);\n\t\t}\n\t\treq.trace(\"loader-define\", args.slice(0, 2));\n\t\tvar targetModule = args[0] && getModule(args[0]),\n\t\t\tmodule;\n\t\tif(targetModule && !waiting[targetModule.mid]){\n\t\t\t// given a mid that hasn't been requested; therefore, defined through means other than injecting\n\t\t\t// consequent to a require() or define() application; examples include defining modules on-the-fly\n\t\t\t// due to some code path or including a module in a script element. In any case,\n\t\t\t// there is no callback waiting to finish processing and nothing to trigger the defQ and the\n\t\t\t// dependencies are never requested; therefore, do it here.\n\t\t\tinjectDependencies(defineModule(targetModule, args[1], args[2]));\n\t\t}else if(!has(\"ie-event-behavior\") || !1 || injectingCachedModule){\n\t\t\t// not IE path: anonymous module and therefore must have been injected; therefore, onLoad will fire immediately\n\t\t\t// after script finishes being evaluated and the defQ can be run from that callback to detect the module id\n\t\t\tdefQ.push(args);\n\t\t}else{\n\t\t\t// IE path: possibly anonymous module and therefore injected; therefore, cannot depend on 1-to-1,\n\t\t\t// in-order exec of onLoad with script eval (since it's IE) and must manually detect here\n\t\t\ttargetModule = targetModule || injectingModule;\n\t\t\tif(!targetModule){\n\t\t\t\tfor(mid in waiting){\n\t\t\t\t\tmodule = modules[mid];\n\t\t\t\t\tif(module && module.node && module.node.readyState === 'interactive'){\n\t\t\t\t\t\ttargetModule = module;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(0 && !targetModule){\n\t\t\t\t\tfor(var i = 0; i<combosPending.length; i++){\n\t\t\t\t\t\ttargetModule = combosPending[i];\n\t\t\t\t\t\tif(targetModule.node && targetModule.node.readyState === 'interactive'){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttargetModule= 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(0 && isArray(targetModule)){\n\t\t\t\tinjectDependencies(defineModule(targetModule.shift(), args[1], args[2]));\n\t\t\t\tif(!targetModule.length){\n\t\t\t\t\tcombosPending.splice(i, 1);\n\t\t\t\t}\n\t\t\t}else if(targetModule){\n\t\t\t\tconsumePendingCacheInsert(targetModule);\n\t\t\t\tinjectDependencies(defineModule(targetModule, args[1], args[2]));\n\t\t\t}else{\n\t\t\t\tsignal(error, makeError(\"ieDefineFailed\", args[0]));\n\t\t\t}\n\t\t\tcheckComplete();\n\t\t}\n\t};\n\tdef.amd = {\n\t\tvendor:\"dojotoolkit.org\"\n\t};\n\n\tif(0){\n\t\treq.def = def;\n\t}\n\n\t// allow config to override default implemention of named functions; this is useful for\n\t// non-browser environments, e.g., overriding injectUrl, getText, log, etc. in node.js, Rhino, etc.\n\t// also useful for testing and monkey patching loader\n\tmix(mix(req, defaultConfig.loaderPatch), userConfig.loaderPatch);\n\n\t// now that req is fully initialized and won't change, we can hook it up to the error signal\n\ton(error, function(arg){\n\t\ttry{\n\t\t\tconsole.error(arg);\n\t\t\tif(arg instanceof Error){\n\t\t\t\tfor(var p in arg){\n\t\t\t\t\tconsole.log(p + \":\", arg[p]);\n\t\t\t\t}\n\t\t\t\tconsole.log(\".\");\n\t\t\t}\n\t\t}catch(e){}\n\t});\n\n\t// always publish these\n\tmix(req, {\n\t\tuid:uid,\n\t\tcache:cache,\n\t\tpacks:packs\n\t});\n\n\n\tif(0){\n\t\tmix(req, {\n\t\t\t// these may be interesting to look at when debugging\n\t\t\tpaths:paths,\n\t\t\taliases:aliases,\n\t\t\tpackageMap:packageMap,\n\t\t\tmodules:modules,\n\t\t\tlegacyMode:legacyMode,\n\t\t\texecQ:execQ,\n\t\t\tdefQ:defQ,\n\t\t\twaiting:waiting,\n\n\t\t\t// these are used for testing\n\t\t\t// TODO: move testing infrastructure to a different has feature\n\t\t\tpathsMapProg:pathsMapProg,\n\t\t\tpackageMapProg:packageMapProg,\n\t\t\tlistenerQueues:listenerQueues,\n\n\t\t\t// these are used by the builder (at least)\n\t\t\tcomputeMapProg:computeMapProg,\n\t\t\trunMapProg:runMapProg,\n\t\t\tcompactPath:compactPath,\n\t\t\tgetModuleInfo:getModuleInfo_\n\t\t});\n\t}\n\n\t// the loader can be defined exactly once; look for global define which is the symbol AMD loaders are\n\t// *required* to define (as opposed to require, which is optional)\n\tif(global.define){\n\t\tif(1){\n\t\t\tsignal(error, makeError(\"defineAlreadyDefined\", 0));\n\t\t}\n\t}else{\n\t\tglobal.define = def;\n\t\tglobal.require = req;\n\t}\n\n\tif(0 && req.combo && req.combo.plugins){\n\t\tvar plugins = req.combo.plugins,\n\t\t\tpluginName;\n\t\tfor(pluginName in plugins){\n\t\t\tmix(mix(getModule(pluginName), plugins[pluginName]), {isCombo:1, executed:\"executed\", load:1});\n\t\t}\n\t}\n\n\tif(1){\n\t\tvar bootDeps = defaultConfig.deps || userConfig.deps || dojoSniffConfig.deps,\n\t\t\tbootCallback = defaultConfig.deps || userConfig.callback || dojoSniffConfig.callback;\n\t\treq.boot = (bootDeps || bootCallback) ? [bootDeps || [], bootCallback] : 0;\n\t}\n\tif(!1){\n\t\t!req.async && req([\"dojo\"]);\n\t\treq.boot && req.apply(null, req.boot);\n\t}\n})\n(this.dojoConfig || this.djConfig || this.require || {}, {\n\t\tasync:0,\n\t\thasCache:{\n\t\t\t\t'config-selectorEngine':\"acme\",\n\t\t\t\t'dojo-built':1,\n\t\t\t\t'dojo-loader':1,\n\t\t\t\tdom:1,\n\t\t\t\t'host-browser':1\n\t\t},\n\t\tpackages:[\n\t\t\t\t{\n\t\t\t\t\t location:\"../dijit\",\n\t\t\t\t\t name:\"dijit\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t location:\"../dojox\",\n\t\t\t\t\t name:\"dojox\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t location:\".\",\n\t\t\t\t\t name:\"dojo\"\n\t\t\t\t}\n\t\t]\n});require({cache:{\n'dojo/_base/fx':function(){\ndefine([\"./kernel\", \"./lang\", \"../Evented\", \"./Color\", \"./connect\", \"./sniff\", \"../dom\", \"../dom-style\"], function(dojo, lang, Evented, Color, connect, has, dom, style){\n\t// module:\n\t//\t\tdojo/_base/fx\n\t// summary:\n\t//\t\tThis module defines the base dojo.fx implementation.\n\t// notes:\n\t//\t\tAnimation loosely package based on Dan Pupius' work, contributed under CLA; see\n\t//\t\thttp://pupius.co.uk/js/Toolkit.Drawing.js\n\n\tvar _mixin = lang.mixin;\n\n\tdojo._Line = function(/*int*/ start, /*int*/ end){\n\t\t//\tsummary:\n\t\t//\t\tdojo._Line is the object used to generate values from a start value\n\t\t//\t\tto an end value\n\t\t//\tstart: int\n\t\t//\t\tBeginning value for range\n\t\t//\tend: int\n\t\t//\t\tEnding value for range\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t};\n\n\tdojo._Line.prototype.getValue = function(/*float*/ n){\n\t\t//\tsummary: Returns the point on the line\n\t\t//\tn: a floating point number greater than 0 and less than 1\n\t\treturn ((this.end - this.start) * n) + this.start; // Decimal\n\t};\n\n\tdojo.Animation = function(args){\n\t\t//\tsummary:\n\t\t//\t\tA generic animation class that fires callbacks into its handlers\n\t\t//\t\tobject at various states.\n\t\t//\tdescription:\n\t\t//\t\tA generic animation class that fires callbacks into its handlers\n\t\t//\t\tobject at various states. Nearly all dojo animation functions\n\t\t//\t\treturn an instance of this method, usually without calling the\n\t\t//\t\t.play() method beforehand. Therefore, you will likely need to\n\t\t//\t\tcall .play() on instances of `dojo.Animation` when one is\n\t\t//\t\treturned.\n\t\t// args: Object\n\t\t//\t\tThe 'magic argument', mixing all the properties into this\n\t\t//\t\tanimation instance.\n\n\t\t_mixin(this, args);\n\t\tif(lang.isArray(this.curve)){\n\t\t\tthis.curve = new dojo._Line(this.curve[0], this.curve[1]);\n\t\t}\n\n\t};\n\tdojo.Animation.prototype = new Evented();\n\t// Alias to drop come 2.0:\n\tdojo._Animation = dojo.Animation;\n\n\tlang.extend(dojo.Animation, {\n\t\t// duration: Integer\n\t\t//\t\tThe time in milliseonds the animation will take to run\n\t\tduration: 350,\n\n\t/*=====\n\t\t// curve: dojo._Line|Array\n\t\t//\t\tA two element array of start and end values, or a `dojo._Line` instance to be\n\t\t//\t\tused in the Animation.\n\t\tcurve: null,\n\n\t\t// easing: Function?\n\t\t//\t\tA Function to adjust the acceleration (or deceleration) of the progress\n\t\t//\t\tacross a dojo._Line\n\t\teasing: null,\n\t=====*/\n\n\t\t// repeat: Integer?\n\t\t//\t\tThe number of times to loop the animation\n\t\trepeat: 0,\n\n\t\t// rate: Integer?\n\t\t//\t\tthe time in milliseconds to wait before advancing to next frame\n\t\t//\t\t(used as a fps timer: 1000/rate = fps)\n\t\trate: 20 /* 50 fps */,\n\n\t/*=====\n\t\t// delay: Integer?\n\t\t//\t\tThe time in milliseconds to wait before starting animation after it\n\t\t//\t\thas been .play()'ed\n\t\tdelay: null,\n\n\t\t// beforeBegin: Event?\n\t\t//\t\tSynthetic event fired before a dojo.Animation begins playing (synchronous)\n\t\tbeforeBegin: null,\n\n\t\t// onBegin: Event?\n\t\t//\t\tSynthetic event fired as a dojo.Animation begins playing (useful?)\n\t\tonBegin: null,\n\n\t\t// onAnimate: Event?\n\t\t//\t\tSynthetic event fired at each interval of a `dojo.Animation`\n\t\tonAnimate: null,\n\n\t\t// onEnd: Event?\n\t\t//\t\tSynthetic event fired after the final frame of a `dojo.Animation`\n\t\tonEnd: null,\n\n\t\t// onPlay: Event?\n\t\t//\t\tSynthetic event fired any time a `dojo.Animation` is play()'ed\n\t\tonPlay: null,\n\n\t\t// onPause: Event?\n\t\t//\t\tSynthetic event fired when a `dojo.Animation` is paused\n\t\tonPause: null,\n\n\t\t// onStop: Event\n\t\t//\t\tSynthetic event fires when a `dojo.Animation` is stopped\n\t\tonStop: null,\n\n\t=====*/\n\n\t\t_percent: 0,\n\t\t_startRepeatCount: 0,\n\n\t\t_getStep: function(){\n\t\t\tvar _p = this._percent,\n\t\t\t\t_e = this.easing\n\t\t\t;\n\t\t\treturn _e ? _e(_p) : _p;\n\t\t},\n\t\t_fire: function(/*Event*/ evt, /*Array?*/ args){\n\t\t\t//\tsummary:\n\t\t\t//\t\tConvenience function.  Fire event \"evt\" and pass it the\n\t\t\t//\t\targuments specified in \"args\".\n\t\t\t//\tdescription:\n\t\t\t//\t\tConvenience function.  Fire event \"evt\" and pass it the\n\t\t\t//\t\targuments specified in \"args\".\n\t\t\t//\t\tFires the callback in the scope of the `dojo.Animation`\n\t\t\t//\t\tinstance.\n\t\t\t//\tevt:\n\t\t\t//\t\tThe event to fire.\n\t\t\t//\targs:\n\t\t\t//\t\tThe arguments to pass to the event.\n\t\t\tvar a = args||[];\n\t\t\tif(this[evt]){\n\t\t\t\tif(dojo.config.debugAtAllCosts){\n\t\t\t\t\tthis[evt].apply(this, a);\n\t\t\t\t}else{\n\t\t\t\t\ttry{\n\t\t\t\t\t\tthis[evt].apply(this, a);\n\t\t\t\t\t}catch(e){\n\t\t\t\t\t\t// squelch and log because we shouldn't allow exceptions in\n\t\t\t\t\t\t// synthetic event handlers to cause the internal timer to run\n\t\t\t\t\t\t// amuck, potentially pegging the CPU. I'm not a fan of this\n\t\t\t\t\t\t// squelch, but hopefully logging will make it clear what's\n\t\t\t\t\t\t// going on\n\t\t\t\t\t\tconsole.error(\"exception in animation handler for:\", evt);\n\t\t\t\t\t\tconsole.error(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this; // dojo.Animation\n\t\t},\n\n\t\tplay: function(/*int?*/ delay, /*Boolean?*/ gotoStart){\n\t\t\t// summary:\n\t\t\t//\t\tStart the animation.\n\t\t\t// delay:\n\t\t\t//\t\tHow many milliseconds to delay before starting.\n\t\t\t// gotoStart:\n\t\t\t//\t\tIf true, starts the animation from the beginning; otherwise,\n\t\t\t//\t\tstarts it from its current position.\n\t\t\t// returns: dojo.Animation\n\t\t\t//\t\tThe instance to allow chaining.\n\n\t\t\tvar _t = this;\n\t\t\tif(_t._delayTimer){ _t._clearTimer(); }\n\t\t\tif(gotoStart){\n\t\t\t\t_t._stopTimer();\n\t\t\t\t_t._active = _t._paused = false;\n\t\t\t\t_t._percent = 0;\n\t\t\t}else if(_t._active && !_t._paused){\n\t\t\t\treturn _t;\n\t\t\t}\n\n\t\t\t_t._fire(\"beforeBegin\", [_t.node]);\n\n\t\t\tvar de = delay || _t.delay,\n\t\t\t\t_p = lang.hitch(_t, \"_play\", gotoStart);\n\n\t\t\tif(de > 0){\n\t\t\t\t_t._delayTimer = setTimeout(_p, de);\n\t\t\t\treturn _t;\n\t\t\t}\n\t\t\t_p();\n\t\t\treturn _t;\t// dojo.Animation\n\t\t},\n\n\t\t_play: function(gotoStart){\n\t\t\tvar _t = this;\n\t\t\tif(_t._delayTimer){ _t._clearTimer(); }\n\t\t\t_t._startTime = new Date().valueOf();\n\t\t\tif(_t._paused){\n\t\t\t\t_t._startTime -= _t.duration * _t._percent;\n\t\t\t}\n\n\t\t\t_t._active = true;\n\t\t\t_t._paused = false;\n\t\t\tvar value = _t.curve.getValue(_t._getStep());\n\t\t\tif(!_t._percent){\n\t\t\t\tif(!_t._startRepeatCount){\n\t\t\t\t\t_t._startRepeatCount = _t.repeat;\n\t\t\t\t}\n\t\t\t\t_t._fire(\"onBegin\", [value]);\n\t\t\t}\n\n\t\t\t_t._fire(\"onPlay\", [value]);\n\n\t\t\t_t._cycle();\n\t\t\treturn _t; // dojo.Animation\n\t\t},\n\n\t\tpause: function(){\n\t\t\t// summary: Pauses a running animation.\n\t\t\tvar _t = this;\n\t\t\tif(_t._delayTimer){ _t._clearTimer(); }\n\t\t\t_t._stopTimer();\n\t\t\tif(!_t._active){ return _t; /*dojo.Animation*/ }\n\t\t\t_t._paused = true;\n\t\t\t_t._fire(\"onPause\", [_t.curve.getValue(_t._getStep())]);\n\t\t\treturn _t; // dojo.Animation\n\t\t},\n\n\t\tgotoPercent: function(/*Decimal*/ percent, /*Boolean?*/ andPlay){\n\t\t\t//\tsummary:\n\t\t\t//\t\tSets the progress of the animation.\n\t\t\t//\tpercent:\n\t\t\t//\t\tA percentage in decimal notation (between and including 0.0 and 1.0).\n\t\t\t//\tandPlay:\n\t\t\t//\t\tIf true, play the animation after setting the progress.\n\t\t\tvar _t = this;\n\t\t\t_t._stopTimer();\n\t\t\t_t._active = _t._paused = true;\n\t\t\t_t._percent = percent;\n\t\t\tif(andPlay){ _t.play(); }\n\t\t\treturn _t; // dojo.Animation\n\t\t},\n\n\t\tstop: function(/*boolean?*/ gotoEnd){\n\t\t\t// summary: Stops a running animation.\n\t\t\t// gotoEnd: If true, the animation will end.\n\t\t\tvar _t = this;\n\t\t\tif(_t._delayTimer){ _t._clearTimer(); }\n\t\t\tif(!_t._timer){ return _t; /* dojo.Animation */ }\n\t\t\t_t._stopTimer();\n\t\t\tif(gotoEnd){\n\t\t\t\t_t._percent = 1;\n\t\t\t}\n\t\t\t_t._fire(\"onStop\", [_t.curve.getValue(_t._getStep())]);\n\t\t\t_t._active = _t._paused = false;\n\t\t\treturn _t; // dojo.Animation\n\t\t},\n\n\t\tstatus: function(){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a string token representation of the status of\n\t\t\t//\t\tthe animation, one of: \"paused\", \"playing\", \"stopped\"\n\t\t\tif(this._active){\n\t\t\t\treturn this._paused ? \"paused\" : \"playing\"; // String\n\t\t\t}\n\t\t\treturn \"stopped\"; // String\n\t\t},\n\n\t\t_cycle: function(){\n\t\t\tvar _t = this;\n\t\t\tif(_t._active){\n\t\t\t\tvar curr = new Date().valueOf();\n\t\t\t\tvar step = (curr - _t._startTime) / (_t.duration);\n\n\t\t\t\tif(step >= 1){\n\t\t\t\t\tstep = 1;\n\t\t\t\t}\n\t\t\t\t_t._percent = step;\n\n\t\t\t\t// Perform easing\n\t\t\t\tif(_t.easing){\n\t\t\t\t\tstep = _t.easing(step);\n\t\t\t\t}\n\n\t\t\t\t_t._fire(\"onAnimate\", [_t.curve.getValue(step)]);\n\n\t\t\t\tif(_t._percent < 1){\n\t\t\t\t\t_t._startTimer();\n\t\t\t\t}else{\n\t\t\t\t\t_t._active = false;\n\n\t\t\t\t\tif(_t.repeat > 0){\n\t\t\t\t\t\t_t.repeat--;\n\t\t\t\t\t\t_t.play(null, true);\n\t\t\t\t\t}else if(_t.repeat == -1){\n\t\t\t\t\t\t_t.play(null, true);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(_t._startRepeatCount){\n\t\t\t\t\t\t\t_t.repeat = _t._startRepeatCount;\n\t\t\t\t\t\t\t_t._startRepeatCount = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_t._percent = 0;\n\t\t\t\t\t_t._fire(\"onEnd\", [_t.node]);\n\t\t\t\t\t!_t.repeat && _t._stopTimer();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn _t; // dojo.Animation\n\t\t},\n\n\t\t_clearTimer: function(){\n\t\t\t// summary: Clear the play delay timer\n\t\t\tclearTimeout(this._delayTimer);\n\t\t\tdelete this._delayTimer;\n\t\t}\n\n\t});\n\n\t// the local timer, stubbed into all Animation instances\n\tvar ctr = 0,\n\t\ttimer = null,\n\t\trunner = {\n\t\t\trun: function(){}\n\t\t};\n\n\tlang.extend(dojo.Animation, {\n\n\t\t_startTimer: function(){\n\t\t\tif(!this._timer){\n\t\t\t\tthis._timer = connect.connect(runner, \"run\", this, \"_cycle\");\n\t\t\t\tctr++;\n\t\t\t}\n\t\t\tif(!timer){\n\t\t\t\ttimer = setInterval(lang.hitch(runner, \"run\"), this.rate);\n\t\t\t}\n\t\t},\n\n\t\t_stopTimer: function(){\n\t\t\tif(this._timer){\n\t\t\t\tconnect.disconnect(this._timer);\n\t\t\t\tthis._timer = null;\n\t\t\t\tctr--;\n\t\t\t}\n\t\t\tif(ctr <= 0){\n\t\t\t\tclearInterval(timer);\n\t\t\t\ttimer = null;\n\t\t\t\tctr = 0;\n\t\t\t}\n\t\t}\n\n\t});\n\n\tvar _makeFadeable =\n\t\t\t\thas(\"ie\") ? function(node){\n\t\t\t// only set the zoom if the \"tickle\" value would be the same as the\n\t\t\t// default\n\t\t\tvar ns = node.style;\n\t\t\t// don't set the width to auto if it didn't already cascade that way.\n\t\t\t// We don't want to f anyones designs\n\t\t\tif(!ns.width.length && style.get(node, \"width\") == \"auto\"){\n\t\t\t\tns.width = \"auto\";\n\t\t\t}\n\t\t} :\n\t\t\t\tfunction(){};\n\n\tdojo._fade = function(/*Object*/ args){\n\t\t//\tsummary:\n\t\t//\t\tReturns an animation that will fade the node defined by\n\t\t//\t\targs.node from the start to end values passed (args.start\n\t\t//\t\targs.end) (end is mandatory, start is optional)\n\n\t\targs.node = dom.byId(args.node);\n\t\tvar fArgs = _mixin({ properties: {} }, args),\n\t\t\tprops = (fArgs.properties.opacity = {});\n\n\t\tprops.start = !(\"start\" in fArgs) ?\n\t\t\tfunction(){\n\t\t\t\treturn +style.get(fArgs.node, \"opacity\")||0;\n\t\t\t} : fArgs.start;\n\t\tprops.end = fArgs.end;\n\n\t\tvar anim = dojo.animateProperty(fArgs);\n\t\tconnect.connect(anim, \"beforeBegin\", lang.partial(_makeFadeable, fArgs.node));\n\n\t\treturn anim; // dojo.Animation\n\t};\n\n\t/*=====\n\tdojo.__FadeArgs = function(node, duration, easing){\n\t\t//\tnode: DOMNode|String\n\t\t//\t\tThe node referenced in the animation\n\t\t//\tduration: Integer?\n\t\t//\t\tDuration of the animation in milliseconds.\n\t\t//\teasing: Function?\n\t\t//\t\tAn easing function.\n\t\tthis.node = node;\n\t\tthis.duration = duration;\n\t\tthis.easing = easing;\n\t}\n\t=====*/\n\n\tdojo.fadeIn = function(/*dojo.__FadeArgs*/ args){\n\t\t// summary:\n\t\t//\t\tReturns an animation that will fade node defined in 'args' from\n\t\t//\t\tits current opacity to fully opaque.\n\t\treturn dojo._fade(_mixin({ end: 1 }, args)); // dojo.Animation\n\t};\n\n\tdojo.fadeOut = function(/*dojo.__FadeArgs*/ args){\n\t\t// summary:\n\t\t//\t\tReturns an animation that will fade node defined in 'args'\n\t\t//\t\tfrom its current opacity to fully transparent.\n\t\treturn dojo._fade(_mixin({ end: 0 }, args)); // dojo.Animation\n\t};\n\n\tdojo._defaultEasing = function(/*Decimal?*/ n){\n\t\t// summary: The default easing function for dojo.Animation(s)\n\t\treturn 0.5 + ((Math.sin((n + 1.5) * Math.PI)) / 2);\t// Decimal\n\t};\n\n\tvar PropLine = function(properties){\n\t\t// PropLine is an internal class which is used to model the values of\n\t\t// an a group of CSS properties across an animation lifecycle. In\n\t\t// particular, the \"getValue\" function handles getting interpolated\n\t\t// values between start and end for a particular CSS value.\n\t\tthis._properties = properties;\n\t\tfor(var p in properties){\n\t\t\tvar prop = properties[p];\n\t\t\tif(prop.start instanceof Color){\n\t\t\t\t// create a reusable temp color object to keep intermediate results\n\t\t\t\tprop.tempColor = new Color();\n\t\t\t}\n\t\t}\n\t};\n\n\tPropLine.prototype.getValue = function(r){\n\t\tvar ret = {};\n\t\tfor(var p in this._properties){\n\t\t\tvar prop = this._properties[p],\n\t\t\t\tstart = prop.start;\n\t\t\tif(start instanceof Color){\n\t\t\t\tret[p] = Color.blendColors(start, prop.end, r, prop.tempColor).toCss();\n\t\t\t}else if(!lang.isArray(start)){\n\t\t\t\tret[p] = ((prop.end - start) * r) + start + (p != \"opacity\" ? prop.units || \"px\" : 0);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t};\n\n\t/*=====\n\tdojo.declare(\"dojo.__AnimArgs\", [dojo.__FadeArgs], {\n\t\t// Properties: Object?\n\t\t//\tA hash map of style properties to Objects describing the transition,\n\t\t//\tsuch as the properties of dojo._Line with an additional 'units' property\n\t\tproperties: {}\n\n\t\t//TODOC: add event callbacks\n\t});\n\t=====*/\n\n\tdojo.animateProperty = function(/*dojo.__AnimArgs*/ args){\n\t\t// summary:\n\t\t//\t\tReturns an animation that will transition the properties of\n\t\t//\t\tnode defined in `args` depending how they are defined in\n\t\t//\t\t`args.properties`\n\t\t//\n\t\t// description:\n\t\t//\t\t`dojo.animateProperty` is the foundation of most `dojo.fx`\n\t\t//\t\tanimations. It takes an object of \"properties\" corresponding to\n\t\t//\t\tstyle properties, and animates them in parallel over a set\n\t\t//\t\tduration.\n\t\t//\n\t\t// example:\n\t\t//\t\tA simple animation that changes the width of the specified node.\n\t\t//\t|\tdojo.animateProperty({\n\t\t//\t|\t\tnode: \"nodeId\",\n\t\t//\t|\t\tproperties: { width: 400 },\n\t\t//\t|\t}).play();\n\t\t//\t\tDojo figures out the start value for the width and converts the\n\t\t//\t\tinteger specified for the width to the more expressive but\n\t\t//\t\tverbose form `{ width: { end: '400', units: 'px' } }` which you\n\t\t//\t\tcan also specify directly. Defaults to 'px' if ommitted.\n\t\t//\n\t\t// example:\n\t\t//\t\tAnimate width, height, and padding over 2 seconds... the\n\t\t//\t\tpedantic way:\n\t\t//\t|\tdojo.animateProperty({ node: node, duration:2000,\n\t\t//\t|\t\tproperties: {\n\t\t//\t|\t\t\twidth: { start: '200', end: '400', units:\"px\" },\n\t\t//\t|\t\t\theight: { start:'200', end: '400', units:\"px\" },\n\t\t//\t|\t\t\tpaddingTop: { start:'5', end:'50', units:\"px\" }\n\t\t//\t|\t\t}\n\t\t//\t|\t}).play();\n\t\t//\t\tNote 'paddingTop' is used over 'padding-top'. Multi-name CSS properties\n\t\t//\t\tare written using \"mixed case\", as the hyphen is illegal as an object key.\n\t\t//\n\t\t// example:\n\t\t//\t\tPlug in a different easing function and register a callback for\n\t\t//\t\twhen the animation ends. Easing functions accept values between\n\t\t//\t\tzero and one and return a value on that basis. In this case, an\n\t\t//\t\texponential-in curve.\n\t\t//\t|\tdojo.animateProperty({\n\t\t//\t|\t\tnode: \"nodeId\",\n\t\t//\t|\t\t// dojo figures out the start value\n\t\t//\t|\t\tproperties: { width: { end: 400 } },\n\t\t//\t|\t\teasing: function(n){\n\t\t//\t|\t\t\treturn (n==0) ? 0 : Math.pow(2, 10 * (n - 1));\n\t\t//\t|\t\t},\n\t\t//\t|\t\tonEnd: function(node){\n\t\t//\t|\t\t\t// called when the animation finishes. The animation\n\t\t//\t|\t\t\t// target is passed to this function\n\t\t//\t|\t\t}\n\t\t//\t|\t}).play(500); // delay playing half a second\n\t\t//\n\t\t// example:\n\t\t//\t\tLike all `dojo.Animation`s, animateProperty returns a handle to the\n\t\t//\t\tAnimation instance, which fires the events common to Dojo FX. Use `dojo.connect`\n\t\t//\t\tto access these events outside of the Animation definiton:\n\t\t//\t|\tvar anim = dojo.animateProperty({\n\t\t//\t|\t\tnode:\"someId\",\n\t\t//\t|\t\tproperties:{\n\t\t//\t|\t\t\twidth:400, height:500\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\t|\tdojo.connect(anim,\"onEnd\", function(){\n\t\t//\t|\t\tconsole.log(\"animation ended\");\n\t\t//\t|\t});\n\t\t//\t|\t// play the animation now:\n\t\t//\t|\tanim.play();\n\t\t//\n\t\t// example:\n\t\t//\t\tEach property can be a function whose return value is substituted along.\n\t\t//\t\tAdditionally, each measurement (eg: start, end) can be a function. The node\n\t\t//\t\treference is passed direcly to callbacks.\n\t\t//\t|\tdojo.animateProperty({\n\t\t//\t|\t\tnode:\"mine\",\n\t\t//\t|\t\tproperties:{\n\t\t//\t|\t\t\theight:function(node){\n\t\t//\t|\t\t\t\t// shrink this node by 50%\n\t\t//\t|\t\t\t\treturn dojo.position(node).h / 2\n\t\t//\t|\t\t\t},\n\t\t//\t|\t\t\twidth:{\n\t\t//\t|\t\t\t\tstart:function(node){ return 100; },\n\t\t//\t|\t\t\t\tend:function(node){ return 200; }\n\t\t//\t|\t\t\t}\n\t\t//\t|\t\t}\n\t\t//\t|\t}).play();\n\t\t//\n\n\t\tvar n = args.node = dom.byId(args.node);\n\t\tif(!args.easing){ args.easing = dojo._defaultEasing; }\n\n\t\tvar anim = new dojo.Animation(args);\n\t\tconnect.connect(anim, \"beforeBegin\", anim, function(){\n\t\t\tvar pm = {};\n\t\t\tfor(var p in this.properties){\n\t\t\t\t// Make shallow copy of properties into pm because we overwrite\n\t\t\t\t// some values below. In particular if start/end are functions\n\t\t\t\t// we don't want to overwrite them or the functions won't be\n\t\t\t\t// called if the animation is reused.\n\t\t\t\tif(p == \"width\" || p == \"height\"){\n\t\t\t\t\tthis.node.display = \"block\";\n\t\t\t\t}\n\t\t\t\tvar prop = this.properties[p];\n\t\t\t\tif(lang.isFunction(prop)){\n\t\t\t\t\tprop = prop(n);\n\t\t\t\t}\n\t\t\t\tprop = pm[p] = _mixin({}, (lang.isObject(prop) ? prop: { end: prop }));\n\n\t\t\t\tif(lang.isFunction(prop.start)){\n\t\t\t\t\tprop.start = prop.start(n);\n\t\t\t\t}\n\t\t\t\tif(lang.isFunction(prop.end)){\n\t\t\t\t\tprop.end = prop.end(n);\n\t\t\t\t}\n\t\t\t\tvar isColor = (p.toLowerCase().indexOf(\"color\") >= 0);\n\t\t\t\tfunction getStyle(node, p){\n\t\t\t\t\t// dojo.style(node, \"height\") can return \"auto\" or \"\" on IE; this is more reliable:\n\t\t\t\t\tvar v = { height: node.offsetHeight, width: node.offsetWidth }[p];\n\t\t\t\t\tif(v !== undefined){ return v; }\n\t\t\t\t\tv = style.get(node, p);\n\t\t\t\t\treturn (p == \"opacity\") ? +v : (isColor ? v : parseFloat(v));\n\t\t\t\t}\n\t\t\t\tif(!(\"end\" in prop)){\n\t\t\t\t\tprop.end = getStyle(n, p);\n\t\t\t\t}else if(!(\"start\" in prop)){\n\t\t\t\t\tprop.start = getStyle(n, p);\n\t\t\t\t}\n\n\t\t\t\tif(isColor){\n\t\t\t\t\tprop.start = new Color(prop.start);\n\t\t\t\t\tprop.end = new Color(prop.end);\n\t\t\t\t}else{\n\t\t\t\t\tprop.start = (p == \"opacity\") ? +prop.start : parseFloat(prop.start);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.curve = new PropLine(pm);\n\t\t});\n\t\tconnect.connect(anim, \"onAnimate\", lang.hitch(style, \"set\", anim.node));\n\t\treturn anim; // dojo.Animation\n\t};\n\n\tdojo.anim = function(\t/*DOMNode|String*/\tnode,\n\t\t\t\t\t\t\t/*Object*/\t\t\tproperties,\n\t\t\t\t\t\t\t/*Integer?*/\t\tduration,\n\t\t\t\t\t\t\t/*Function?*/\t\teasing,\n\t\t\t\t\t\t\t/*Function?*/\t\tonEnd,\n\t\t\t\t\t\t\t/*Integer?*/\t\tdelay){\n\t\t//\tsummary:\n\t\t//\t\tA simpler interface to `dojo.animateProperty()`, also returns\n\t\t//\t\tan instance of `dojo.Animation` but begins the animation\n\t\t//\t\timmediately, unlike nearly every other Dojo animation API.\n\t\t//\tdescription:\n\t\t//\t\t`dojo.anim` is a simpler (but somewhat less powerful) version\n\t\t//\t\tof `dojo.animateProperty`.  It uses defaults for many basic properties\n\t\t//\t\tand allows for positional parameters to be used in place of the\n\t\t//\t\tpacked \"property bag\" which is used for other Dojo animation\n\t\t//\t\tmethods.\n\t\t//\n\t\t//\t\tThe `dojo.Animation` object returned from `dojo.anim` will be\n\t\t//\t\talready playing when it is returned from this function, so\n\t\t//\t\tcalling play() on it again is (usually) a no-op.\n\t\t//\tnode:\n\t\t//\t\ta DOM node or the id of a node to animate CSS properties on\n\t\t//\tduration:\n\t\t//\t\tThe number of milliseconds over which the animation\n\t\t//\t\tshould run. Defaults to the global animation default duration\n\t\t//\t\t(350ms).\n\t\t//\teasing:\n\t\t//\t\tAn easing function over which to calculate acceleration\n\t\t//\t\tand deceleration of the animation through its duration.\n\t\t//\t\tA default easing algorithm is provided, but you may\n\t\t//\t\tplug in any you wish. A large selection of easing algorithms\n\t\t//\t\tare available in `dojo.fx.easing`.\n\t\t//\tonEnd:\n\t\t//\t\tA function to be called when the animation finishes\n\t\t//\t\trunning.\n\t\t//\tdelay:\n\t\t//\t\tThe number of milliseconds to delay beginning the\n\t\t//\t\tanimation by. The default is 0.\n\t\t//\texample:\n\t\t//\t\tFade out a node\n\t\t//\t|\tdojo.anim(\"id\", { opacity: 0 });\n\t\t//\texample:\n\t\t//\t\tFade out a node over a full second\n\t\t//\t|\tdojo.anim(\"id\", { opacity: 0 }, 1000);\n\t\treturn dojo.animateProperty({ // dojo.Animation\n\t\t\tnode: node,\n\t\t\tduration: duration || dojo.Animation.prototype.duration,\n\t\t\tproperties: properties,\n\t\t\teasing: easing,\n\t\t\tonEnd: onEnd\n\t\t}).play(delay || 0);\n\t};\n\n\treturn {\n\t\t_Line: dojo._Line,\n\t\tAnimation: dojo.Animation,\n\t\t_fade: dojo._fade,\n\t\tfadeIn: dojo.fadeIn,\n\t\tfadeOut: dojo.fadeOut,\n\t\t_defaultEasing: dojo._defaultEasing,\n\t\tanimateProperty: dojo.animateProperty,\n\t\tanim: dojo.anim\n\t};\n});\n\n},\n'dojo/dom-form':function(){\ndefine(\"dojo/dom-form\", [\"./_base/lang\", \"./dom\", \"./io-query\", \"./json\"], function(lang, dom, ioq, json){\n\t// module:\n\t//\t\tdojo/dom-form\n\t// summary:\n\t//\t\tThis module defines form-processing functions.\n\n\t/*=====\n\tdojo.fieldToObject = function(inputNode){\n\t\t// summary:\n\t\t//\t\tSerialize a form field to a JavaScript object.\n\t\t// description:\n\t\t//\t\tReturns the value encoded in a form field as\n\t\t//\t\tas a string or an array of strings. Disabled form elements\n\t\t//\t\tand unchecked radio and checkboxes are skipped.\tMulti-select\n\t\t//\t\telements are returned as an array of string values.\n\t\t// inputNode: DOMNode|String\n\t\t// returns: Object\n\t};\n\t=====*/\n\n\t/*=====\n    dojo.formToObject = function(formNode){\n        // summary:\n        //\t\tSerialize a form node to a JavaScript object.\n        // description:\n        //\t\tReturns the values encoded in an HTML form as\n        //\t\tstring properties in an object which it then returns. Disabled form\n        //\t\telements, buttons, and other non-value form elements are skipped.\n        //\t\tMulti-select elements are returned as an array of string values.\n\t\t// formNode: DOMNode|String\n\t\t// returns: Object\n        //\n        // example:\n        //\t\tThis form:\n        //\t\t|\t<form id=\"test_form\">\n        //\t\t|\t\t<input type=\"text\" name=\"blah\" value=\"blah\">\n        //\t\t|\t\t<input type=\"text\" name=\"no_value\" value=\"blah\" disabled>\n        //\t\t|\t\t<input type=\"button\" name=\"no_value2\" value=\"blah\">\n        //\t\t|\t\t<select type=\"select\" multiple name=\"multi\" size=\"5\">\n        //\t\t|\t\t\t<option value=\"blah\">blah</option>\n        //\t\t|\t\t\t<option value=\"thud\" selected>thud</option>\n        //\t\t|\t\t\t<option value=\"thonk\" selected>thonk</option>\n        //\t\t|\t\t</select>\n        //\t\t|\t</form>\n        //\n        //\t\tyields this object structure as the result of a call to\n        //\t\tformToObject():\n        //\n        //\t\t|\t{\n        //\t\t|\t\tblah: \"blah\",\n        //\t\t|\t\tmulti: [\n        //\t\t|\t\t\t\"thud\",\n        //\t\t|\t\t\t\"thonk\"\n        //\t\t|\t\t]\n        //\t\t|\t};\n    };\n\t=====*/\n\n\t/*=====\n    dojo.formToQuery = function(formNode){\n        // summary:\n        //\t\tReturns a URL-encoded string representing the form passed as either a\n        //\t\tnode or string ID identifying the form to serialize\n\t\t// formNode: DOMNode|String\n\t\t// returns: String\n    };\n\t=====*/\n\n\t/*=====\n    dojo.formToJson = function(formNode, prettyPrint){\n        // summary:\n        //\t\tCreate a serialized JSON string from a form node or string\n        //\t\tID identifying the form to serialize\n\t\t// formNode: DOMNode|String\n\t\t// prettyPrint: Boolean?\n\t\t// returns: String\n    };\n\t=====*/\n\n    function setValue(/*Object*/obj, /*String*/name, /*String*/value){\n        // summary:\n        //\t\tFor the named property in object, set the value. If a value\n        //\t\talready exists and it is a string, convert the value to be an\n        //\t\tarray of values.\n\n        // Skip it if there is no value\n        if(value === null){\n            return;\n        }\n\n        var val = obj[name];\n        if(typeof val == \"string\"){ // inline'd type check\n            obj[name] = [val, value];\n        }else if(lang.isArray(val)){\n            val.push(value);\n        }else{\n            obj[name] = value;\n        }\n    }\n\n\tvar exclude = \"file|submit|image|reset|button\";\n\n\tvar form = {\n\t\tfieldToObject: function fieldToObject(/*DOMNode|String*/ inputNode){\n\t\t\tvar ret = null;\n\t\t\tinputNode = dom.byId(inputNode);\n\t\t\tif(inputNode){\n\t\t\t\tvar _in = inputNode.name, type = (inputNode.type || \"\").toLowerCase();\n\t\t\t\tif(_in && type && !inputNode.disabled){\n\t\t\t\t\tif(type == \"radio\" || type == \"checkbox\"){\n\t\t\t\t\t\tif(inputNode.checked){\n\t\t\t\t\t\t\tret = inputNode.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(inputNode.multiple){\n\t\t\t\t\t\tret = [];\n\t\t\t\t\t\tvar nodes = [inputNode.firstChild];\n\t\t\t\t\t\twhile(nodes.length){\n\t\t\t\t\t\t\tfor(var node = nodes.pop(); node; node = node.nextSibling){\n\t\t\t\t\t\t\t\tif(node.nodeType == 1 && node.tagName.toLowerCase() == \"option\"){\n\t\t\t\t\t\t\t\t\tif(node.selected){\n\t\t\t\t\t\t\t\t\t\tret.push(node.value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tif(node.nextSibling){\n\t\t\t\t\t\t\t\t\t\tnodes.push(node.nextSibling);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(node.firstChild){\n\t\t\t\t\t\t\t\t\t\tnodes.push(node.firstChild);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret = inputNode.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret; // Object\n\t\t},\n\n\t\ttoObject: function formToObject(/*DOMNode|String*/ formNode){\n\t\t\tvar ret = {}, elems = dom.byId(formNode).elements;\n\t\t\tfor(var i = 0, l = elems.length; i < l; ++i){\n\t\t\t\tvar item = elems[i], _in = item.name, type = (item.type || \"\").toLowerCase();\n\t\t\t\tif(_in && type && exclude.indexOf(type) < 0 && !item.disabled){\n\t\t\t\t\tsetValue(ret, _in, form.fieldToObject(item));\n\t\t\t\t\tif(type == \"image\"){\n\t\t\t\t\t\tret[_in + \".x\"] = ret[_in + \".y\"] = ret[_in].x = ret[_in].y = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret; // Object\n\t\t},\n\n\t\ttoQuery: function formToQuery(/*DOMNode|String*/ formNode){\n\t\t\treturn ioq.objectToQuery(form.toObject(formNode)); // String\n\t\t},\n\n\t\ttoJson: function formToJson(/*DOMNode|String*/ formNode, /*Boolean?*/prettyPrint){\n\t\t\treturn json.stringify(form.toObject(formNode), null, prettyPrint ? 4 : 0); // String\n\t\t}\n\t};\n\n    return form;\n});\n\n},\n'dojo/_base/html':function(){\ndefine([\"./kernel\", \"../dom\", \"../dom-style\", \"../dom-attr\", \"../dom-prop\", \"../dom-class\", \"../dom-construct\", \"../dom-geometry\"], function(dojo, dom, style, attr, prop, cls, ctr, geom){\n\t// module:\n\t//\t\tdojo/dom\n\t// summary:\n\t//\t\tThis module is a stub for the core dojo DOM API.\n\n\t// mix-in dom\n\tdojo.byId = dom.byId;\n\tdojo.isDescendant = dom.isDescendant;\n\tdojo.setSelectable = dom.setSelectable;\n\n\t// mix-in dom-attr\n\tdojo.getAttr = attr.get;\n\tdojo.setAttr = attr.set;\n\tdojo.hasAttr = attr.has;\n\tdojo.removeAttr = attr.remove;\n\tdojo.getNodeProp = attr.getNodeProp;\n\n\tdojo.attr = function(node, name, value){\n\t\t// summary:\n\t\t//\t\tGets or sets an attribute on an HTML element.\n\t\t// description:\n\t\t//\t\tHandles normalized getting and setting of attributes on DOM\n\t\t//\t\tNodes. If 2 arguments are passed, and a the second argument is a\n\t\t//\t\tstring, acts as a getter.\n\t\t//\n\t\t//\t\tIf a third argument is passed, or if the second argument is a\n\t\t//\t\tmap of attributes, acts as a setter.\n\t\t//\n\t\t//\t\tWhen passing functions as values, note that they will not be\n\t\t//\t\tdirectly assigned to slots on the node, but rather the default\n\t\t//\t\tbehavior will be removed and the new behavior will be added\n\t\t//\t\tusing `dojo.connect()`, meaning that event handler properties\n\t\t//\t\twill be normalized and that some caveats with regards to\n\t\t//\t\tnon-standard behaviors for onsubmit apply. Namely that you\n\t\t//\t\tshould cancel form submission using `dojo.stopEvent()` on the\n\t\t//\t\tpassed event object instead of returning a boolean value from\n\t\t//\t\tthe handler itself.\n\t\t// node: DOMNode|String\n\t\t//\t\tid or reference to the element to get or set the attribute on\n\t\t// name: String|Object\n\t\t//\t\tthe name of the attribute to get or set.\n\t\t// value: String?\n\t\t//\t\tThe value to set for the attribute\n\t\t// returns:\n\t\t//\t\twhen used as a getter, the value of the requested attribute\n\t\t//\t\tor null if that attribute does not have a specified or\n\t\t//\t\tdefault value;\n\t\t//\n\t\t//\t\twhen used as a setter, the DOM node\n\t\t//\n\t\t// example:\n\t\t//\t|\t// get the current value of the \"foo\" attribute on a node\n\t\t//\t|\tdojo.attr(dojo.byId(\"nodeId\"), \"foo\");\n\t\t//\t|\t// or we can just pass the id:\n\t\t//\t|\tdojo.attr(\"nodeId\", \"foo\");\n\t\t//\n\t\t// example:\n\t\t//\t|\t// use attr() to set the tab index\n\t\t//\t|\tdojo.attr(\"nodeId\", \"tabIndex\", 3);\n\t\t//\t|\n\t\t//\n\t\t// example:\n\t\t//\tSet multiple values at once, including event handlers:\n\t\t//\t|\tdojo.attr(\"formId\", {\n\t\t//\t|\t\t\"foo\": \"bar\",\n\t\t//\t|\t\t\"tabIndex\": -1,\n\t\t//\t|\t\t\"method\": \"POST\",\n\t\t//\t|\t\t\"onsubmit\": function(e){\n\t\t//\t|\t\t\t// stop submitting the form. Note that the IE behavior\n\t\t//\t|\t\t\t// of returning true or false will have no effect here\n\t\t//\t|\t\t\t// since our handler is connect()ed to the built-in\n\t\t//\t|\t\t\t// onsubmit behavior and so we need to use\n\t\t//\t|\t\t\t// dojo.stopEvent() to ensure that the submission\n\t\t//\t|\t\t\t// doesn't proceed.\n\t\t//\t|\t\t\tdojo.stopEvent(e);\n\t\t//\t|\n\t\t//\t|\t\t\t// submit the form with Ajax\n\t\t//\t|\t\t\tdojo.xhrPost({ form: \"formId\" });\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\tStyle is s special case: Only set with an object hash of styles\n\t\t//\t|\tdojo.attr(\"someNode\",{\n\t\t//\t|\t\tid:\"bar\",\n\t\t//\t|\t\tstyle:{\n\t\t//\t|\t\t\twidth:\"200px\", height:\"100px\", color:\"#000\"\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\tAgain, only set style as an object hash of styles:\n\t\t//\t|\tvar obj = { color:\"#fff\", backgroundColor:\"#000\" };\n\t\t//\t|\tdojo.attr(\"someNode\", \"style\", obj);\n\t\t//\t|\n\t\t//\t|\t// though shorter to use `dojo.style()` in this case:\n\t\t//\t|\tdojo.style(\"someNode\", obj);\n\n\t\tif(arguments.length == 2){\n\t\t\treturn attr[typeof name == \"string\" ? \"get\" : \"set\"](node, name);\n\t\t}\n\t\treturn attr.set(node, name, value);\n\t};\n\n\t// mix-in dom-class\n\tdojo.hasClass = cls.contains;\n\tdojo.addClass = cls.add;\n\tdojo.removeClass = cls.remove;\n\tdojo.toggleClass = cls.toggle;\n\tdojo.replaceClass = cls.replace;\n\n\t// mix-in dom-construct\n\tdojo._toDom = dojo.toDom = ctr.toDom;\n\tdojo.place = ctr.place;\n\tdojo.create = ctr.create;\n\tdojo.empty = function(node){ ctr.empty(node); };\n\tdojo._destroyElement = dojo.destroy = function(node){ ctr.destroy(node); };\n\n\t// mix-in dom-geometry\n\tdojo._getPadExtents = dojo.getPadExtents = geom.getPadExtents;\n\tdojo._getBorderExtents = dojo.getBorderExtents = geom.getBorderExtents;\n\tdojo._getPadBorderExtents = dojo.getPadBorderExtents = geom.getPadBorderExtents;\n\tdojo._getMarginExtents = dojo.getMarginExtents = geom.getMarginExtents;\n\tdojo._getMarginSize = dojo.getMarginSize = geom.getMarginSize;\n\tdojo._getMarginBox = dojo.getMarginBox = geom.getMarginBox;\n\tdojo.setMarginBox = geom.setMarginBox;\n\tdojo._getContentBox = dojo.getContentBox = geom.getContentBox;\n\tdojo.setContentSize = geom.setContentSize;\n\tdojo._isBodyLtr = dojo.isBodyLtr = geom.isBodyLtr;\n\tdojo._docScroll = dojo.docScroll = geom.docScroll;\n\tdojo._getIeDocumentElementOffset = dojo.getIeDocumentElementOffset = geom.getIeDocumentElementOffset;\n\tdojo._fixIeBiDiScrollLeft = dojo.fixIeBiDiScrollLeft = geom.fixIeBiDiScrollLeft;\n\tdojo.position = geom.position;\n\n\tdojo.marginBox = function marginBox(/*DomNode|String*/node, /*Object?*/box){\n\t\t// summary:\n\t\t//\t\tGetter/setter for the margin-box of node.\n\t\t// description:\n\t\t//\t\tGetter/setter for the margin-box of node.\n\t\t//\t\tReturns an object in the expected format of box (regardless\n\t\t//\t\tif box is passed). The object might look like:\n\t\t//\t\t\t`{ l: 50, t: 200, w: 300: h: 150 }`\n\t\t//\t\tfor a node offset from its parent 50px to the left, 200px from\n\t\t//\t\tthe top with a margin width of 300px and a margin-height of\n\t\t//\t\t150px.\n\t\t// node:\n\t\t//\t\tid or reference to DOM Node to get/set box for\n\t\t// box:\n\t\t//\t\tIf passed, denotes that dojo.marginBox() should\n\t\t//\t\tupdate/set the margin box for node. Box is an object in the\n\t\t//\t\tabove format. All properties are optional if passed.\n\t\t// example:\n\t\t//\t\tRetrieve the margin box of a passed node\n\t\t//\t|\tvar box = dojo.marginBox(\"someNodeId\");\n\t\t//\t|\tconsole.dir(box);\n\t\t//\n\t\t// example:\n\t\t//\t\tSet a node's margin box to the size of another node\n\t\t//\t|\tvar box = dojo.marginBox(\"someNodeId\");\n\t\t//\t|\tdojo.marginBox(\"someOtherNode\", box);\n\t\treturn box ? geom.setMarginBox(node, box) : geom.getMarginBox(node); // Object\n\t};\n\n\tdojo.contentBox = function contentBox(/*DomNode|String*/node, /*Object?*/box){\n\t\t// summary:\n\t\t//\t\tGetter/setter for the content-box of node.\n\t\t// description:\n\t\t//\t\tReturns an object in the expected format of box (regardless if box is passed).\n\t\t//\t\tThe object might look like:\n\t\t//\t\t\t`{ l: 50, t: 200, w: 300: h: 150 }`\n\t\t//\t\tfor a node offset from its parent 50px to the left, 200px from\n\t\t//\t\tthe top with a content width of 300px and a content-height of\n\t\t//\t\t150px. Note that the content box may have a much larger border\n\t\t//\t\tor margin box, depending on the box model currently in use and\n\t\t//\t\tCSS values set/inherited for node.\n\t\t//\t\tWhile the getter will return top and left values, the\n\t\t//\t\tsetter only accepts setting the width and height.\n\t\t// node:\n\t\t//\t\tid or reference to DOM Node to get/set box for\n\t\t// box:\n\t\t//\t\tIf passed, denotes that dojo.contentBox() should\n\t\t//\t\tupdate/set the content box for node. Box is an object in the\n\t\t//\t\tabove format, but only w (width) and h (height) are supported.\n\t\t//\t\tAll properties are optional if passed.\n\t\treturn box ? geom.setContentSize(node, box) : geom.getContentBox(node); // Object\n\t};\n\n\tdojo.coords = function(/*DomNode|String*/node, /*Boolean?*/includeScroll){\n\t\t// summary:\n\t\t//\t\tDeprecated: Use position() for border-box x/y/w/h\n\t\t//\t\tor marginBox() for margin-box w/h/l/t.\n\t\t//\t\tReturns an object representing a node's size and position.\n\t\t//\n\t\t// description:\n\t\t//\t\tReturns an object that measures margin-box (w)idth/(h)eight\n\t\t//\t\tand absolute position x/y of the border-box. Also returned\n\t\t//\t\tis computed (l)eft and (t)op values in pixels from the\n\t\t//\t\tnode's offsetParent as returned from marginBox().\n\t\t//\t\tReturn value will be in the form:\n\t\t//|\t\t\t{ l: 50, t: 200, w: 300: h: 150, x: 100, y: 300 }\n\t\t//\t\tDoes not act as a setter. If includeScroll is passed, the x and\n\t\t//\t\ty params are affected as one would expect in dojo.position().\n\t\tdojo.deprecated(\"dojo.coords()\", \"Use dojo.position() or dojo.marginBox().\");\n\t\tnode = dom.byId(node);\n\t\tvar s = style.getComputedStyle(node), mb = geom.getMarginBox(node, s);\n\t\tvar abs = geom.position(node, includeScroll);\n\t\tmb.x = abs.x;\n\t\tmb.y = abs.y;\n\t\treturn mb;\t// Object\n\t};\n\n\t// mix-in dom-prop\n\tdojo.getProp = prop.get;\n\tdojo.setProp = prop.set;\n\n\tdojo.prop = function(/*DomNode|String*/node, /*String|Object*/name, /*String?*/value){\n\t\t// summary:\n\t\t//\t\tGets or sets a property on an HTML element.\n\t\t// description:\n\t\t//\t\tHandles normalized getting and setting of properties on DOM\n\t\t//\t\tNodes. If 2 arguments are passed, and a the second argument is a\n\t\t//\t\tstring, acts as a getter.\n\t\t//\n\t\t//\t\tIf a third argument is passed, or if the second argument is a\n\t\t//\t\tmap of attributes, acts as a setter.\n\t\t//\n\t\t//\t\tWhen passing functions as values, note that they will not be\n\t\t//\t\tdirectly assigned to slots on the node, but rather the default\n\t\t//\t\tbehavior will be removed and the new behavior will be added\n\t\t//\t\tusing `dojo.connect()`, meaning that event handler properties\n\t\t//\t\twill be normalized and that some caveats with regards to\n\t\t//\t\tnon-standard behaviors for onsubmit apply. Namely that you\n\t\t//\t\tshould cancel form submission using `dojo.stopEvent()` on the\n\t\t//\t\tpassed event object instead of returning a boolean value from\n\t\t//\t\tthe handler itself.\n\t\t// node:\n\t\t//\t\tid or reference to the element to get or set the property on\n\t\t// name:\n\t\t//\t\tthe name of the property to get or set.\n\t\t// value:\n\t\t//\t\tThe value to set for the property\n\t\t// returns:\n\t\t//\t\twhen used as a getter, the value of the requested property\n\t\t//\t\tor null if that attribute does not have a specified or\n\t\t//\t\tdefault value;\n\t\t//\n\t\t//\t\twhen used as a setter, the DOM node\n\t\t//\n\t\t// example:\n\t\t//\t|\t// get the current value of the \"foo\" property on a node\n\t\t//\t|\tdojo.prop(dojo.byId(\"nodeId\"), \"foo\");\n\t\t//\t|\t// or we can just pass the id:\n\t\t//\t|\tdojo.prop(\"nodeId\", \"foo\");\n\t\t//\n\t\t// example:\n\t\t//\t|\t// use prop() to set the tab index\n\t\t//\t|\tdojo.prop(\"nodeId\", \"tabIndex\", 3);\n\t\t//\t|\n\t\t//\n\t\t// example:\n\t\t//\tSet multiple values at once, including event handlers:\n\t\t//\t|\tdojo.prop(\"formId\", {\n\t\t//\t|\t\t\"foo\": \"bar\",\n\t\t//\t|\t\t\"tabIndex\": -1,\n\t\t//\t|\t\t\"method\": \"POST\",\n\t\t//\t|\t\t\"onsubmit\": function(e){\n\t\t//\t|\t\t\t// stop submitting the form. Note that the IE behavior\n\t\t//\t|\t\t\t// of returning true or false will have no effect here\n\t\t//\t|\t\t\t// since our handler is connect()ed to the built-in\n\t\t//\t|\t\t\t// onsubmit behavior and so we need to use\n\t\t//\t|\t\t\t// dojo.stopEvent() to ensure that the submission\n\t\t//\t|\t\t\t// doesn't proceed.\n\t\t//\t|\t\t\tdojo.stopEvent(e);\n\t\t//\t|\n\t\t//\t|\t\t\t// submit the form with Ajax\n\t\t//\t|\t\t\tdojo.xhrPost({ form: \"formId\" });\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\tStyle is s special case: Only set with an object hash of styles\n\t\t//\t|\tdojo.prop(\"someNode\",{\n\t\t//\t|\t\tid:\"bar\",\n\t\t//\t|\t\tstyle:{\n\t\t//\t|\t\t\twidth:\"200px\", height:\"100px\", color:\"#000\"\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\tAgain, only set style as an object hash of styles:\n\t\t//\t|\tvar obj = { color:\"#fff\", backgroundColor:\"#000\" };\n\t\t//\t|\tdojo.prop(\"someNode\", \"style\", obj);\n\t\t//\t|\n\t\t//\t|\t// though shorter to use `dojo.style()` in this case:\n\t\t//\t|\tdojo.style(\"someNode\", obj);\n\n\t\tif(arguments.length == 2){\n\t\t\treturn prop[typeof name == \"string\" ? \"get\" : \"set\"](node, name);\n\t\t}\n\t\t// setter\n\t\treturn prop.set(node, name, value);\n\t};\n\n\t// mix-in dom-style\n\tdojo.getStyle = style.get;\n\tdojo.setStyle = style.set;\n\tdojo.getComputedStyle = style.getComputedStyle;\n\tdojo.__toPixelValue = dojo.toPixelValue = style.toPixelValue;\n\n\tdojo.style = function(node, name, value){\n\t\t// summary:\n\t\t//\t\tAccesses styles on a node. If 2 arguments are\n\t\t//\t\tpassed, acts as a getter. If 3 arguments are passed, acts\n\t\t//\t\tas a setter.\n\t\t// description:\n\t\t//\t\tGetting the style value uses the computed style for the node, so the value\n\t\t//\t\twill be a calculated value, not just the immediate node.style value.\n\t\t//\t\tAlso when getting values, use specific style names,\n\t\t//\t\tlike \"borderBottomWidth\" instead of \"border\" since compound values like\n\t\t//\t\t\"border\" are not necessarily reflected as expected.\n\t\t//\t\tIf you want to get node dimensions, use `dojo.marginBox()`,\n\t\t//\t\t`dojo.contentBox()` or `dojo.position()`.\n\t\t// node: DOMNode|String\n\t\t//\t\tid or reference to node to get/set style for\n\t\t// name: String?|Object?\n\t\t//\t\tthe style property to set in DOM-accessor format\n\t\t//\t\t(\"borderWidth\", not \"border-width\") or an object with key/value\n\t\t//\t\tpairs suitable for setting each property.\n\t\t// value: String?\n\t\t//\t\tIf passed, sets value on the node for style, handling\n\t\t//\t\tcross-browser concerns.  When setting a pixel value,\n\t\t//\t\tbe sure to include \"px\" in the value. For instance, top: \"200px\".\n\t\t//\t\tOtherwise, in some cases, some browsers will not apply the style.\n\t\t// returns:\n\t\t//\t\twhen used as a getter, return the computed style of the node if passing in an ID or node,\n\t\t//\t\tor return the normalized, computed value for the property when passing in a node and a style property\n\t\t// example:\n\t\t//\t\tPassing only an ID or node returns the computed style object of\n\t\t//\t\tthe node:\n\t\t//\t|\tdojo.style(\"thinger\");\n\t\t// example:\n\t\t//\t\tPassing a node and a style property returns the current\n\t\t//\t\tnormalized, computed value for that property:\n\t\t//\t|\tdojo.style(\"thinger\", \"opacity\"); // 1 by default\n\t\t//\n\t\t// example:\n\t\t//\t\tPassing a node, a style property, and a value changes the\n\t\t//\t\tcurrent display of the node and returns the new computed value\n\t\t//\t|\tdojo.style(\"thinger\", \"opacity\", 0.5); // == 0.5\n\t\t//\n\t\t// example:\n\t\t//\t\tPassing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:\n\t\t//\t|\tdojo.style(\"thinger\", {\n\t\t//\t|\t\t\"opacity\": 0.5,\n\t\t//\t|\t\t\"border\": \"3px solid black\",\n\t\t//\t|\t\t\"height\": \"300px\"\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\t\tWhen the CSS style property is hyphenated, the JavaScript property is camelCased.\n\t\t//\t\tfont-size becomes fontSize, and so on.\n\t\t//\t|\tdojo.style(\"thinger\",{\n\t\t//\t|\t\tfontSize:\"14pt\",\n\t\t//\t|\t\tletterSpacing:\"1.2em\"\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\t\tdojo.NodeList implements .style() using the same syntax, omitting the \"node\" parameter, calling\n\t\t//\t\tdojo.style() on every element of the list. See: `dojo.query()` and `dojo.NodeList()`\n\t\t//\t|\tdojo.query(\".someClassName\").style(\"visibility\",\"hidden\");\n\t\t//\t|\t// or\n\t\t//\t|\tdojo.query(\"#baz > div\").style({\n\t\t//\t|\t\topacity:0.75,\n\t\t//\t|\t\tfontSize:\"13pt\"\n\t\t//\t|\t});\n\n\t\tswitch(arguments.length){\n\t\t\tcase 1:\n\t\t\t\treturn style.get(node);\n\t\t\tcase 2:\n\t\t\t\treturn style[typeof name == \"string\" ? \"get\" : \"set\"](node, name);\n\t\t}\n\t\t// setter\n\t\treturn style.set(node, name, value);\n\t};\n\n\treturn dojo;\n});\n\n},\n'dojo/_base/kernel':function(){\ndefine([\"../has\", \"./config\", \"require\", \"module\"], function(has, config, require, module){\n\t// module:\n\t//\t\tdojo/_base/kernel\n\t// summary:\n\t//\t\tThis module is the foundational module of the dojo boot sequence; it defines the dojo object.\n\tvar\n\t\t// loop variables for this module\n\t\ti, p,\n\n\t\t// create dojo, dijit, and dojox\n\t\t// FIXME: in 2.0 remove dijit, dojox being created by dojo\n\t\tdijit = {},\n\t\tdojox = {},\n\t\tdojo = {\n\t\t\t// notice dojo takes ownership of the value of the config module\n\t\t\tconfig:config,\n\t\t\tglobal:this,\n\t\t\tdijit:dijit,\n\t\t\tdojox:dojox\n\t\t};\n\n\n\t// Configure the scope map. For a 100% AMD application, the scope map is not needed other than to provide\n\t// a _scopeName property for the dojo, dijit, and dojox root object so those packages can create\n\t// unique names in the global space.\n\t//\n\t// Built, legacy modules use the scope map to allow those modules to be expressed as if dojo, dijit, and dojox,\n\t// where global when in fact they are either global under different names or not global at all. In v1.6-, the\n\t// config variable \"scopeMap\" was used to map names as used within a module to global names. This has been\n\t// subsumed by the dojo packageMap configuration variable which relocates packages to different names. See\n\t// http://livedocs.dojotoolkit.org/developer/design/loader#legacy-cross-domain-mode for details.\n\t//\n\t// The following computations contort the packageMap for this dojo instance into a scopeMap.\n\tvar scopeMap =\n\t\t\t// a map from a name used in a legacy module to the (global variable name, object addressed by that name)\n\t\t\t// always map dojo, dijit, and dojox\n\t\t\t{\n\t\t\t\tdojo:[\"dojo\", dojo],\n\t\t\t\tdijit:[\"dijit\", dijit],\n\t\t\t\tdojox:[\"dojox\", dojox]\n\t\t\t},\n\n\t\tpackageMap =\n\t\t\t// the package map for this dojo instance; note, a foreign loader or no pacakgeMap results in the above default config\n\t\t\t(require.packs && require.packs[module.id.match(/[^\\/]+/)[0]].packageMap) || {},\n\n\t\titem;\n\n\t// process all mapped top-level names for this instance of dojo\n\tfor(p in packageMap){\n\t\tif(scopeMap[p]){\n\t\t\t// mapped dojo, dijit, or dojox\n\t\t\tscopeMap[p][0] = packageMap[p];\n\t\t}else{\n\t\t\t// some other top-level name\n\t\t\tscopeMap[p] = [packageMap[p], {}];\n\t\t}\n\t}\n\n\t// publish those names to _scopeName and, optionally, the global namespace\n\tfor(p in scopeMap){\n\t\titem = scopeMap[p];\n\t\titem[1]._scopeName = item[0];\n\t\tif(!config.noGlobals){\n\t\t\tthis[item[0]] = item[1];\n\t\t}\n\t}\n\tdojo.scopeMap = scopeMap;\n\n\t// FIXME: dojo.baseUrl and dojo.config.baseUrl should be deprecated\n\tdojo.baseUrl = dojo.config.baseUrl = require.baseUrl;\n\tdojo.isAsync = !1 || require.async;\n\tdojo.locale = config.locale;\n\n\t/*=====\n\t\tdojo.version = function(){\n\t\t\t// summary:\n\t\t\t//\t\tVersion number of the Dojo Toolkit\n\t\t\t// major: Integer\n\t\t\t//\t\tMajor version. If total version is \"1.2.0beta1\", will be 1\n\t\t\t// minor: Integer\n\t\t\t//\t\tMinor version. If total version is \"1.2.0beta1\", will be 2\n\t\t\t// patch: Integer\n\t\t\t//\t\tPatch version. If total version is \"1.2.0beta1\", will be 0\n\t\t\t// flag: String\n\t\t\t//\t\tDescriptor flag. If total version is \"1.2.0beta1\", will be \"beta1\"\n\t\t\t// revision: Number\n\t\t\t//\t\tThe SVN rev from which dojo was pulled\n\t\t\tthis.major = 0;\n\t\t\tthis.minor = 0;\n\t\t\tthis.patch = 0;\n\t\t\tthis.flag = \"\";\n\t\t\tthis.revision = 0;\n\t\t}\n\t=====*/\n\tvar rev = \"$Rev: 27407 $\".match(/\\d+/);\n\tdojo.version = {\n\t\tmajor: 1, minor: 7, patch: 1, flag: \"\",\n\t\trevision: rev ? +rev[0] : NaN,\n\t\ttoString: function(){\n\t\t\tvar v = dojo.version;\n\t\t\treturn v.major + \".\" + v.minor + \".\" + v.patch + v.flag + \" (\" + v.revision + \")\";\t// String\n\t\t}\n\t};\n\n\n\t// If 1 is truthy, then as a dojo module is defined it should push it's definitions\n\t// into the dojo object, and conversely. In 2.0, it will likely be unusual to augment another object\n\t// as a result of defining a module. This has feature gives a way to force 2.0 behavior as the code\n\t// is migrated. Absent specific advice otherwise, set extend-dojo to truthy.\n\ttrue || has.add(\"extend-dojo\", 1);\n\n\tif(1){\n\t\tdojo.eval = require.eval;\n\t}else{\n\t\tvar eval_ =\n\t\t\t// use the function constructor so our eval is scoped close to (but not in) in the global space with minimal pollution\n\t\t\tnew Function(\"__text\", \"return eval(__text);\");\n\n\t\tdojo.eval = function(text, hint){\n\t\t\t// note: the four forward-slashes make the firebug hint work in ie9\n\t\t\treturn eval_(text + \"\\r\\n////@ sourceURL=\" + hint);\n\t\t};\n\t}\n\n\tif(0){\n\t\tdojo.exit = function(exitcode){\n\t\t\tquit(exitcode);\n\t\t};\n\t} else{\n\t\tdojo.exit = function(){\n\t\t};\n\t}\n\n\ttrue || has.add(\"dojo-guarantee-console\",\n\t\t// ensure that console.log, console.warn, etc. are defined\n\t\t1\n\t);\n\tif(1){\n\t\ttypeof console != \"undefined\" || (console = {});\n\t\t//\tBe careful to leave 'log' always at the end\n\t\tvar cn = [\n\t\t\t\"assert\", \"count\", \"debug\", \"dir\", \"dirxml\", \"error\", \"group\",\n\t\t\t\"groupEnd\", \"info\", \"profile\", \"profileEnd\", \"time\", \"timeEnd\",\n\t\t\t\"trace\", \"warn\", \"log\"\n\t\t];\n\t\tvar tn;\n\t\ti = 0;\n\t\twhile((tn = cn[i++])){\n\t\t\tif(!console[tn]){\n\t\t\t\t(function(){\n\t\t\t\t\tvar tcn = tn + \"\";\n\t\t\t\t\tconsole[tcn] = ('log' in console) ? function(){\n\t\t\t\t\t\tvar a = Array.apply({}, arguments);\n\t\t\t\t\t\ta.unshift(tcn + \":\");\n\t\t\t\t\t\tconsole[\"log\"](a.join(\" \"));\n\t\t\t\t\t} : function(){};\n\t\t\t\t\tconsole[tcn]._fake = true;\n\t\t\t\t})();\n\t\t\t}\n\t\t}\n\t}\n\n\thas.add(\"dojo-debug-messages\",\n\t\t// include dojo.deprecated/dojo.experimental implementations\n\t\t!!config.isDebug\n\t);\n\tif(has(\"dojo-debug-messages\")){\n\t\tdojo.deprecated = function(/*String*/ behaviour, /*String?*/ extra, /*String?*/ removal){\n\t\t\t//\tsummary:\n\t\t\t//\t\tLog a debug message to indicate that a behavior has been\n\t\t\t//\t\tdeprecated.\n\t\t\t//\tbehaviour: String\n\t\t\t//\t\tThe API or behavior being deprecated. Usually in the form\n\t\t\t//\t\tof \"myApp.someFunction()\".\n\t\t\t//\textra: String?\n\t\t\t//\t\tText to append to the message. Often provides advice on a\n\t\t\t//\t\tnew function or facility to achieve the same goal during\n\t\t\t//\t\tthe deprecation period.\n\t\t\t//\tremoval: String?\n\t\t\t//\t\tText to indicate when in the future the behavior will be\n\t\t\t//\t\tremoved. Usually a version number.\n\t\t\t//\texample:\n\t\t\t//\t| dojo.deprecated(\"myApp.getTemp()\", \"use myApp.getLocaleTemp() instead\", \"1.0\");\n\n\t\t\tvar message = \"DEPRECATED: \" + behaviour;\n\t\t\tif(extra){ message += \" \" + extra; }\n\t\t\tif(removal){ message += \" -- will be removed in version: \" + removal; }\n\t\t\tconsole.warn(message);\n\t\t};\n\n\t\tdojo.experimental = function(/* String */ moduleName, /* String? */ extra){\n\t\t\t//\tsummary: Marks code as experimental.\n\t\t\t//\tdescription:\n\t\t\t//\t\tThis can be used to mark a function, file, or module as\n\t\t\t//\t\texperimental.\t Experimental code is not ready to be used, and the\n\t\t\t//\t\tAPIs are subject to change without notice.\tExperimental code may be\n\t\t\t//\t\tcompleted deleted without going through the normal deprecation\n\t\t\t//\t\tprocess.\n\t\t\t//\tmoduleName: String\n\t\t\t//\t\tThe name of a module, or the name of a module file or a specific\n\t\t\t//\t\tfunction\n\t\t\t//\textra: String?\n\t\t\t//\t\tsome additional message for the user\n\t\t\t//\texample:\n\t\t\t//\t| dojo.experimental(\"dojo.data.Result\");\n\t\t\t//\texample:\n\t\t\t//\t| dojo.experimental(\"dojo.weather.toKelvin()\", \"PENDING approval from NOAA\");\n\n\t\t\tvar message = \"EXPERIMENTAL: \" + moduleName + \" -- APIs subject to change without notice.\";\n\t\t\tif(extra){ message += \" \" + extra; }\n\t\t\tconsole.warn(message);\n\t\t};\n\t}else{\n\t\tdojo.deprecated = dojo.experimental =  function(){};\n\t}\n\n\ttrue || has.add(\"dojo-modulePaths\",\n\t\t// consume dojo.modulePaths processing\n\t\t1\n\t);\n\tif(1){\n\t\t// notice that modulePaths won't be applied to any require's before the dojo/_base/kernel factory is run;\n\t\t// this is the v1.6- behavior.\n\t\tif(config.modulePaths){\n\t\t\tdojo.deprecated(\"dojo.modulePaths\", \"use paths configuration\");\n\t\t\tvar paths = {};\n\t\t\tfor(p in config.modulePaths){\n\t\t\t\tpaths[p.replace(/\\./g, \"/\")] = config.modulePaths[p];\n\t\t\t}\n\t\t\trequire({paths:paths});\n\t\t}\n\t}\n\n\ttrue || has.add(\"dojo-moduleUrl\",\n\t\t// include dojo.moduleUrl\n\t\t1\n\t);\n\tif(1){\n\t\tdojo.moduleUrl = function(/*String*/module, /*String?*/url){\n\t\t\t//\tsummary:\n\t\t\t//\t\tReturns a URL relative to a module.\n\t\t\t//\texample:\n\t\t\t//\t|\tvar pngPath = dojo.moduleUrl(\"acme\",\"images/small.png\");\n\t\t\t//\t|\tconsole.dir(pngPath); // list the object properties\n\t\t\t//\t|\t// create an image and set it's source to pngPath's value:\n\t\t\t//\t|\tvar img = document.createElement(\"img\");\n\t\t\t//\t|\timg.src = pngPath;\n\t\t\t//\t|\t// add our image to the document\n\t\t\t//\t|\tdojo.body().appendChild(img);\n\t\t\t//\texample:\n\t\t\t//\t\tyou may de-reference as far as you like down the package\n\t\t\t//\t\thierarchy.  This is sometimes handy to avoid lenghty relative\n\t\t\t//\t\turls or for building portable sub-packages. In this example,\n\t\t\t//\t\tthe `acme.widget` and `acme.util` directories may be located\n\t\t\t//\t\tunder different roots (see `dojo.registerModulePath`) but the\n\t\t\t//\t\tthe modules which reference them can be unaware of their\n\t\t\t//\t\trelative locations on the filesystem:\n\t\t\t//\t|\t// somewhere in a configuration block\n\t\t\t//\t|\tdojo.registerModulePath(\"acme.widget\", \"../../acme/widget\");\n\t\t\t//\t|\tdojo.registerModulePath(\"acme.util\", \"../../util\");\n\t\t\t//\t|\n\t\t\t//\t|\t// ...\n\t\t\t//\t|\n\t\t\t//\t|\t// code in a module using acme resources\n\t\t\t//\t|\tvar tmpltPath = dojo.moduleUrl(\"acme.widget\",\"templates/template.html\");\n\t\t\t//\t|\tvar dataPath = dojo.moduleUrl(\"acme.util\",\"resources/data.json\");\n\n\t\t\tdojo.deprecated(\"dojo.moduleUrl()\", \"use require.toUrl\", \"2.0\");\n\n\t\t\t// require.toUrl requires a filetype; therefore, just append the suffix \"/*.*\" to guarantee a filetype, then\n\t\t\t// remove the suffix from the result. This way clients can request a url w/out a filetype. This should be\n\t\t\t// rare, but it maintains backcompat for the v1.x line (note: dojo.moduleUrl will be removed in v2.0).\n\t\t\t// Notice * is an illegal filename so it won't conflict with any real path map that may exist the paths config.\n\t\t\tvar result = null;\n\t\t\tif(module){\n\t\t\t\tresult = require.toUrl(module.replace(/\\./g, \"/\") + (url ? (\"/\" + url) : \"\") + \"/*.*\").replace(/\\/\\*\\.\\*/, \"\") + (url ? \"\" : \"/\");\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t}\n\n\tdojo._hasResource = {}; // for backward compatibility with layers built with 1.6 tooling\n\n\treturn dojo;\n});\n\n},\n'dojo/io-query':function(){\ndefine([\"./_base/lang\"], function(lang){\n\t// module:\n\t//\t\tdojo/io-query\n\t// summary:\n\t//\t\tThis module defines query string processing functions.\n\n    var backstop = {};\n\n    function objectToQuery(/*Object*/ map){\n        // summary:\n        //\t\ttakes a name/value mapping object and returns a string representing\n        //\t\ta URL-encoded version of that object.\n        // example:\n        //\t\tthis object:\n        //\n        //\t|\t{\n        //\t|\t\tblah: \"blah\",\n        //\t|\t\tmulti: [\n        //\t|\t\t\t\"thud\",\n        //\t|\t\t\t\"thonk\"\n        //\t|\t\t]\n        //\t|\t};\n        //\n        // yields the following query string:\n        //\n        //\t|\t\"blah=blah&multi=thud&multi=thonk\"\n\n        // FIXME: need to implement encodeAscii!!\n        var enc = encodeURIComponent, pairs = [];\n        for(var name in map){\n            var value = map[name];\n            if(value != backstop[name]){\n                var assign = enc(name) + \"=\";\n                if(lang.isArray(value)){\n                    for(var i = 0, l = value.length; i < l; ++i){\n                        pairs.push(assign + enc(value[i]));\n                    }\n                }else{\n                    pairs.push(assign + enc(value));\n                }\n            }\n        }\n        return pairs.join(\"&\"); // String\n    }\n\n    function queryToObject(/*String*/ str){\n        // summary:\n        //\t\tCreate an object representing a de-serialized query section of a\n        //\t\tURL. Query keys with multiple values are returned in an array.\n        //\n        // example:\n        //\t\tThis string:\n        //\n        //\t|\t\t\"foo=bar&foo=baz&thinger=%20spaces%20=blah&zonk=blarg&\"\n        //\n        //\t\tresults in this object structure:\n        //\n        //\t|\t\t{\n        //\t|\t\t\tfoo: [ \"bar\", \"baz\" ],\n        //\t|\t\t\tthinger: \" spaces =blah\",\n        //\t|\t\t\tzonk: \"blarg\"\n        //\t|\t\t}\n        //\n        //\t\tNote that spaces and other urlencoded entities are correctly\n        //\t\thandled.\n\n        // FIXME: should we grab the URL string if we're not passed one?\n        var dec = decodeURIComponent, qp = str.split(\"&\"), ret = {}, name, val;\n        for(var i = 0, l = qp.length, item; i < l; ++i){\n            item = qp[i];\n            if(item.length){\n                var s = item.indexOf(\"=\");\n                if(s < 0){\n                    name = dec(item);\n                    val = \"\";\n                }else{\n                    name = dec(item.slice(0, s));\n                    val  = dec(item.slice(s + 1));\n                }\n                if(typeof ret[name] == \"string\"){ // inline'd type check\n                    ret[name] = [ret[name]];\n                }\n\n                if(lang.isArray(ret[name])){\n                    ret[name].push(val);\n                }else{\n                    ret[name] = val;\n                }\n            }\n        }\n        return ret; // Object\n    }\n\n    return {\n        objectToQuery: objectToQuery,\n        queryToObject: queryToObject\n    };\n});\n},\n'dojo/_base/Deferred':function(){\ndefine(\"dojo/_base/Deferred\", [\"./kernel\", \"./lang\"], function(dojo, lang){\n\t// module:\n\t//\t\tdojo/_base/Deferred\n\t// summary:\n\t//\t\tThis module defines dojo.Deferred.\n\n\tvar mutator = function(){};\n\tvar freeze = Object.freeze || function(){};\n\t// A deferred provides an API for creating and resolving a promise.\n\tdojo.Deferred = function(/*Function?*/ canceller){\n\t\t// summary:\n\t\t//\t\tDeferreds provide a generic means for encapsulating an asynchronous\n\t\t//\t\toperation and notifying users of the completion and result of the operation.\n\t\t// description:\n\t\t//\t\tThe dojo.Deferred API is based on the concept of promises that provide a\n\t\t//\t\tgeneric interface into the eventual completion of an asynchronous action.\n\t\t//\t\tThe motivation for promises fundamentally is about creating a\n\t\t//\t\tseparation of concerns that allows one to achieve the same type of\n\t\t//\t\tcall patterns and logical data flow in asynchronous code as can be\n\t\t//\t\tachieved in synchronous code. Promises allows one\n\t\t//\t\tto be able to call a function purely with arguments needed for\n\t\t//\t\texecution, without conflating the call with concerns of whether it is\n\t\t//\t\tsync or async. One shouldn't need to alter a call's arguments if the\n\t\t//\t\timplementation switches from sync to async (or vice versa). By having\n\t\t//\t\tasync functions return promises, the concerns of making the call are\n\t\t//\t\tseparated from the concerns of asynchronous interaction (which are\n\t\t//\t\thandled by the promise).\n\t\t//\n\t\t//\t\tThe dojo.Deferred is a type of promise that provides methods for fulfilling the\n\t\t//\t\tpromise with a successful result or an error. The most important method for\n\t\t//\t\tworking with Dojo's promises is the then() method, which follows the\n\t\t//\t\tCommonJS proposed promise API. An example of using a Dojo promise:\n\t\t//\n\t\t//\t\t|\tvar resultingPromise = someAsyncOperation.then(function(result){\n\t\t//\t\t|\t\t... handle result ...\n\t\t//\t\t|\t},\n\t\t//\t\t|\tfunction(error){\n\t\t//\t\t|\t\t... handle error ...\n\t\t//\t\t|\t});\n\t\t//\n\t\t//\t\tThe .then() call returns a new promise that represents the result of the\n\t\t//\t\texecution of the callback. The callbacks will never affect the original promises value.\n\t\t//\n\t\t//\t\tThe dojo.Deferred instances also provide the following functions for backwards compatibility:\n\t\t//\n\t\t//\t\t\t* addCallback(handler)\n\t\t//\t\t\t* addErrback(handler)\n\t\t//\t\t\t* callback(result)\n\t\t//\t\t\t* errback(result)\n\t\t//\n\t\t//\t\tCallbacks are allowed to return promises themselves, so\n\t\t//\t\tyou can build complicated sequences of events with ease.\n\t\t//\n\t\t//\t\tThe creator of the Deferred may specify a canceller.  The canceller\n\t\t//\t\tis a function that will be called if Deferred.cancel is called\n\t\t//\t\tbefore the Deferred fires. You can use this to implement clean\n\t\t//\t\taborting of an XMLHttpRequest, etc. Note that cancel will fire the\n\t\t//\t\tdeferred with a CancelledError (unless your canceller returns\n\t\t//\t\tanother kind of error), so the errbacks should be prepared to\n\t\t//\t\thandle that error for cancellable Deferreds.\n\t\t// example:\n\t\t//\t|\tvar deferred = new dojo.Deferred();\n\t\t//\t|\tsetTimeout(function(){ deferred.callback({success: true}); }, 1000);\n\t\t//\t|\treturn deferred;\n\t\t// example:\n\t\t//\t\tDeferred objects are often used when making code asynchronous. It\n\t\t//\t\tmay be easiest to write functions in a synchronous manner and then\n\t\t//\t\tsplit code using a deferred to trigger a response to a long-lived\n\t\t//\t\toperation. For example, instead of register a callback function to\n\t\t//\t\tdenote when a rendering operation completes, the function can\n\t\t//\t\tsimply return a deferred:\n\t\t//\n\t\t//\t\t|\t// callback style:\n\t\t//\t\t|\tfunction renderLotsOfData(data, callback){\n\t\t//\t\t|\t\tvar success = false\n\t\t//\t\t|\t\ttry{\n\t\t//\t\t|\t\t\tfor(var x in data){\n\t\t//\t\t|\t\t\t\trenderDataitem(data[x]);\n\t\t//\t\t|\t\t\t}\n\t\t//\t\t|\t\t\tsuccess = true;\n\t\t//\t\t|\t\t}catch(e){ }\n\t\t//\t\t|\t\tif(callback){\n\t\t//\t\t|\t\t\tcallback(success);\n\t\t//\t\t|\t\t}\n\t\t//\t\t|\t}\n\t\t//\n\t\t//\t\t|\t// using callback style\n\t\t//\t\t|\trenderLotsOfData(someDataObj, function(success){\n\t\t//\t\t|\t\t// handles success or failure\n\t\t//\t\t|\t\tif(!success){\n\t\t//\t\t|\t\t\tpromptUserToRecover();\n\t\t//\t\t|\t\t}\n\t\t//\t\t|\t});\n\t\t//\t\t|\t// NOTE: no way to add another callback here!!\n\t\t// example:\n\t\t//\t\tUsing a Deferred doesn't simplify the sending code any, but it\n\t\t//\t\tprovides a standard interface for callers and senders alike,\n\t\t//\t\tproviding both with a simple way to service multiple callbacks for\n\t\t//\t\tan operation and freeing both sides from worrying about details\n\t\t//\t\tsuch as \"did this get called already?\". With Deferreds, new\n\t\t//\t\tcallbacks can be added at any time.\n\t\t//\n\t\t//\t\t|\t// Deferred style:\n\t\t//\t\t|\tfunction renderLotsOfData(data){\n\t\t//\t\t|\t\tvar d = new dojo.Deferred();\n\t\t//\t\t|\t\ttry{\n\t\t//\t\t|\t\t\tfor(var x in data){\n\t\t//\t\t|\t\t\t\trenderDataitem(data[x]);\n\t\t//\t\t|\t\t\t}\n\t\t//\t\t|\t\t\td.callback(true);\n\t\t//\t\t|\t\t}catch(e){\n\t\t//\t\t|\t\t\td.errback(new Error(\"rendering failed\"));\n\t\t//\t\t|\t\t}\n\t\t//\t\t|\t\treturn d;\n\t\t//\t\t|\t}\n\t\t//\n\t\t//\t\t|\t// using Deferred style\n\t\t//\t\t|\trenderLotsOfData(someDataObj).then(null, function(){\n\t\t//\t\t|\t\tpromptUserToRecover();\n\t\t//\t\t|\t});\n\t\t//\t\t|\t// NOTE: addErrback and addCallback both return the Deferred\n\t\t//\t\t|\t// again, so we could chain adding callbacks or save the\n\t\t//\t\t|\t// deferred for later should we need to be notified again.\n\t\t// example:\n\t\t//\t\tIn this example, renderLotsOfData is synchronous and so both\n\t\t//\t\tversions are pretty artificial. Putting the data display on a\n\t\t//\t\ttimeout helps show why Deferreds rock:\n\t\t//\n\t\t//\t\t|\t// Deferred style and async func\n\t\t//\t\t|\tfunction renderLotsOfData(data){\n\t\t//\t\t|\t\tvar d = new dojo.Deferred();\n\t\t//\t\t|\t\tsetTimeout(function(){\n\t\t//\t\t|\t\t\ttry{\n\t\t//\t\t|\t\t\t\tfor(var x in data){\n\t\t//\t\t|\t\t\t\t\trenderDataitem(data[x]);\n\t\t//\t\t|\t\t\t\t}\n\t\t//\t\t|\t\t\t\td.callback(true);\n\t\t//\t\t|\t\t\t}catch(e){\n\t\t//\t\t|\t\t\t\td.errback(new Error(\"rendering failed\"));\n\t\t//\t\t|\t\t\t}\n\t\t//\t\t|\t\t}, 100);\n\t\t//\t\t|\t\treturn d;\n\t\t//\t\t|\t}\n\t\t//\n\t\t//\t\t|\t// using Deferred style\n\t\t//\t\t|\trenderLotsOfData(someDataObj).then(null, function(){\n\t\t//\t\t|\t\tpromptUserToRecover();\n\t\t//\t\t|\t});\n\t\t//\n\t\t//\t\tNote that the caller doesn't have to change his code at all to\n\t\t//\t\thandle the asynchronous case.\n\n\t\tvar result, finished, isError, head, nextListener;\n\t\tvar promise = (this.promise = {});\n\n\t\tfunction complete(value){\n\t\t\tif(finished){\n\t\t\t\tthrow new Error(\"This deferred has already been resolved\");\n\t\t\t}\n\t\t\tresult = value;\n\t\t\tfinished = true;\n\t\t\tnotify();\n\t\t}\n\t\tfunction notify(){\n\t\t\tvar mutated;\n\t\t\twhile(!mutated && nextListener){\n\t\t\t\tvar listener = nextListener;\n\t\t\t\tnextListener = nextListener.next;\n\t\t\t\tif((mutated = (listener.progress == mutator))){ // assignment and check\n\t\t\t\t\tfinished = false;\n\t\t\t\t}\n\t\t\t\tvar func = (isError ? listener.error : listener.resolved);\n\t\t\t\tif(func){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tvar newResult = func(result);\n\t\t\t\t\t\tif (newResult && typeof newResult.then === \"function\"){\n\t\t\t\t\t\t\tnewResult.then(lang.hitch(listener.deferred, \"resolve\"), lang.hitch(listener.deferred, \"reject\"), lang.hitch(listener.deferred, \"progress\"));\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar unchanged = mutated && newResult === undefined;\n\t\t\t\t\t\tif(mutated && !unchanged){\n\t\t\t\t\t\t\tisError = newResult instanceof Error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlistener.deferred[unchanged && isError ? \"reject\" : \"resolve\"](unchanged ? result : newResult);\n\t\t\t\t\t}catch(e){\n\t\t\t\t\t\tlistener.deferred.reject(e);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(isError){\n\t\t\t\t\t\tlistener.deferred.reject(result);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlistener.deferred.resolve(result);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// calling resolve will resolve the promise\n\t\tthis.resolve = this.callback = function(value){\n\t\t\t// summary:\n\t\t\t//\t\tFulfills the Deferred instance successfully with the provide value\n\t\t\tthis.fired = 0;\n\t\t\tthis.results = [value, null];\n\t\t\tcomplete(value);\n\t\t};\n\n\n\t\t// calling error will indicate that the promise failed\n\t\tthis.reject = this.errback = function(error){\n\t\t\t// summary:\n\t\t\t//\t\tFulfills the Deferred instance as an error with the provided error\n\t\t\tisError = true;\n\t\t\tthis.fired = 1;\n\t\t\tcomplete(error);\n\t\t\tthis.results = [null, error];\n\t\t\tif(!error || error.log !== false){\n\t\t\t\t(dojo.config.deferredOnError || function(x){ console.error(x); })(error);\n\t\t\t}\n\t\t};\n\t\t// call progress to provide updates on the progress on the completion of the promise\n\t\tthis.progress = function(update){\n\t\t\t// summary:\n\t\t\t//\t\tSend progress events to all listeners\n\t\t\tvar listener = nextListener;\n\t\t\twhile(listener){\n\t\t\t\tvar progress = listener.progress;\n\t\t\t\tprogress && progress(update);\n\t\t\t\tlistener = listener.next;\n\t\t\t}\n\t\t};\n\t\tthis.addCallbacks = function(callback, errback){\n\t\t\t// summary:\n\t\t\t//\t\tAdds callback and error callback for this deferred instance.\n\t\t\t// callback: Function?\n\t\t\t// \t\tThe callback attached to this deferred object.\n\t\t\t// errback: Function?\n\t\t\t// \t\tThe error callback attached to this deferred object.\n\t\t\t// returns:\n\t\t\t// \t\tReturns this deferred object.\n\t\t\tthis.then(callback, errback, mutator);\n\t\t\treturn this;\t// dojo.Deferred\n\t\t};\n\t\t// provide the implementation of the promise\n\t\tpromise.then = this.then = function(/*Function?*/resolvedCallback, /*Function?*/errorCallback, /*Function?*/progressCallback){\n\t\t\t// summary:\n\t\t\t//\t\tAdds a fulfilledHandler, errorHandler, and progressHandler to be called for\n\t\t\t//\t\tcompletion of a promise. The fulfilledHandler is called when the promise\n\t\t\t//\t\tis fulfilled. The errorHandler is called when a promise fails. The\n\t\t\t//\t\tprogressHandler is called for progress events. All arguments are optional\n\t\t\t//\t\tand non-function values are ignored. The progressHandler is not only an\n\t\t\t//\t\toptional argument, but progress events are purely optional. Promise\n\t\t\t//\t\tproviders are not required to ever create progress events.\n\t\t\t//\n\t\t\t//\t\tThis function will return a new promise that is fulfilled when the given\n\t\t\t//\t\tfulfilledHandler or errorHandler callback is finished. This allows promise\n\t\t\t//\t\toperations to be chained together. The value returned from the callback\n\t\t\t//\t\thandler is the fulfillment value for the returned promise. If the callback\n\t\t\t//\t\tthrows an error, the returned promise will be moved to failed state.\n\t\t\t//\n\t\t\t// returns: \n\t\t\t//\t\tReturns a new promise that represents the result of the\n\t\t\t//\t\texecution of the callback. The callbacks will never affect the original promises value.\n\t\t\t// example:\n\t\t\t//\t\tAn example of using a CommonJS compliant promise:\n\t\t\t//\t\t|\tasyncComputeTheAnswerToEverything().\n\t\t\t//\t\t|\t\tthen(addTwo).\n\t\t\t//\t\t|\t\tthen(printResult, onError);\n\t\t\t//\t\t|\t>44\n\t\t\t//\n\t\t\tvar returnDeferred = progressCallback == mutator ? this : new dojo.Deferred(promise.cancel);\n\t\t\tvar listener = {\n\t\t\t\tresolved: resolvedCallback,\n\t\t\t\terror: errorCallback,\n\t\t\t\tprogress: progressCallback,\n\t\t\t\tdeferred: returnDeferred\n\t\t\t};\n\t\t\tif(nextListener){\n\t\t\t\thead = head.next = listener;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnextListener = head = listener;\n\t\t\t}\n\t\t\tif(finished){\n\t\t\t\tnotify();\n\t\t\t}\n\t\t\treturn returnDeferred.promise; // Promise\n\t\t};\n\t\tvar deferred = this;\n\t\tpromise.cancel = this.cancel = function (){\n\t\t\t// summary:\n\t\t\t//\t\tCancels the asynchronous operation\n\t\t\tif(!finished){\n\t\t\t\tvar error = canceller && canceller(deferred);\n\t\t\t\tif(!finished){\n\t\t\t\t\tif (!(error instanceof Error)){\n\t\t\t\t\t\terror = new Error(error);\n\t\t\t\t\t}\n\t\t\t\t\terror.log = false;\n\t\t\t\t\tdeferred.reject(error);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tfreeze(promise);\n\t};\n\tlang.extend(dojo.Deferred, {\n\t\taddCallback: function (/*Function*/ callback){\n\t\t\t// summary:\n\t\t\t// \t\tAdds successful callback for this deferred instance.\n\t\t\t// returns:\n\t\t\t// \t\tReturns this deferred object.\n\t\t\treturn this.addCallbacks(lang.hitch.apply(dojo, arguments));\t// dojo.Deferred\n\t\t},\n\n\t\taddErrback: function (/*Function*/ errback){\n\t\t\t// summary:\n\t\t\t// \t\tAdds error callback for this deferred instance.\n\t\t\t// returns:\n\t\t\t// \t\tReturns this deferred object.\n\t\t\treturn this.addCallbacks(null, lang.hitch.apply(dojo, arguments));\t// dojo.Deferred\n\t\t},\n\n\t\taddBoth: function (/*Function*/ callback){\n\t\t\t// summary:\n\t\t\t// \t\tAdd handler as both successful callback and error callback for this deferred instance.\n\t\t\t// returns:\n\t\t\t// \t\tReturns this deferred object.\n\t\t\tvar enclosed = lang.hitch.apply(dojo, arguments);\n\t\t\treturn this.addCallbacks(enclosed, enclosed);\t// dojo.Deferred\n\t\t},\n\t\tfired: -1\n\t});\n\n\tdojo.Deferred.when = dojo.when = function(promiseOrValue, /*Function?*/ callback, /*Function?*/ errback, /*Function?*/ progressHandler){\n\t\t// summary:\n\t\t//\t\tThis provides normalization between normal synchronous values and\n\t\t//\t\tasynchronous promises, so you can interact with them in a common way\n\t\t// returns:\n\t\t// \t\tReturns a new promise that represents the result of the execution of callback \n\t\t// \t\twhen parameter \"promiseOrValue\" is promise.\n\t\t// \t\tReturns the execution result of callback when parameter \"promiseOrValue\" is value.\n\t\t// example:\n\t\t//\t\t|\tfunction printFirstAndLast(items){\n\t\t//\t\t|\t\tdojo.when(findFirst(items), console.log);\n\t\t//\t\t|\t\tdojo.when(findLast(items), console.log);\n\t\t//\t\t|\t}\n\t\t//\t\t|\tfunction findFirst(items){\n\t\t//\t\t|\t\treturn dojo.when(items, function(items){\n\t\t//\t\t|\t\t\treturn items[0];\n\t\t//\t\t|\t\t});\n\t\t//\t\t|\t}\n\t\t//\t\t|\tfunction findLast(items){\n\t\t//\t\t|\t\treturn dojo.when(items, function(items){\n\t\t//\t\t|\t\t\treturn items[items.length - 1];\n\t\t//\t\t|\t\t});\n\t\t//\t\t|\t}\n\t\t//\t\tAnd now all three of his functions can be used sync or async.\n\t\t//\t\t|\tprintFirstAndLast([1,2,3,4]) will work just as well as\n\t\t//\t\t|\tprintFirstAndLast(dojo.xhrGet(...));\n\n\t\tif(promiseOrValue && typeof promiseOrValue.then === \"function\"){\n\t\t\treturn promiseOrValue.then(callback, errback, progressHandler);\n\t\t}\n\t\treturn callback ? callback(promiseOrValue) : promiseOrValue;\t// Promise\n\t};\n\n\treturn dojo.Deferred;\n});\n\n},\n'dojo/NodeList-dom':function(){\ndefine([\"./_base/kernel\", \"./query\", \"./_base/array\", \"./_base/lang\", \"./dom-class\", \"./dom-construct\", \"./dom-geometry\", \"./dom-attr\", \"./dom-style\"], function(dojo, query, array, lang, domCls, domCtr, domGeom, domAttr, domStyle){\n\t/*===== var NodeList = dojo.NodeList; =====*/\n\tvar magicGuard = function(a){\n\t\t// summary:\n\t\t//\t\tthe guard function for dojo.attr() and dojo.style()\n\t\treturn a.length == 1 && (typeof a[0] == \"string\"); // inline'd type check\n\t};\n\n\tvar orphan = function(node){\n\t\t// summary:\n\t\t//\t\tfunction to orphan nodes\n\t\tvar p = node.parentNode;\n\t\tif(p){\n\t\t\tp.removeChild(node);\n\t\t}\n\t};\n\t// FIXME: should we move orphan() to dojo.html?\n\n\tvar NodeList = query.NodeList,\n\t\tawc = NodeList._adaptWithCondition,\n\t\taafe = NodeList._adaptAsForEach,\n\t\taam = NodeList._adaptAsMap;\n\n\tfunction getSet(module){\n\t\treturn function(node, name, value){\n\t\t\tif(arguments.length == 2){\n\t\t\t\treturn module[typeof name == \"string\" ? \"get\" : \"set\"](node, name);\n\t\t\t}\n\t\t\t// setter\n\t\t\treturn module.set(node, name, value);\n\t\t};\n\t}\n\n\tlang.extend(NodeList, {\n\t\t_normalize: function(/*String||Element||Object||NodeList*/content, /*DOMNode?*/refNode){\n\t\t\t// summary:\n\t\t\t//\t\tnormalizes data to an array of items to insert.\n\t\t\t// description:\n\t\t\t//\t\tIf content is an object, it can have special properties \"template\" and\n\t\t\t//\t\t\"parse\". If \"template\" is defined, then the template value is run through\n\t\t\t//\t\tdojo.string.substitute (if dojo.string.substitute has been dojo.required elsewhere),\n\t\t\t//\t\tor if templateFunc is a function on the content, that function will be used to\n\t\t\t//\t\ttransform the template into a final string to be used for for passing to dojo._toDom.\n\t\t\t//\t\tIf content.parse is true, then it is remembered for later, for when the content\n\t\t\t//\t\tnodes are inserted into the DOM. At that point, the nodes will be parsed for widgets\n\t\t\t//\t\t(if dojo.parser has been dojo.required elsewhere).\n\n\t\t\t//Wanted to just use a DocumentFragment, but for the array/NodeList\n\t\t\t//case that meant using cloneNode, but we may not want that.\n\t\t\t//Cloning should only happen if the node operations span\n\t\t\t//multiple refNodes. Also, need a real array, not a NodeList from the\n\t\t\t//DOM since the node movements could change those NodeLists.\n\n\t\t\tvar parse = content.parse === true;\n\n\t\t\t//Do we have an object that needs to be run through a template?\n\t\t\tif(typeof content.template == \"string\"){\n\t\t\t\tvar templateFunc = content.templateFunc || (dojo.string && dojo.string.substitute);\n\t\t\t\tcontent = templateFunc ? templateFunc(content.template, content) : content;\n\t\t\t}\n\n\t\t\tvar type = (typeof content);\n\t\t\tif(type == \"string\" || type == \"number\"){\n\t\t\t\tcontent = domCtr.toDom(content, (refNode && refNode.ownerDocument));\n\t\t\t\tif(content.nodeType == 11){\n\t\t\t\t\t//DocumentFragment. It cannot handle cloneNode calls, so pull out the children.\n\t\t\t\t\tcontent = lang._toArray(content.childNodes);\n\t\t\t\t}else{\n\t\t\t\t\tcontent = [content];\n\t\t\t\t}\n\t\t\t}else if(!lang.isArrayLike(content)){\n\t\t\t\tcontent = [content];\n\t\t\t}else if(!lang.isArray(content)){\n\t\t\t\t//To get to this point, content is array-like, but\n\t\t\t\t//not an array, which likely means a DOM NodeList. Convert it now.\n\t\t\t\tcontent = lang._toArray(content);\n\t\t\t}\n\n\t\t\t//Pass around the parse info\n\t\t\tif(parse){\n\t\t\t\tcontent._runParse = true;\n\t\t\t}\n\t\t\treturn content; //Array\n\t\t},\n\n\t\t_cloneNode: function(/*DOMNode*/ node){\n\t\t\t// summary:\n\t\t\t//\t\tprivate utility to clone a node. Not very interesting in the vanilla\n\t\t\t//\t\tdojo.NodeList case, but delegates could do interesting things like\n\t\t\t//\t\tclone event handlers if that is derivable from the node.\n\t\t\treturn node.cloneNode(true);\n\t\t},\n\n\t\t_place: function(/*Array*/ary, /*DOMNode*/refNode, /*String*/position, /*Boolean*/useClone){\n\t\t\t// summary:\n\t\t\t//\t\tprivate utility to handle placing an array of nodes relative to another node.\n\t\t\t// description:\n\t\t\t//\t\tAllows for cloning the nodes in the array, and for\n\t\t\t//\t\toptionally parsing widgets, if ary._runParse is true.\n\n\t\t\t//Avoid a disallowed operation if trying to do an innerHTML on a non-element node.\n\t\t\tif(refNode.nodeType != 1 && position == \"only\"){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar rNode = refNode, tempNode;\n\n\t\t\t//Always cycle backwards in case the array is really a\n\t\t\t//DOM NodeList and the DOM operations take it out of the live collection.\n\t\t\tvar length = ary.length;\n\t\t\tfor(var i = length - 1; i >= 0; i--){\n\t\t\t\tvar node = (useClone ? this._cloneNode(ary[i]) : ary[i]);\n\n\t\t\t\t//If need widget parsing, use a temp node, instead of waiting after inserting into\n\t\t\t\t//real DOM because we need to start widget parsing at one node up from current node,\n\t\t\t\t//which could cause some already parsed widgets to be parsed again.\n\t\t\t\tif(ary._runParse && dojo.parser && dojo.parser.parse){\n\t\t\t\t\tif(!tempNode){\n\t\t\t\t\t\ttempNode = rNode.ownerDocument.createElement(\"div\");\n\t\t\t\t\t}\n\t\t\t\t\ttempNode.appendChild(node);\n\t\t\t\t\tdojo.parser.parse(tempNode);\n\t\t\t\t\tnode = tempNode.firstChild;\n\t\t\t\t\twhile(tempNode.firstChild){\n\t\t\t\t\t\ttempNode.removeChild(tempNode.firstChild);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(i == length - 1){\n\t\t\t\t\tdomCtr.place(node, rNode, position);\n\t\t\t\t}else{\n\t\t\t\t\trNode.parentNode.insertBefore(node, rNode);\n\t\t\t\t}\n\t\t\t\trNode = node;\n\t\t\t}\n\t\t},\n\n\t\t/*=====\n\t\tposition: function(){\n\t\t\t// summary:\n\t\t\t//\t\tReturns border-box objects (x/y/w/h) of all elements in a node list\n\t\t\t//\t\tas an Array (*not* a NodeList). Acts like `dojo.position`, though\n\t\t\t//\t\tassumes the node passed is each node in this list.\n\n\t\t\treturn dojo.map(this, dojo.position); // Array\n\t\t},\n\n\t\tattr: function(property, value){\n\t\t\t// summary:\n\t\t\t//\t\tgets or sets the DOM attribute for every element in the\n\t\t\t//\t\tNodeList. See also `dojo.attr`\n\t\t\t// property: String\n\t\t\t//\t\tthe attribute to get/set\n\t\t\t// value: String?\n\t\t\t//\t\toptional. The value to set the property to\n\t\t\t// returns:\n\t\t\t//\t\tif no value is passed, the result is an array of attribute values\n\t\t\t//\t\tIf a value is passed, the return is this NodeList\n\t\t\t// example:\n\t\t\t//\t\tMake all nodes with a particular class focusable:\n\t\t\t//\t|\tdojo.query(\".focusable\").attr(\"tabIndex\", -1);\n\t\t\t// example:\n\t\t\t//\t\tDisable a group of buttons:\n\t\t\t//\t|\tdojo.query(\"button.group\").attr(\"disabled\", true);\n\t\t\t// example:\n\t\t\t//\t\tinnerHTML can be assigned or retrieved as well:\n\t\t\t//\t|\t// get the innerHTML (as an array) for each list item\n\t\t\t//\t|\tvar ih = dojo.query(\"li.replaceable\").attr(\"innerHTML\");\n\t\t\treturn; // dojo.NodeList\n\t\t\treturn; // Array\n\t\t},\n\n\t\tstyle: function(property, value){\n\t\t\t// summary:\n\t\t\t//\t\tgets or sets the CSS property for every element in the NodeList\n\t\t\t// property: String\n\t\t\t//\t\tthe CSS property to get/set, in JavaScript notation\n\t\t\t//\t\t(\"lineHieght\" instead of \"line-height\")\n\t\t\t// value: String?\n\t\t\t//\t\toptional. The value to set the property to\n\t\t\t// returns:\n\t\t\t//\t\tif no value is passed, the result is an array of strings.\n\t\t\t//\t\tIf a value is passed, the return is this NodeList\n\t\t\treturn; // dojo.NodeList\n\t\t\treturn; // Array\n\t\t},\n\n\t\taddClass: function(className){\n\t\t\t// summary:\n\t\t\t//\t\tadds the specified class to every node in the list\n\t\t\t// className: String|Array\n\t\t\t//\t\tA String class name to add, or several space-separated class names,\n\t\t\t//\t\tor an array of class names.\n\t\t\treturn; // dojo.NodeList\n\t\t},\n\n\t\tremoveClass: function(className){\n\t\t\t// summary:\n\t\t\t//\t\tremoves the specified class from every node in the list\n\t\t\t// className: String|Array?\n\t\t\t//\t\tAn optional String class name to remove, or several space-separated\n\t\t\t//\t\tclass names, or an array of class names. If omitted, all class names\n\t\t\t//\t\twill be deleted.\n\t\t\t// returns:\n\t\t\t//\t\tdojo.NodeList, this list\n\t\t\treturn; // dojo.NodeList\n\t\t},\n\n\t\ttoggleClass: function(className, condition){\n\t\t\t// summary:\n\t\t\t//\t\tAdds a class to node if not present, or removes if present.\n\t\t\t//\t\tPass a boolean condition if you want to explicitly add or remove.\n\t\t\t// condition: Boolean?\n\t\t\t//\t\tIf passed, true means to add the class, false means to remove.\n\t\t\t// className: String\n\t\t\t//\t\tthe CSS class to add\n\t\t\treturn; // dojo.NodeList\n\t\t},\n\n\t\tempty: function(){\n\t\t\t// summary:\n\t\t\t//\t\tclears all content from each node in the list. Effectively\n\t\t\t//\t\tequivalent to removing all child nodes from every item in\n\t\t\t//\t\tthe list.\n\t\t\treturn this.forEach(\"item.innerHTML='';\"); // dojo.NodeList\n\t\t\t// FIXME: should we be checking for and/or disposing of widgets below these nodes?\n\t\t},\n\t\t=====*/\n\n\t\t// useful html methods\n\t\tattr: awc(getSet(domAttr), magicGuard),\n\t\tstyle: awc(getSet(domStyle), magicGuard),\n\n\t\taddClass: aafe(domCls.add),\n\t\tremoveClass: aafe(domCls.remove),\n\t\treplaceClass: aafe(domCls.replace),\n\t\ttoggleClass: aafe(domCls.toggle),\n\n\t\tempty: aafe(domCtr.empty),\n\t\tremoveAttr: aafe(domAttr.remove),\n\n\t\tposition: aam(domGeom.position),\n\t\tmarginBox: aam(domGeom.getMarginBox),\n\n\t\t// FIXME: connectPublisher()? connectRunOnce()?\n\n\t\t/*\n\t\tdestroy: function(){\n\t\t\t// summary:\n\t\t\t//\t\tdestroys every item in the list.\n\t\t\tthis.forEach(d.destroy);\n\t\t\t// FIXME: should we be checking for and/or disposing of widgets below these nodes?\n\t\t},\n\t\t*/\n\n\t\tplace: function(/*String||Node*/ queryOrNode, /*String*/ position){\n\t\t\t// summary:\n\t\t\t//\t\tplaces elements of this node list relative to the first element matched\n\t\t\t//\t\tby queryOrNode. Returns the original NodeList. See: `dojo.place`\n\t\t\t// queryOrNode:\n\t\t\t//\t\tmay be a string representing any valid CSS3 selector or a DOM node.\n\t\t\t//\t\tIn the selector case, only the first matching element will be used\n\t\t\t//\t\tfor relative positioning.\n\t\t\t// position:\n\t\t\t//\t\tcan be one of:\n\t\t\t//\t\t|\t\"last\" (default)\n\t\t\t//\t\t|\t\"first\"\n\t\t\t//\t\t|\t\"before\"\n\t\t\t//\t\t|\t\"after\"\n\t\t\t//\t\t|\t\"only\"\n\t\t\t//\t\t|\t\"replace\"\n\t\t\t//\t\tor an offset in the childNodes property\n\t\t\tvar item = query(queryOrNode)[0];\n\t\t\treturn this.forEach(function(node){ domCtr.place(node, item, position); }); // dojo.NodeList\n\t\t},\n\n\t\torphan: function(/*String?*/ filter){\n\t\t\t// summary:\n\t\t\t//\t\tremoves elements in this list that match the filter\n\t\t\t//\t\tfrom their parents and returns them as a new NodeList.\n\t\t\t// filter:\n\t\t\t//\t\tCSS selector like \".foo\" or \"div > span\"\n\t\t\t// returns:\n\t\t\t//\t\t`dojo.NodeList` containing the orphaned elements\n\t\t\treturn (filter ? query._filterResult(this, filter) : this).forEach(orphan); // dojo.NodeList\n\t\t},\n\n\t\tadopt: function(/*String||Array||DomNode*/ queryOrListOrNode, /*String?*/ position){\n\t\t\t// summary:\n\t\t\t//\t\tplaces any/all elements in queryOrListOrNode at a\n\t\t\t//\t\tposition relative to the first element in this list.\n\t\t\t//\t\tReturns a dojo.NodeList of the adopted elements.\n\t\t\t// queryOrListOrNode:\n\t\t\t//\t\ta DOM node or a query string or a query result.\n\t\t\t//\t\tRepresents the nodes to be adopted relative to the\n\t\t\t//\t\tfirst element of this NodeList.\n\t\t\t// position:\n\t\t\t//\t\tcan be one of:\n\t\t\t//\t\t|\t\"last\" (default)\n\t\t\t//\t\t|\t\"first\"\n\t\t\t//\t\t|\t\"before\"\n\t\t\t//\t\t|\t\"after\"\n\t\t\t//\t\t|\t\"only\"\n\t\t\t//\t\t|\t\"replace\"\n\t\t\t//\t\tor an offset in the childNodes property\n\t\t\treturn query(queryOrListOrNode).place(this[0], position)._stash(this);\t// dojo.NodeList\n\t\t},\n\n\t\t// FIXME: do we need this?\n\t\tquery: function(/*String*/ queryStr){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a new list whose members match the passed query,\n\t\t\t//\t\tassuming elements of the current NodeList as the root for\n\t\t\t//\t\teach search.\n\t\t\t// example:\n\t\t\t//\t\tassume a DOM created by this markup:\n\t\t\t//\t|\t<div id=\"foo\">\n\t\t\t//\t|\t\t<p>\n\t\t\t//\t|\t\t\tbacon is tasty, <span>dontcha think?</span>\n\t\t\t//\t|\t\t</p>\n\t\t\t//\t|\t</div>\n\t\t\t//\t|\t<div id=\"bar\">\n\t\t\t//\t|\t\t<p>great comedians may not be funny <span>in person</span></p>\n\t\t\t//\t|\t</div>\n\t\t\t//\t\tIf we are presented with the following definition for a NodeList:\n\t\t\t//\t|\tvar l = new dojo.NodeList(dojo.byId(\"foo\"), dojo.byId(\"bar\"));\n\t\t\t//\t\tit's possible to find all span elements under paragraphs\n\t\t\t//\t\tcontained by these elements with this sub-query:\n\t\t\t//\t|\tvar spans = l.query(\"p span\");\n\n\t\t\t// FIXME: probably slow\n\t\t\tif(!queryStr){ return this; }\n\t\t\tvar ret = new NodeList;\n\t\t\tthis.map(function(node){\n\t\t\t\t// FIXME: why would we ever get undefined here?\n\t\t\t\tquery(queryStr, node).forEach(function(subNode){\n\t\t\t\t\tif(subNode !== undefined){\n\t\t\t\t\t\tret.push(subNode);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t\treturn ret._stash(this);\t// dojo.NodeList\n\t\t},\n\n\t\tfilter: function(/*String|Function*/ filter){\n\t\t\t// summary:\n\t\t\t//\t\t\"masks\" the built-in javascript filter() method (supported\n\t\t\t//\t\tin Dojo via `dojo.filter`) to support passing a simple\n\t\t\t//\t\tstring filter in addition to supporting filtering function\n\t\t\t//\t\tobjects.\n\t\t\t// filter:\n\t\t\t//\t\tIf a string, a CSS rule like \".thinger\" or \"div > span\".\n\t\t\t// example:\n\t\t\t//\t\t\"regular\" JS filter syntax as exposed in dojo.filter:\n\t\t\t//\t\t|\tdojo.query(\"*\").filter(function(item){\n\t\t\t//\t\t|\t\t// highlight every paragraph\n\t\t\t//\t\t|\t\treturn (item.nodeName == \"p\");\n\t\t\t//\t\t|\t}).style(\"backgroundColor\", \"yellow\");\n\t\t\t// example:\n\t\t\t//\t\tthe same filtering using a CSS selector\n\t\t\t//\t\t|\tdojo.query(\"*\").filter(\"p\").styles(\"backgroundColor\", \"yellow\");\n\n\t\t\tvar a = arguments, items = this, start = 0;\n\t\t\tif(typeof filter == \"string\"){ // inline'd type check\n\t\t\t\titems = query._filterResult(this, a[0]);\n\t\t\t\tif(a.length == 1){\n\t\t\t\t\t// if we only got a string query, pass back the filtered results\n\t\t\t\t\treturn items._stash(this); // dojo.NodeList\n\t\t\t\t}\n\t\t\t\t// if we got a callback, run it over the filtered items\n\t\t\t\tstart = 1;\n\t\t\t}\n\t\t\treturn this._wrap(array.filter(items, a[start], a[start + 1]), this);\t// dojo.NodeList\n\t\t},\n\n\t\t/*\n\t\t// FIXME: should this be \"copyTo\" and include parenting info?\n\t\tclone: function(){\n\t\t\t// summary:\n\t\t\t//\t\tcreates node clones of each element of this list\n\t\t\t//\t\tand returns a new list containing the clones\n\t\t},\n\t\t*/\n\n\t\taddContent: function(/*String||DomNode||Object||dojo.NodeList*/ content, /*String||Integer?*/ position){\n\t\t\t// summary:\n\t\t\t//\t\tadd a node, NodeList or some HTML as a string to every item in the\n\t\t\t//\t\tlist.  Returns the original list.\n\t\t\t// description:\n\t\t\t//\t\ta copy of the HTML content is added to each item in the\n\t\t\t//\t\tlist, with an optional position argument. If no position\n\t\t\t//\t\targument is provided, the content is appended to the end of\n\t\t\t//\t\teach item.\n\t\t\t// content:\n\t\t\t//\t\tDOM node, HTML in string format, a NodeList or an Object. If a DOM node or\n\t\t\t//\t\tNodeList, the content will be cloned if the current NodeList has more than one\n\t\t\t//\t\telement. Only the DOM nodes are cloned, no event handlers. If it is an Object,\n\t\t\t//\t\tit should be an object with at \"template\" String property that has the HTML string\n\t\t\t//\t\tto insert. If dojo.string has already been dojo.required, then dojo.string.substitute\n\t\t\t//\t\twill be used on the \"template\" to generate the final HTML string. Other allowed\n\t\t\t//\t\tproperties on the object are: \"parse\" if the HTML\n\t\t\t//\t\tstring should be parsed for widgets (dojo.require(\"dojo.parser\") to get that\n\t\t\t//\t\toption to work), and \"templateFunc\" if a template function besides dojo.string.substitute\n\t\t\t//\t\tshould be used to transform the \"template\".\n\t\t\t// position:\n\t\t\t//\t\tcan be one of:\n\t\t\t//\t\t|\t\"last\"||\"end\" (default)\n\t\t\t//\t\t|\t\"first||\"start\"\n\t\t\t//\t\t|\t\"before\"\n\t\t\t//\t\t|\t\"after\"\n\t\t\t//\t\t|\t\"replace\" (replaces nodes in this NodeList with new content)\n\t\t\t//\t\t|\t\"only\" (removes other children of the nodes so new content is the only child)\n\t\t\t//\t\tor an offset in the childNodes property\n\t\t\t// example:\n\t\t\t//\t\tappends content to the end if the position is omitted\n\t\t\t//\t|\tdojo.query(\"h3 > p\").addContent(\"hey there!\");\n\t\t\t// example:\n\t\t\t//\t\tadd something to the front of each element that has a\n\t\t\t//\t\t\"thinger\" property:\n\t\t\t//\t|\tdojo.query(\"[thinger]\").addContent(\"...\", \"first\");\n\t\t\t// example:\n\t\t\t//\t\tadds a header before each element of the list\n\t\t\t//\t|\tdojo.query(\".note\").addContent(\"<h4>NOTE:</h4>\", \"before\");\n\t\t\t// example:\n\t\t\t//\t\tadd a clone of a DOM node to the end of every element in\n\t\t\t//\t\tthe list, removing it from its existing parent.\n\t\t\t//\t|\tdojo.query(\".note\").addContent(dojo.byId(\"foo\"));\n\t\t\t// example:\n\t\t\t//\t\tAppend nodes from a templatized string.\n\t\t\t//\t\tdojo.require(\"dojo.string\");\n\t\t\t//\t\tdojo.query(\".note\").addContent({\n\t\t\t//\t\t\ttemplate: '<b>${id}: </b><span>${name}</span>',\n\t\t\t//\t\t\tid: \"user332\",\n\t\t\t//\t\t\tname: \"Mr. Anderson\"\n\t\t\t//\t\t});\n\t\t\t// example:\n\t\t\t//\t\tAppend nodes from a templatized string that also has widgets parsed.\n\t\t\t//\t\tdojo.require(\"dojo.string\");\n\t\t\t//\t\tdojo.require(\"dojo.parser\");\n\t\t\t//\t\tvar notes = dojo.query(\".note\").addContent({\n\t\t\t//\t\t\ttemplate: '<button dojoType=\"dijit.form.Button\">${text}</button>',\n\t\t\t//\t\t\tparse: true,\n\t\t\t//\t\t\ttext: \"Send\"\n\t\t\t//\t\t});\n\t\t\tcontent = this._normalize(content, this[0]);\n\t\t\tfor(var i = 0, node; (node = this[i]); i++){\n\t\t\t\tthis._place(content, node, position, i > 0);\n\t\t\t}\n\t\t\treturn this; //dojo.NodeList\n\t\t}\n\t});\n\n\t/*===== return dojo.NodeList; =====*/\n\treturn NodeList;\n});\n\n},\n'dojo/query':function(){\ndefine([\"./_base/kernel\", \"./has\", \"./dom\", \"./on\", \"./_base/array\", \"./_base/lang\", \"./selector/_loader\", \"./selector/_loader!default\"],\n\tfunction(dojo, has, dom, on, array, lang, loader, defaultEngine){\n\"use strict\";\n\n\thas.add(\"array-extensible\", function(){\n\t\t// test to see if we can extend an array (not supported in old IE)\n\t\treturn lang.delegate([], {length: 1}).length == 1 && !has(\"bug-for-in-skips-shadowed\");\n\t});\n\t\n\tvar ap = Array.prototype, aps = ap.slice, apc = ap.concat, forEach = array.forEach;\n\n\tvar tnl = function(/*Array*/ a, /*dojo.NodeList?*/ parent, /*Function?*/ NodeListCtor){\n\t\t// summary:\n\t\t//\t\tdecorate an array to make it look like a `dojo.NodeList`.\n\t\t// a:\n\t\t//\t\tArray of nodes to decorate.\n\t\t// parent:\n\t\t//\t\tAn optional parent NodeList that generated the current\n\t\t//\t\tlist of nodes. Used to call _stash() so the parent NodeList\n\t\t//\t\tcan be accessed via end() later.\n\t\t// NodeListCtor:\n\t\t//\t\tAn optional constructor function to use for any\n\t\t//\t\tnew NodeList calls. This allows a certain chain of\n\t\t//\t\tNodeList calls to use a different object than dojo.NodeList.\n\t\tvar nodeList = new (NodeListCtor || this._NodeListCtor || nl)(a);\n\t\treturn parent ? nodeList._stash(parent) : nodeList;\n\t};\n\n\tvar loopBody = function(f, a, o){\n\t\ta = [0].concat(aps.call(a, 0));\n\t\to = o || dojo.global;\n\t\treturn function(node){\n\t\t\ta[0] = node;\n\t\t\treturn f.apply(o, a);\n\t\t};\n\t};\n\n\t// adapters\n\n\tvar adaptAsForEach = function(f, o){\n\t\t// summary:\n\t\t//\t\tadapts a single node function to be used in the forEach-type\n\t\t//\t\tactions. The initial object is returned from the specialized\n\t\t//\t\tfunction.\n\t\t// f: Function\n\t\t//\t\ta function to adapt\n\t\t// o: Object?\n\t\t//\t\tan optional context for f\n\t\treturn function(){\n\t\t\tthis.forEach(loopBody(f, arguments, o));\n\t\t\treturn this;\t// Object\n\t\t};\n\t};\n\n\tvar adaptAsMap = function(f, o){\n\t\t// summary:\n\t\t//\t\tadapts a single node function to be used in the map-type\n\t\t//\t\tactions. The return is a new array of values, as via `dojo.map`\n\t\t// f: Function\n\t\t//\t\ta function to adapt\n\t\t// o: Object?\n\t\t//\t\tan optional context for f\n\t\treturn function(){\n\t\t\treturn this.map(loopBody(f, arguments, o));\n\t\t};\n\t};\n\n\tvar adaptAsFilter = function(f, o){\n\t\t// summary:\n\t\t//\t\tadapts a single node function to be used in the filter-type actions\n\t\t// f: Function\n\t\t//\t\ta function to adapt\n\t\t// o: Object?\n\t\t//\t\tan optional context for f\n\t\treturn function(){\n\t\t\treturn this.filter(loopBody(f, arguments, o));\n\t\t};\n\t};\n\n\tvar adaptWithCondition = function(f, g, o){\n\t\t// summary:\n\t\t//\t\tadapts a single node function to be used in the map-type\n\t\t//\t\tactions, behaves like forEach() or map() depending on arguments\n\t\t// f: Function\n\t\t//\t\ta function to adapt\n\t\t// g: Function\n\t\t//\t\ta condition function, if true runs as map(), otherwise runs as forEach()\n\t\t// o: Object?\n\t\t//\t\tan optional context for f and g\n\t\treturn function(){\n\t\t\tvar a = arguments, body = loopBody(f, a, o);\n\t\t\tif(g.call(o || dojo.global, a)){\n\t\t\t\treturn this.map(body);\t// self\n\t\t\t}\n\t\t\tthis.forEach(body);\n\t\t\treturn this;\t// self\n\t\t};\n\t};\n\n\tvar NodeList = function(array){\n\t\t// summary:\n\t\t//\t\tdojo.NodeList is an of Array-like object which adds syntactic\n\t\t//\t\tsugar for chaining, common iteration operations, animation, and\n\t\t//\t\tnode manipulation. NodeLists are most often returned as the\n\t\t//\t\tresult of dojo.query() calls.\n\t\t// description:\n\t\t//\t\tdojo.NodeList instances provide many utilities that reflect\n\t\t//\t\tcore Dojo APIs for Array iteration and manipulation, DOM\n\t\t//\t\tmanipulation, and event handling. Instead of needing to dig up\n\t\t//\t\tfunctions in the dojo.* namespace, NodeLists generally make the\n\t\t//\t\tfull power of Dojo available for DOM manipulation tasks in a\n\t\t//\t\tsimple, chainable way.\n\t\t// example:\n\t\t//\t\tcreate a node list from a node\n\t\t//\t\t|\tnew dojo.NodeList(dojo.byId(\"foo\"));\n\t\t// example:\n\t\t//\t\tget a NodeList from a CSS query and iterate on it\n\t\t//\t\t|\tvar l = dojo.query(\".thinger\");\n\t\t//\t\t|\tl.forEach(function(node, index, nodeList){\n\t\t//\t\t|\t\tconsole.log(index, node.innerHTML);\n\t\t//\t\t|\t});\n\t\t// example:\n\t\t//\t\tuse native and Dojo-provided array methods to manipulate a\n\t\t//\t\tNodeList without needing to use dojo.* functions explicitly:\n\t\t//\t\t|\tvar l = dojo.query(\".thinger\");\n\t\t//\t\t|\t// since NodeLists are real arrays, they have a length\n\t\t//\t\t|\t// property that is both readable and writable and\n\t\t//\t\t|\t// push/pop/shift/unshift methods\n\t\t//\t\t|\tconsole.log(l.length);\n\t\t//\t\t|\tl.push(dojo.create(\"span\"));\n\t\t//\t\t|\n\t\t//\t\t|\t// dojo's normalized array methods work too:\n\t\t//\t\t|\tconsole.log( l.indexOf(dojo.byId(\"foo\")) );\n\t\t//\t\t|\t// ...including the special \"function as string\" shorthand\n\t\t//\t\t|\tconsole.log( l.every(\"item.nodeType == 1\") );\n\t\t//\t\t|\n\t\t//\t\t|\t// NodeLists can be [..] indexed, or you can use the at()\n\t\t//\t\t|\t// function to get specific items wrapped in a new NodeList:\n\t\t//\t\t|\tvar node = l[3]; // the 4th element\n\t\t//\t\t|\tvar newList = l.at(1, 3); // the 2nd and 4th elements\n\t\t// example:\n\t\t//\t\tthe style functions you expect are all there too:\n\t\t//\t\t|\t// style() as a getter...\n\t\t//\t\t|\tvar borders = dojo.query(\".thinger\").style(\"border\");\n\t\t//\t\t|\t// ...and as a setter:\n\t\t//\t\t|\tdojo.query(\".thinger\").style(\"border\", \"1px solid black\");\n\t\t//\t\t|\t// class manipulation\n\t\t//\t\t|\tdojo.query(\"li:nth-child(even)\").addClass(\"even\");\n\t\t//\t\t|\t// even getting the coordinates of all the items\n\t\t//\t\t|\tvar coords = dojo.query(\".thinger\").coords();\n\t\t// example:\n\t\t//\t\tDOM manipulation functions from the dojo.* namespace area also\n\t\t//\t\tavailable:\n\t\t//\t\t|\t// remove all of the elements in the list from their\n\t\t//\t\t|\t// parents (akin to \"deleting\" them from the document)\n\t\t//\t\t|\tdojo.query(\".thinger\").orphan();\n\t\t//\t\t|\t// place all elements in the list at the front of #foo\n\t\t//\t\t|\tdojo.query(\".thinger\").place(\"foo\", \"first\");\n\t\t// example:\n\t\t//\t\tEvent handling couldn't be easier. `dojo.connect` is mapped in,\n\t\t//\t\tand shortcut handlers are provided for most DOM events:\n\t\t//\t\t|\t// like dojo.connect(), but with implicit scope\n\t\t//\t\t|\tdojo.query(\"li\").connect(\"onclick\", console, \"log\");\n\t\t//\t\t|\n\t\t//\t\t|\t// many common event handlers are already available directly:\n\t\t//\t\t|\tdojo.query(\"li\").onclick(console, \"log\");\n\t\t//\t\t|\tvar toggleHovered = dojo.hitch(dojo, \"toggleClass\", \"hovered\");\n\t\t//\t\t|\tdojo.query(\"p\")\n\t\t//\t\t|\t\t.onmouseenter(toggleHovered)\n\t\t//\t\t|\t\t.onmouseleave(toggleHovered);\n\t\t// example:\n\t\t//\t\tchainability is a key advantage of NodeLists:\n\t\t//\t\t|\tdojo.query(\".thinger\")\n\t\t//\t\t|\t\t.onclick(function(e){ /* ... */ })\n\t\t//\t\t|\t\t.at(1, 3, 8) // get a subset\n\t\t//\t\t|\t\t\t.style(\"padding\", \"5px\")\n\t\t//\t\t|\t\t\t.forEach(console.log);\n\t\tvar isNew = this instanceof nl && has(\"array-extensible\");\n\t\tif(typeof array == \"number\"){\n\t\t\tarray = Array(array);\n\t\t}\n\t\tvar nodeArray = (array && \"length\" in array) ? array : arguments;\n\t\tif(isNew || !nodeArray.sort){\n\t\t\t// make sure it's a real array before we pass it on to be wrapped \n\t\t\tvar target = isNew ? this : [],\n\t\t\t\tl = target.length = nodeArray.length;\n\t\t\tfor(var i = 0; i < l; i++){\n\t\t\t\ttarget[i] = nodeArray[i];\n\t\t\t}\n\t\t\tif(isNew){\n\t\t\t\t// called with new operator, this means we are going to use this instance and push\n\t\t\t\t// the nodes on to it. This is usually much faster since the NodeList properties\n\t\t\t\t//\tdon't need to be copied (unless the list of nodes is extremely large).\n\t\t\t\treturn target;\n\t\t\t}\n\t\t\tnodeArray = target;\n\t\t}\n\t\t// called without new operator, use a real array and copy prototype properties,\n\t\t// this is slower and exists for back-compat. Should be removed in 2.0.\n\t\tlang._mixin(nodeArray, nlp);\n\t\tnodeArray._NodeListCtor = function(array){\n\t\t\t// call without new operator to preserve back-compat behavior\n\t\t\treturn nl(array);\n\t\t};\n\t\treturn nodeArray;\n\t};\n\t\n\tvar nl = NodeList, nlp = nl.prototype = \n\t\thas(\"array-extensible\") ? [] : {};// extend an array if it is extensible\n\n\t// expose adapters and the wrapper as private functions\n\n\tnl._wrap = nlp._wrap = tnl;\n\tnl._adaptAsMap = adaptAsMap;\n\tnl._adaptAsForEach = adaptAsForEach;\n\tnl._adaptAsFilter  = adaptAsFilter;\n\tnl._adaptWithCondition = adaptWithCondition;\n\n\t// mass assignment\n\n\t// add array redirectors\n\tforEach([\"slice\", \"splice\"], function(name){\n\t\tvar f = ap[name];\n\t\t//Use a copy of the this array via this.slice() to allow .end() to work right in the splice case.\n\t\t// CANNOT apply ._stash()/end() to splice since it currently modifies\n\t\t// the existing this array -- it would break backward compatibility if we copy the array before\n\t\t// the splice so that we can use .end(). So only doing the stash option to this._wrap for slice.\n\t\tnlp[name] = function(){ return this._wrap(f.apply(this, arguments), name == \"slice\" ? this : null); };\n\t});\n\t// concat should be here but some browsers with native NodeList have problems with it\n\n\t// add array.js redirectors\n\tforEach([\"indexOf\", \"lastIndexOf\", \"every\", \"some\"], function(name){\n\t\tvar f = array[name];\n\t\tnlp[name] = function(){ return f.apply(dojo, [this].concat(aps.call(arguments, 0))); };\n\t});\n\n\t/*===== var NodeList = dojo.NodeList; =====*/\n\tlang.extend(NodeList, {\n\t\t// copy the constructors\n\t\tconstructor: nl,\n\t\t_NodeListCtor: nl,\n\t\ttoString: function(){\n\t\t\t// Array.prototype.toString can't be applied to objects, so we use join\n\t\t\treturn this.join(\",\");\n\t\t},\n\t\t_stash: function(parent){\n\t\t\t// summary:\n\t\t\t//\t\tprivate function to hold to a parent NodeList. end() to return the parent NodeList.\n\t\t\t//\n\t\t\t// example:\n\t\t\t// How to make a `dojo.NodeList` method that only returns the third node in\n\t\t\t// the dojo.NodeList but allows access to the original NodeList by using this._stash:\n\t\t\t//\t|\tdojo.extend(dojo.NodeList, {\n\t\t\t//\t|\t\tthird: function(){\n\t\t\t//\t|\t\t\tvar newNodeList = dojo.NodeList(this[2]);\n\t\t\t//\t|\t\t\treturn newNodeList._stash(this);\n\t\t\t//\t|\t\t}\n\t\t\t//\t|\t});\n\t\t\t//\t|\t// then see how _stash applies a sub-list, to be .end()'ed out of\n\t\t\t//\t|\tdojo.query(\".foo\")\n\t\t\t//\t|\t\t.third()\n\t\t\t//\t|\t\t\t.addClass(\"thirdFoo\")\n\t\t\t//\t|\t\t.end()\n\t\t\t//\t|\t\t// access to the orig .foo list\n\t\t\t//\t|\t\t.removeClass(\"foo\")\n\t\t\t//\t|\n\t\t\t//\n\t\t\tthis._parent = parent;\n\t\t\treturn this; //dojo.NodeList\n\t\t},\n\n\t\ton: function(eventName, listener){\n\t\t\t// summary:\n\t\t\t//\t\tListen for events on the nodes in the NodeList. Basic usage is:\n\t\t\t//\t\t| query(\".my-class\").on(\"click\", listener);\n\t\t\t// \t\tThis supports event delegation by using selectors as the first argument with the event names as\n\t\t\t//\t\tpseudo selectors. For example:\n\t\t\t//\t\t| dojo.query(\"#my-list\").on(\"li:click\", listener);\n\t\t\t//\t\tThis will listen for click events within <li> elements that are inside the #my-list element.\n\t\t\t//\t\tBecause on supports CSS selector syntax, we can use comma-delimited events as well:\n\t\t\t//\t\t| dojo.query(\"#my-list\").on(\"li button:mouseover, li:click\", listener);\n\t\t\tvar handles = this.map(function(node){\n\t\t\t\treturn on(node, eventName, listener); // TODO: apply to the NodeList so the same selector engine is used for matches\n\t\t\t});\n\t\t\thandles.remove = function(){\n\t\t\t\tfor(var i = 0; i < handles.length; i++){\n\t\t\t\t\thandles[i].remove();\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn handles;\n\t\t},\n\n\t\tend: function(){\n\t\t\t// summary:\n\t\t\t//\t\tEnds use of the current `dojo.NodeList` by returning the previous dojo.NodeList\n\t\t\t//\t\tthat generated the current dojo.NodeList.\n\t\t\t// description:\n\t\t\t//\t\tReturns the `dojo.NodeList` that generated the current `dojo.NodeList`. If there\n\t\t\t//\t\tis no parent dojo.NodeList, an empty dojo.NodeList is returned.\n\t\t\t// example:\n\t\t\t//\t|\tdojo.query(\"a\")\n\t\t\t//\t|\t\t.filter(\".disabled\")\n\t\t\t//\t|\t\t\t// operate on the anchors that only have a disabled class\n\t\t\t//\t|\t\t\t.style(\"color\", \"grey\")\n\t\t\t//\t|\t\t.end()\n\t\t\t//\t|\t\t// jump back to the list of anchors\n\t\t\t//\t|\t\t.style(...)\n\t\t\t//\n\t\t\tif(this._parent){\n\t\t\t\treturn this._parent;\n\t\t\t}else{\n\t\t\t\t//Just return empty list.\n\t\t\t\treturn new this._NodeListCtor(0);\n\t\t\t}\n\t\t},\n\n\t\t// http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array#Methods\n\n\t\t// FIXME: handle return values for #3244\n\t\t//\t\thttp://trac.dojotoolkit.org/ticket/3244\n\n\t\t// FIXME:\n\t\t//\t\tneed to wrap or implement:\n\t\t//\t\t\tjoin (perhaps w/ innerHTML/outerHTML overload for toString() of items?)\n\t\t//\t\t\treduce\n\t\t//\t\t\treduceRight\n\n\t\t/*=====\n\t\tslice: function(begin, end){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a new NodeList, maintaining this one in place\n\t\t\t// description:\n\t\t\t//\t\tThis method behaves exactly like the Array.slice method\n\t\t\t//\t\twith the caveat that it returns a dojo.NodeList and not a\n\t\t\t//\t\traw Array. For more details, see Mozilla's (slice\n\t\t\t//\t\tdocumentation)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:slice]\n\t\t\t// begin: Integer\n\t\t\t//\t\tCan be a positive or negative integer, with positive\n\t\t\t//\t\tintegers noting the offset to begin at, and negative\n\t\t\t//\t\tintegers denoting an offset from the end (i.e., to the left\n\t\t\t//\t\tof the end)\n\t\t\t// end: Integer?\n\t\t\t//\t\tOptional parameter to describe what position relative to\n\t\t\t//\t\tthe NodeList's zero index to end the slice at. Like begin,\n\t\t\t//\t\tcan be positive or negative.\n\t\t\treturn this._wrap(a.slice.apply(this, arguments));\n\t\t},\n\n\t\tsplice: function(index, howmany, item){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a new NodeList, manipulating this NodeList based on\n\t\t\t//\t\tthe arguments passed, potentially splicing in new elements\n\t\t\t//\t\tat an offset, optionally deleting elements\n\t\t\t// description:\n\t\t\t//\t\tThis method behaves exactly like the Array.splice method\n\t\t\t//\t\twith the caveat that it returns a dojo.NodeList and not a\n\t\t\t//\t\traw Array. For more details, see Mozilla's (splice\n\t\t\t//\t\tdocumentation)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:splice]\n\t\t\t//\t\tFor backwards compatibility, calling .end() on the spliced NodeList\n\t\t\t//\t\tdoes not return the original NodeList -- splice alters the NodeList in place.\n\t\t\t// index: Integer\n\t\t\t//\t\tbegin can be a positive or negative integer, with positive\n\t\t\t//\t\tintegers noting the offset to begin at, and negative\n\t\t\t//\t\tintegers denoting an offset from the end (i.e., to the left\n\t\t\t//\t\tof the end)\n\t\t\t// howmany: Integer?\n\t\t\t//\t\tOptional parameter to describe what position relative to\n\t\t\t//\t\tthe NodeList's zero index to end the slice at. Like begin,\n\t\t\t//\t\tcan be positive or negative.\n\t\t\t// item: Object...?\n\t\t\t//\t\tAny number of optional parameters may be passed in to be\n\t\t\t//\t\tspliced into the NodeList\n\t\t\t// returns:\n\t\t\t//\t\tdojo.NodeList\n\t\t\treturn this._wrap(a.splice.apply(this, arguments));\n\t\t},\n\n\t\tindexOf: function(value, fromIndex){\n\t\t\t// summary:\n\t\t\t//\t\tsee dojo.indexOf(). The primary difference is that the acted-on\n\t\t\t//\t\tarray is implicitly this NodeList\n\t\t\t// value: Object:\n\t\t\t//\t\tThe value to search for.\n\t\t\t// fromIndex: Integer?:\n\t\t\t//\t\tThe location to start searching from. Optional. Defaults to 0.\n\t\t\t// description:\n\t\t\t//\t\tFor more details on the behavior of indexOf, see Mozilla's\n\t\t\t//\t\t(indexOf\n\t\t\t//\t\tdocs)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:indexOf]\n\t\t\t// returns:\n\t\t\t//\t\tPositive Integer or 0 for a match, -1 of not found.\n\t\t\treturn d.indexOf(this, value, fromIndex); // Integer\n\t\t},\n\n\t\tlastIndexOf: function(value, fromIndex){\n\t\t\t// summary:\n\t\t\t//\t\tsee dojo.lastIndexOf(). The primary difference is that the\n\t\t\t//\t\tacted-on array is implicitly this NodeList\n\t\t\t// description:\n\t\t\t//\t\tFor more details on the behavior of lastIndexOf, see\n\t\t\t//\t\tMozilla's (lastIndexOf\n\t\t\t//\t\tdocs)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:lastIndexOf]\n\t\t\t// value: Object\n\t\t\t//\t\tThe value to search for.\n\t\t\t// fromIndex: Integer?\n\t\t\t//\t\tThe location to start searching from. Optional. Defaults to 0.\n\t\t\t// returns:\n\t\t\t//\t\tPositive Integer or 0 for a match, -1 of not found.\n\t\t\treturn d.lastIndexOf(this, value, fromIndex); // Integer\n\t\t},\n\n\t\tevery: function(callback, thisObject){\n\t\t\t// summary:\n\t\t\t//\t\tsee `dojo.every()` and the (Array.every\n\t\t\t//\t\tdocs)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:every].\n\t\t\t//\t\tTakes the same structure of arguments and returns as\n\t\t\t//\t\tdojo.every() with the caveat that the passed array is\n\t\t\t//\t\timplicitly this NodeList\n\t\t\t// callback: Function: the callback\n\t\t\t// thisObject: Object?: the context\n\t\t\treturn d.every(this, callback, thisObject); // Boolean\n\t\t},\n\n\t\tsome: function(callback, thisObject){\n\t\t\t// summary:\n\t\t\t//\t\tTakes the same structure of arguments and returns as\n\t\t\t//\t\t`dojo.some()` with the caveat that the passed array is\n\t\t\t//\t\timplicitly this NodeList.  See `dojo.some()` and Mozilla's\n\t\t\t//\t\t(Array.some\n\t\t\t//\t\tdocumentation)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:some].\n\t\t\t// callback: Function: the callback\n\t\t\t// thisObject: Object?: the context\n\t\t\treturn d.some(this, callback, thisObject); // Boolean\n\t\t},\n\t\t=====*/\n\n\t\tconcat: function(item){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a new NodeList comprised of items in this NodeList\n\t\t\t//\t\tas well as items passed in as parameters\n\t\t\t// description:\n\t\t\t//\t\tThis method behaves exactly like the Array.concat method\n\t\t\t//\t\twith the caveat that it returns a `dojo.NodeList` and not a\n\t\t\t//\t\traw Array. For more details, see the (Array.concat\n\t\t\t//\t\tdocs)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:concat]\n\t\t\t// item: Object?\n\t\t\t//\t\tAny number of optional parameters may be passed in to be\n\t\t\t//\t\tspliced into the NodeList\n\t\t\t// returns:\n\t\t\t//\t\tdojo.NodeList\n\n\t\t\t//return this._wrap(apc.apply(this, arguments));\n\t\t\t// the line above won't work for the native NodeList :-(\n\n\t\t\t// implementation notes:\n\t\t\t// 1) Native NodeList is not an array, and cannot be used directly\n\t\t\t// in concat() --- the latter doesn't recognize it as an array, and\n\t\t\t// does not inline it, but append as a single entity.\n\t\t\t// 2) On some browsers (e.g., Safari) the \"constructor\" property is\n\t\t\t// read-only and cannot be changed. So we have to test for both\n\t\t\t// native NodeList and dojo.NodeList in this property to recognize\n\t\t\t// the node list.\n\n\t\t\tvar t = lang.isArray(this) ? this : aps.call(this, 0),\n\t\t\t\tm = array.map(arguments, function(a){\n\t\t\t\t\treturn a && !lang.isArray(a) &&\n\t\t\t\t\t\t(typeof NodeList != \"undefined\" && a.constructor === NodeList || a.constructor === this._NodeListCtor) ?\n\t\t\t\t\t\t\taps.call(a, 0) : a;\n\t\t\t\t});\n\t\t\treturn this._wrap(apc.apply(t, m), this);\t// dojo.NodeList\n\t\t},\n\n\t\tmap: function(/*Function*/ func, /*Function?*/ obj){\n\t\t\t// summary:\n\t\t\t//\t\tsee dojo.map(). The primary difference is that the acted-on\n\t\t\t//\t\tarray is implicitly this NodeList and the return is a\n\t\t\t//\t\tdojo.NodeList (a subclass of Array)\n\t\t\t///return d.map(this, func, obj, d.NodeList); // dojo.NodeList\n\t\t\treturn this._wrap(array.map(this, func, obj), this); // dojo.NodeList\n\t\t},\n\n\t\tforEach: function(callback, thisObj){\n\t\t\t// summary:\n\t\t\t//\t\tsee `dojo.forEach()`. The primary difference is that the acted-on\n\t\t\t//\t\tarray is implicitly this NodeList. If you want the option to break out\n\t\t\t//\t\tof the forEach loop, use every() or some() instead.\n\t\t\tforEach(this, callback, thisObj);\n\t\t\t// non-standard return to allow easier chaining\n\t\t\treturn this; // dojo.NodeList\n\t\t},\n\t\tfilter: function(/*String|Function*/ filter){\n\t\t\t// summary:\n\t\t\t//\t\t\"masks\" the built-in javascript filter() method (supported\n\t\t\t//\t\tin Dojo via `dojo.filter`) to support passing a simple\n\t\t\t//\t\tstring filter in addition to supporting filtering function\n\t\t\t//\t\tobjects.\n\t\t\t// filter:\n\t\t\t//\t\tIf a string, a CSS rule like \".thinger\" or \"div > span\".\n\t\t\t// example:\n\t\t\t//\t\t\"regular\" JS filter syntax as exposed in dojo.filter:\n\t\t\t//\t\t|\tdojo.query(\"*\").filter(function(item){\n\t\t\t//\t\t|\t\t// highlight every paragraph\n\t\t\t//\t\t|\t\treturn (item.nodeName == \"p\");\n\t\t\t//\t\t|\t}).style(\"backgroundColor\", \"yellow\");\n\t\t\t// example:\n\t\t\t//\t\tthe same filtering using a CSS selector\n\t\t\t//\t\t|\tdojo.query(\"*\").filter(\"p\").styles(\"backgroundColor\", \"yellow\");\n\n\t\t\tvar a = arguments, items = this, start = 0;\n\t\t\tif(typeof filter == \"string\"){ // inline'd type check\n\t\t\t\titems = query._filterResult(this, a[0]);\n\t\t\t\tif(a.length == 1){\n\t\t\t\t\t// if we only got a string query, pass back the filtered results\n\t\t\t\t\treturn items._stash(this); // dojo.NodeList\n\t\t\t\t}\n\t\t\t\t// if we got a callback, run it over the filtered items\n\t\t\t\tstart = 1;\n\t\t\t}\n\t\t\treturn this._wrap(array.filter(items, a[start], a[start + 1]), this);\t// dojo.NodeList\n\t\t},\n\t\tinstantiate: function(/*String|Object*/ declaredClass, /*Object?*/ properties){\n\t\t\t// summary:\n\t\t\t//\t\tCreate a new instance of a specified class, using the\n\t\t\t//\t\tspecified properties and each node in the nodeList as a\n\t\t\t//\t\tsrcNodeRef.\n\t\t\t// example:\n\t\t\t//\t\tGrabs all buttons in the page and converts them to diji.form.Buttons.\n\t\t\t//\t|\tvar buttons = dojo.query(\"button\").instantiate(\"dijit.form.Button\", {showLabel: true});\n\t\t\tvar c = lang.isFunction(declaredClass) ? declaredClass : lang.getObject(declaredClass);\n\t\t\tproperties = properties || {};\n\t\t\treturn this.forEach(function(node){\n\t\t\t\tnew c(properties, node);\n\t\t\t});\t// dojo.NodeList\n\t\t},\n\t\tat: function(/*===== index =====*/){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a new NodeList comprised of items in this NodeList\n\t\t\t//\t\tat the given index or indices.\n\t\t\t//\n\t\t\t// index: Integer...\n\t\t\t//\t\tOne or more 0-based indices of items in the current\n\t\t\t//\t\tNodeList. A negative index will start at the end of the\n\t\t\t//\t\tlist and go backwards.\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\tShorten the list to the first, second, and third elements\n\t\t\t//\t|\tdojo.query(\"a\").at(0, 1, 2).forEach(fn);\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\tRetrieve the first and last elements of a unordered list:\n\t\t\t//\t|\tdojo.query(\"ul > li\").at(0, -1).forEach(cb);\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\tDo something for the first element only, but end() out back to\n\t\t\t//\tthe original list and continue chaining:\n\t\t\t//\t|\tdojo.query(\"a\").at(0).onclick(fn).end().forEach(function(n){\n\t\t\t//\t|\t\tconsole.log(n); // all anchors on the page.\n\t\t\t//\t|\t})\n\t\t\t//\n\t\t\t// returns:\n\t\t\t//\t\tdojo.NodeList\n\t\t\tvar t = new this._NodeListCtor(0);\n\t\t\tforEach(arguments, function(i){\n\t\t\t\tif(i < 0){ i = this.length + i; }\n\t\t\t\tif(this[i]){ t.push(this[i]); }\n\t\t\t}, this);\n\t\t\treturn t._stash(this); // dojo.NodeList\n\t\t}\n\t});\n\n\n/*===== \ndojo.query = function(selector, context){\n\t// summary:\n\t//\t\tThis modules provides DOM querying functionality. The module export is a function\n\t//\t\tthat can be used to query for DOM nodes by CSS selector and returns a dojo.NodeList\n\t//\t\trepresenting the matching nodes.\n\t//\n\t// selector: String\n\t//\t\tA CSS selector to search for.\n\t// context: String|DomNode?\n\t//\t\tAn optional context to limit the searching scope. Only nodes under `context` will be \n\t//\t\tscanned. \n\t// \n\t//\texample:\n\t//\t\tadd an onclick handler to every submit button in the document\n\t//\t\twhich causes the form to be sent via Ajax instead:\n\t//\t|\tdefine([\"dojo/query\"], function(query){\n\t// \t|\tquery(\"input[type='submit']\").on(\"click\", function(e){\n\t//\t|\t\tdojo.stopEvent(e); // prevent sending the form\n\t//\t|\t\tvar btn = e.target;\n\t//\t|\t\tdojo.xhrPost({\n\t//\t|\t\t\tform: btn.form,\n\t//\t|\t\t\tload: function(data){\n\t//\t|\t\t\t\t// replace the form with the response\n\t//\t|\t\t\t\tvar div = dojo.doc.createElement(\"div\");\n\t//\t|\t\t\t\tdojo.place(div, btn.form, \"after\");\n\t//\t|\t\t\t\tdiv.innerHTML = data;\n\t//\t|\t\t\t\tdojo.style(btn.form, \"display\", \"none\");\n\t//\t|\t\t\t}\n\t//\t|\t\t});\n\t//\t|\t}); \n\t//\n\t// description:\n\t//\t\tdojo/query is responsible for loading the appropriate query engine and wrapping \n\t//\t\tits results with a `dojo.NodeList`. You can use dojo/query with a specific selector engine\n\t//\t\tby using it as a plugin. For example, if you installed the sizzle package, you could\n\t//\t\tuse it as the selector engine with:\n\t//\t\t|\tdefine(\"dojo/query!sizzle\", function(query){\n\t//\t\t|\t\tquery(\"div\")...\n\t//\n\t//\t\tThe id after the ! can be a module id of the selector engine or one of the following values:\n\t//\t\t|\t+ acme: This is the default engine used by Dojo base, and will ensure that the full\n\t//\t\t|\tAcme engine is always loaded. \n\t//\t\t|\t\n\t//\t\t|\t+ css2: If the browser has a native selector engine, this will be used, otherwise a\n\t//\t\t|\tvery minimal lightweight selector engine will be loaded that can do simple CSS2 selectors\n\t//\t\t|\t(by #id, .class, tag, and [name=value] attributes, with standard child or descendant (>)\n\t//\t\t|\toperators) and nothing more.\n\t//\t\t|\n\t//\t\t|\t+ css2.1: If the browser has a native selector engine, this will be used, otherwise the\n\t//\t\t|\tfull Acme engine will be loaded. \n\t//\t\t|\t\n\t//\t\t|\t+ css3: If the browser has a native selector engine with support for CSS3 pseudo\n\t//\t\t|\tselectors (most modern browsers except IE8), this will be used, otherwise the\n\t//\t\t|\tfull Acme engine will be loaded.\n\t//\t\t|\t\n\t//\t\t|\t+ Or the module id of a selector engine can be used to explicitly choose the selector engine\n\t//\t\t\n\t//\t\tFor example, if you are using CSS3 pseudo selectors in module, you can specify that\n\t//\t\tyou will need support them with:\n\t//\t\t|\tdefine(\"dojo/query!css3\", function(query){\n\t//\t\t|\t\tquery('#t > h3:nth-child(odd)')...\n\t//\n\t//\t\tYou can also choose the selector engine/load configuration by setting the <FIXME:what is the configuration setting?>.\n\t//\t\tFor example:\n\t//\t\t|\t<script data-dojo-config=\"query-selector:'css3'\" src=\"dojo.js\"></script>\n\t//\t\t\n\treturn new dojo.NodeList(); // dojo.NodeList\n};\n=====*/\n\nfunction queryForEngine(engine, NodeList){\n\tvar query = function(/*String*/ query, /*String|DOMNode?*/ root){\n\t\t//\tsummary:\n\t\t//\t\tReturns nodes which match the given CSS selector, searching the\n\t\t//\t\tentire document by default but optionally taking a node to scope\n\t\t//\t\tthe search by. Returns an instance of dojo.NodeList.\n\t\tif(typeof root == \"string\"){\n\t\t\troot = dom.byId(root);\n\t\t\tif(!root){\n\t\t\t\treturn new NodeList([]);\n\t\t\t}\n\t\t}\n\t\tvar results = typeof query == \"string\" ? engine(query, root) : query.orphan ? query : [query];\n\t\tif(results.orphan){\n\t\t\t// already wrapped\n\t\t\treturn results; \n\t\t}\n\t\treturn new NodeList(results);\n\t};\n\tquery.matches = engine.match || function(node, selector, root){\n\t\t// summary:\n\t\t//\t\tTest to see if a node matches a selector\n\t\treturn query.filter([node], selector, root).length > 0;\n\t};\n\t// the engine provides a filtering function, use it to for matching\n\tquery.filter = engine.filter || function(nodes, selector, root){\n\t\t// summary:\n\t\t//\t\tFilters an array of nodes. Note that this does not guarantee to return a dojo.NodeList, just an array.\n\t\treturn query(selector, root).filter(function(node){\n\t\t\treturn array.indexOf(nodes, node) > -1;\n\t\t});\n\t};\n\tif(typeof engine != \"function\"){\n\t\tvar search = engine.search;\n\t\tengine = function(selector, root){\n\t\t\t// Slick does it backwards (or everyone else does it backwards, probably the latter)\n\t\t\treturn search(root || document, selector);\n\t\t};\n\t}\n\treturn query;\n}\nvar query = queryForEngine(defaultEngine, NodeList);\n// the query that is returned from this module is slightly different than dojo.query,\n// because dojo.query has to maintain backwards compatibility with returning a\n// true array which has performance problems. The query returned from the module\n// does not use true arrays, but rather inherits from Array, making it much faster to\n// instantiate.\ndojo.query = queryForEngine(defaultEngine, function(array){\n\t// call it without the new operator to invoke the back-compat behavior that returns a true array\n\treturn NodeList(array);\n});\n\nquery.load = /*===== dojo.query.load= ======*/ function(id, parentRequire, loaded, config){\n\t// summary: can be used as AMD plugin to conditionally load new query engine\n\t// example:\n\t//\t|\tdefine([\"dojo/query!custom\"], function(qsa){ \n\t//\t|\t\t// loaded selector/custom.js as engine\n\t//\t|\t\tqsa(\"#foobar\").forEach(...);\n\t//\t|\t});\n\tloader.load(id, parentRequire, function(engine){\n\t\tloaded(queryForEngine(engine, NodeList));\n\t});\n};\n\ndojo._filterQueryResult = query._filterResult = function(nodes, selector, root){\n\treturn new NodeList(query.filter(nodes, selector, root));\n};\ndojo.NodeList = query.NodeList = NodeList;\nreturn query;\n});\n\n},\n'dojo/has':function(){\ndefine([\"require\"], function(require) {\n\t// module:\n\t//\t\tdojo/has\n\t// summary:\n\t//\t\tDefines the has.js API and several feature tests used by dojo.\n\t// description:\n\t//\t\tThis module defines the has API as described by the project has.js with the following additional features:\n\t//\n\t//\t\t\t* the has test cache is exposed at has.cache.\n\t//\t\t\t* the method has.add includes a forth parameter that controls whether or not existing tests are replaced\n\t//\t\t\t* the loader's has cache may be optionally copied into this module's has cahce.\n\t//\n\t//\t\tThis module adopted from https://github.com/phiggins42/has.js; thanks has.js team!\n\n\t// try to pull the has implementation from the loader; both the dojo loader and bdLoad provide one\n\t// WARNING: if a foreign loader defines require.has to be something other than the has.js API, then this implementation fail\n\tvar has = require.has || function(){};\n\tif(!1){\n\t\t// notice the condition is written so that if 1 is transformed to 1 during a build\n\t\t// the conditional will be (!1 && typeof has==\"function\") which is statically false and the closure\n\t\t// compiler will discard the block.\n\t\tvar\n\t\t\tisBrowser =\n\t\t\t\t// the most fundamental decision: are we in the browser?\n\t\t\t\ttypeof window != \"undefined\" &&\n\t\t\t\ttypeof location != \"undefined\" &&\n\t\t\t\ttypeof document != \"undefined\" &&\n\t\t\t\twindow.location == location && window.document == document,\n\n\t\t\t// has API variables\n\t\t\tglobal = this,\n\t\t\tdoc = isBrowser && document,\n\t\t\telement = doc && doc.createElement(\"DiV\"),\n\t\t\tcache = {};\n\n\t\thas = /*===== dojo.has= =====*/ function(name){\n\t\t\t//\tsummary:\n\t\t\t//\t\tReturn the current value of the named feature.\n\t\t\t//\n\t\t\t//\tname: String|Integer\n\t\t\t//\t\tThe name (if a string) or identifier (if an integer) of the feature to test.\n\t\t\t//\n\t\t\t//\tdescription:\n\t\t\t//\t\tReturns the value of the feature named by name. The feature must have been\n\t\t\t//\t\tpreviously added to the cache by has.add.\n\n\t\t\treturn cache[name] = typeof cache[name] == \"function\" ? cache[name](global, doc, element) : cache[name]; // Boolean\n\t\t};\n\n\t\thas.cache = cache;\n\n\t\thas.add = /*====== dojo.has.add= ======*/ function(name, test, now, force){\n\t\t\t// summary:\n\t\t\t//\t Register a new feature test for some named feature.\n\t\t\t//\n\t\t\t// name: String|Integer\n\t\t\t//\t The name (if a string) or identifier (if an integer) of the feature to test.\n\t\t\t//\n\t\t\t// test: Function\n\t\t\t//\t A test function to register. If a function, queued for testing until actually\n\t\t\t//\t needed. The test function should return a boolean indicating\n\t\t\t//\t the presence of a feature or bug.\n\t\t\t//\n\t\t\t// now: Boolean?\n\t\t\t//\t Optional. Omit if `test` is not a function. Provides a way to immediately\n\t\t\t//\t run the test and cache the result.\n\t\t\t//\n\t\t\t// force: Boolean?\n\t\t\t//\t Optional. If the test already exists and force is truthy, then the existing\n\t\t\t//\t test will be replaced; otherwise, add does not replace an existing test (that\n\t\t\t//\t is, by default, the first test advice wins).\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\t\tA redundant test, testFn with immediate execution:\n\t\t\t//\t|\t\t\t\thas.add(\"javascript\", function(){ return true; }, true);\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\t\tAgain with the redundantness. You can do this in your tests, but we should\n\t\t\t//\t\t\tnot be doing this in any internal has.js tests\n\t\t\t//\t|\t\t\t\thas.add(\"javascript\", true);\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\t\tThree things are passed to the testFunction. `global`, `document`, and a generic element\n\t\t\t//\t\t\tfrom which to work your test should the need arise.\n\t\t\t//\t|\t\t\t\thas.add(\"bug-byid\", function(g, d, el){\n\t\t\t//\t|\t\t\t\t\t\t// g\t== global, typically window, yadda yadda\n\t\t\t//\t|\t\t\t\t\t\t// d\t== document object\n\t\t\t//\t|\t\t\t\t\t\t// el == the generic element. a `has` element.\n\t\t\t//\t|\t\t\t\t\t\treturn false; // fake test, byid-when-form-has-name-matching-an-id is slightly longer\n\t\t\t//\t|\t\t\t\t});\n\n\t\t\t(typeof cache[name]==\"undefined\" || force) && (cache[name]= test);\n\t\t\treturn now && has(name);\n\t\t};\n\n\t\t// since we're operating under a loader that doesn't provide a has API, we must explicitly initialize\n\t\t// has as it would have otherwise been initialized by the dojo loader; use has.add to the builder\n\t\t// can optimize these away iff desired\n\t\ttrue || has.add(\"host-browser\", isBrowser);\n\t\ttrue || has.add(\"dom\", isBrowser);\n\t\ttrue || has.add(\"dojo-dom-ready-api\", 1);\n\t\ttrue || has.add(\"dojo-sniff\", 1);\n\t}\n\n\tif(1){\n\t\tvar agent = navigator.userAgent;\n\t\t// Common application level tests\n\t\thas.add(\"dom-addeventlistener\", !!document.addEventListener);\n\t\thas.add(\"touch\", \"ontouchstart\" in document);\n\t\t// I don't know if any of these tests are really correct, just a rough guess\n\t\thas.add(\"device-width\", screen.availWidth || innerWidth);\n\t\thas.add(\"agent-ios\", !!agent.match(/iPhone|iP[ao]d/));\n\t\thas.add(\"agent-android\", agent.indexOf(\"android\") > 1);\n\t}\n\n\thas.clearElement = /*===== dojo.has.clearElement= ======*/ function(element) {\n\t\t// summary:\n\t\t//\t Deletes the contents of the element passed to test functions.\n\t\telement.innerHTML= \"\";\n\t\treturn element;\n\t};\n\n\thas.normalize = /*===== dojo.has.normalize= ======*/ function(id, toAbsMid){\n\t\t// summary:\n\t\t//\t Resolves id into a module id based on possibly-nested tenary expression that branches on has feature test value(s).\n\t\t//\n\t\t// toAbsMid: Function\n\t\t//\t Resolves a relative module id into an absolute module id\n\t\tvar\n\t\t\ttokens = id.match(/[\\?:]|[^:\\?]*/g), i = 0,\n\t\t\tget = function(skip){\n\t\t\t\tvar term = tokens[i++];\n\t\t\t\tif(term == \":\"){\n\t\t\t\t\t// empty string module name, resolves to 0\n\t\t\t\t\treturn 0;\n\t\t\t\t}else{\n\t\t\t\t\t// postfixed with a ? means it is a feature to branch on, the term is the name of the feature\n\t\t\t\t\tif(tokens[i++] == \"?\"){\n\t\t\t\t\t\tif(!skip && has(term)){\n\t\t\t\t\t\t\t// matched the feature, get the first value from the options\n\t\t\t\t\t\t\treturn get();\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t// did not match, get the second value, passing over the first\n\t\t\t\t\t\t\tget(true);\n\t\t\t\t\t\t\treturn get(skip);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// a module\n\t\t\t\t\treturn term || 0;\n\t\t\t\t}\n\t\t\t};\n\t\tid = get();\n\t\treturn id && toAbsMid(id);\n\t};\n\n\thas.load = /*===== dojo.has.load= ======*/ function(id, parentRequire, loaded){\n\t\t// summary:\n\t\t//\t Conditional loading of AMD modules based on a has feature test value.\n\t\t//\n\t\t// id: String\n\t\t//\t Gives the resolved module id to load.\n\t\t//\n\t\t// parentRequire: Function\n\t\t//\t The loader require function with respect to the module that contained the plugin resource in it's\n\t\t//\t dependency list.\n\t\t//\n\t\t// loaded: Function\n\t\t//\t Callback to loader that consumes result of plugin demand.\n\n\t\tif(id){\n\t\t\tparentRequire([id], loaded);\n\t\t}else{\n\t\t\tloaded();\n\t\t}\n\t};\n\n\treturn has;\n});\n\n},\n'dojo/_base/loader':function(){\ndefine([\"./kernel\", \"../has\", \"require\", \"module\", \"./json\", \"./lang\", \"./array\"], function(dojo, has, require, thisModule, json, lang, array) {\n\t// module:\n\t//\t\tdojo/_base/lader\n\t// summary:\n\t//\t\tThis module defines the v1.x synchronous loader API.\n\n\t// signal the loader in sync mode...\n\t//>>pure-amd\n\n\tif (!1){\n\t\tconsole.error(\"cannot load the Dojo v1.x loader with a foreign loader\");\n\t\treturn 0;\n\t}\n\n\tvar makeErrorToken = function(id){\n\t\t\treturn {src:thisModule.id, id:id};\n\t\t},\n\n\t\tslashName = function(name){\n\t\t\treturn name.replace(/\\./g, \"/\");\n\t\t},\n\n\t\tbuildDetectRe = /\\/\\/>>built/,\n\n\t\tdojoRequireCallbacks = [],\n\t\tdojoRequireModuleStack = [],\n\n\t\tdojoRequirePlugin = function(mid, require, loaded){\n\t\t\tdojoRequireCallbacks.push(loaded);\n\t\t\tarray.forEach(mid.split(\",\"), function(mid){\n\t\t\t\tvar module = getModule(mid, require.module);\n\t\t\t\tdojoRequireModuleStack.push(module);\n\t\t\t\tinjectModule(module);\n\t\t\t});\n\t\t\tcheckDojoRequirePlugin();\n\t\t},\n\n\t\tcheckDojoRequirePlugin = function(){\n\t\t\tdojoRequireModuleStack = array.filter(dojoRequireModuleStack, function(module){\n\t\t\t\treturn module.injected!==arrived && !module.executed;\n\t\t\t});\n\t\t\tif(!dojoRequireModuleStack.length){\n\t\t\t\tloaderVars.holdIdle();\n\t\t\t\tvar oldCallbacks = dojoRequireCallbacks;\n\t\t\t\tdojoRequireCallbacks = [];\n\t\t\t\tarray.forEach(oldCallbacks, function(cb){cb(1);});\n\t\t\t\tloaderVars.releaseIdle();\n\t\t\t}\n\t\t},\n\n\t\tdojoLoadInitPlugin = function(mid, require, loaded){\n\t\t\t// mid names a module that defines a \"dojo load init\" bundle, an object with two properties:\n\t\t\t//\n\t\t\t//   * names: a vector of module ids that give top-level names to define in the lexical scope of def\n\t\t\t//   * def: a function that contains some some legacy loader API applications\n\t\t\t//\n\t\t\t// The point of def is to possibly cause some modules to be loaded (but not executed) by dojo/require! where the module\n\t\t\t// ids are possibly-determined at runtime. For example, here is dojox.gfx from v1.6 expressed as an AMD module using the dojo/loadInit\n\t\t\t// and dojo/require plugins.\n\t\t\t//\n\t\t\t// // dojox/gfx:\n\t\t\t//\n\t\t\t//   define(\"*loadInit_12, {\n\t\t\t//     names:[\"dojo\", \"dijit\", \"dojox\"],\n\t\t\t//     def: function(){\n\t\t\t//       dojo.loadInit(function(){\n\t\t\t//         var gfx = lang.getObject(\"dojox.gfx\", true);\n\t\t\t//\n\t\t\t//         //\n\t\t\t//         // code required to set gfx properties ommitted...\n\t\t\t//         //\n\t\t\t//\n\t\t\t//         // now use the calculations to include the runtime-dependent module\n\t\t\t//         dojo.require(\"dojox.gfx.\" + gfx.renderer);\n\t\t\t//       });\n\t\t\t//\t   }\n\t\t\t//   });\n\t\t\t//\n\t\t\t//   define([\"dojo\", \"dojo/loadInit!\" + id].concat(\"dojo/require!dojox/gfx/matric,dojox/gfx/_base\"), function(dojo){\n\t\t\t//     // when this AMD factory function is executed, the following modules are guaranteed downloaded but not executed:\n\t\t\t//     //   \"dojox.gfx.\" + gfx.renderer\n\t\t\t//     //   dojox.gfx.matrix\n\t\t\t//     //   dojox.gfx._base\n\t\t\t//     dojo.provide(\"dojo.gfx\");\n\t\t\t//     dojo.require(\"dojox.gfx.matrix\");\n\t\t\t//     dojo.require(\"dojox.gfx._base\");\n\t\t\t//     dojo.require(\"dojox.gfx.\" + gfx.renderer);\n\t\t\t//     return lang.getObject(\"dojo.gfx\");\n\t\t\t//   });\n\t\t\t//  })();\n\t\t\t//\n\t\t\t// The idea is to run the legacy loader API with global variables shadowed, which allows these variables to\n\t\t\t// be relocated. For example, dojox and dojo could be relocated to different names by giving a packageMap and the code above will\n\t\t\t// execute properly (because the plugin below resolves the load init bundle.names module with respect to the module that demanded\n\t\t\t// the plugin resource).\n\t\t\t//\n\t\t\t// Note that the relocation is specified in the runtime configuration; relocated names need not be set at build-time.\n\t\t\t//\n\t\t\t// Warning: this is not the best way to express dojox.gfx as and AMD module. In fact, the module has been properly converted in\n\t\t\t// v1.7. However, this technique allows the builder to convert legacy modules into AMD modules and guarantee the codepath is the\n\t\t\t// same in the converted AMD module.\n\t\t\trequire([mid], function(bundle){\n\t\t\t\t// notice how names is resolved with respect to the module that demanded the plugin resource\n\t\t\t\trequire(bundle.names, function(){\n\t\t\t\t\t// bring the bundle names into scope\n\t\t\t\t\tfor(var scopeText = \"\", args= [], i = 0; i<arguments.length; i++){\n\t\t\t\t\t\tscopeText+= \"var \" + bundle.names[i] + \"= arguments[\" + i + \"]; \";\n\t\t\t\t\t\targs.push(arguments[i]);\n\t\t\t\t\t}\n\t\t\t\t\teval(scopeText);\n\n\t\t\t\t\tvar callingModule = require.module,\n\t\t\t\t\t\tdeps = [],\n\t\t\t\t\t\thold = {},\n\t\t\t\t\t\trequireList = [],\n\t\t\t\t\t\tp,\n\t\t\t\t\t\tsyncLoaderApi = {\n\t\t\t\t\t\t\tprovide:function(moduleName){\n\t\t\t\t\t\t\t\t// mark modules that arrive consequent to multiple provides in this module as arrived since they can't be injected\n\t\t\t\t\t\t\t\tmoduleName = slashName(moduleName);\n\t\t\t\t\t\t\t\tvar providedModule = getModule(moduleName, callingModule);\n\t\t\t\t\t\t\t\tif(providedModule!==callingModule){\n\t\t\t\t\t\t\t\t\tsetArrived(providedModule);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trequire:function(moduleName, omitModuleCheck){\n\t\t\t\t\t\t\t\tmoduleName = slashName(moduleName);\n\t\t\t\t\t\t\t\tomitModuleCheck && (getModule(moduleName, callingModule).result = nonmodule);\n\t\t\t\t\t\t\t\trequireList.push(moduleName);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trequireLocalization:function(moduleName, bundleName, locale){\n\t\t\t\t\t\t\t\t// since we're going to need dojo/i8n, add it to deps if not already there\n\t\t\t\t\t\t\t\tdeps.length || (deps = [\"dojo/i18n\"]);\n\n\t\t\t\t\t\t\t\t// figure out if the bundle is xdomain; if so, add it to the depsSet\n\t\t\t\t\t\t\t\tlocale = (locale || dojo.locale).toLowerCase();\n\t\t\t\t\t\t\t\tmoduleName = slashName(moduleName) + \"/nls/\" + (/root/i.test(locale) ? \"\" : locale + \"/\") + slashName(bundleName);\n\t\t\t\t\t\t\t\tif(getModule(moduleName, callingModule).isXd){\n\t\t\t\t\t\t\t\t\tdeps.push(\"dojo/i18n!\" + moduleName);\n\t\t\t\t\t\t\t\t}// else the bundle will be loaded synchronously when the module is evaluated\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tloadInit:function(f){\n\t\t\t\t\t\t\t\tf();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t// hijack the correct dojo and apply bundle.def\n\t\t\t\t\ttry{\n\t\t\t\t\t\tfor(p in syncLoaderApi){\n\t\t\t\t\t\t\thold[p] = dojo[p];\n\t\t\t\t\t\t\tdojo[p] = syncLoaderApi[p];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundle.def.apply(null, args);\n\t\t\t\t\t}catch(e){\n\t\t\t\t\t\tsignal(\"error\", [makeErrorToken(\"failedDojoLoadInit\"), e]);\n\t\t\t\t\t}finally{\n\t\t\t\t\t\tfor(p in syncLoaderApi){\n\t\t\t\t\t\t\tdojo[p] = hold[p];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// requireList is the list of modules that need to be downloaded but not executed before the callingModule can be executed\n\t\t\t\t\trequireList.length && deps.push(\"dojo/require!\" + requireList.join(\",\"));\n\n\t\t\t\t\tdojoRequireCallbacks.push(loaded);\n\t\t\t\t\tarray.forEach(requireList, function(mid){\n\t\t\t\t\t\tvar module = getModule(mid, require.module);\n\t\t\t\t\t\tdojoRequireModuleStack.push(module);\n\t\t\t\t\t\tinjectModule(module);\n\t\t\t\t\t});\n\t\t\t\t\tcheckDojoRequirePlugin();\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\n\t\textractApplication = function(\n\t\t\ttext,             // the text to search\n\t\t\tstartSearch,      // the position in text to start looking for the closing paren\n\t\t\tstartApplication  // the position in text where the function application expression starts\n\t\t){\n\t\t\t// find end of the call by finding the matching end paren\n\t\t\t// Warning: as usual, this will fail in the presense of unmatched right parans contained in strings, regexs, or unremoved comments\n\t\t\tvar parenRe = /\\(|\\)/g,\n\t\t\t\tmatchCount = 1,\n\t\t\t\tmatch;\n\t\t\tparenRe.lastIndex = startSearch;\n\t\t\twhile((match = parenRe.exec(text))){\n\t\t\t\tif(match[0] == \")\"){\n\t\t\t\t\tmatchCount -= 1;\n\t\t\t\t}else{\n\t\t\t\t\tmatchCount += 1;\n\t\t\t\t}\n\t\t\t\tif(matchCount == 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(matchCount != 0){\n\t\t\t\tthrow \"unmatched paren around character \" + parenRe.lastIndex + \" in: \" + text;\n\t\t\t}\n\n\t\t\t//Put the master matching string in the results.\n\t\t\treturn [dojo.trim(text.substring(startApplication, parenRe.lastIndex))+\";\\n\", parenRe.lastIndex];\n\t\t},\n\n\t\t// the following regex is taken from 1.6. It is a very poor technique to remove comments and\n\t\t// will fail in some cases; for example, consider the code...\n\t\t//\n\t\t//    var message = \"Category-1 */* Category-2\";\n\t\t//\n\t\t// The regex that follows will see a /* comment and trash the code accordingly. In fact, there are all\n\t\t// kinds of cases like this with strings and regexs that will cause this design to fail miserably.\n\t\t//\n\t\t// Alternative regex designs exist that will result in less-likely failures, but will still fail in many cases.\n\t\t// The only solution guaranteed 100% correct is to parse the code and that seems overkill for this\n\t\t// backcompat/unbuilt-xdomain layer. In the end, since it's been this way for a while, we won't change it.\n\t\t// See the opening paragraphs of Chapter 7 or ECME-262 which describes the lexical abiguity further.\n\t\tremoveCommentRe = /(\\/\\*([\\s\\S]*?)\\*\\/|\\/\\/(.*)$)/mg,\n\n\t\tsyncLoaderApiRe = /(^|\\s)dojo\\.(loadInit|require|provide|requireLocalization|requireIf|requireAfterIf|platformRequire)\\s*\\(/mg,\n\n\t\tamdLoaderApiRe = /(^|\\s)(require|define)\\s*\\(/m,\n\n\t\textractLegacyApiApplications = function(text, noCommentText){\n\t\t\t// scan the noCommentText for any legacy loader API applications. Copy such applications into result (this is\n\t\t\t// used by the builder). Move dojo.loadInit applications to loadInitApplications string. Copy all other applications\n\t\t\t// to otherApplications string. If no applications were found, return 0, signalling an AMD module. Otherwise, return\n\t\t\t// loadInitApplications + otherApplications. Fixup text by replacing\n\t\t\t//\n\t\t\t//   dojo.loadInit(// etc...\n\t\t\t//\n\t\t\t// with\n\t\t\t//\n\t\t\t//   \\n 0 && dojo.loadInit(// etc...\n\t\t\t//\n\t\t\t// Which results in the dojo.loadInit from *not* being applied. This design goes a long way towards protecting the\n\t\t\t// code from an over-agressive removeCommentRe. However...\n\t\t\t//\n\t\t\t// WARNING: the removeCommentRe will cause an error if a detected comment removes all or part of a legacy-loader application\n\t\t\t// that is not in a comment.\n\n\t\t\tvar match, startSearch, startApplication, application,\n\t\t\t\tloadInitApplications = [],\n\t\t\t\totherApplications = [],\n\t\t\t\tallApplications = [];\n\n\t\t\t// noCommentText may be provided by a build app with comments extracted by a better method than regex (hopefully)\n\t\t\tnoCommentText = noCommentText || text.replace(removeCommentRe, function(match){\n\t\t\t\t// remove iff the detected comment has text that looks like a sync loader API application; this helps by\n\t\t\t\t// removing as little as possible, minimizing the changes the janky regex will kill the module\n\t\t\t\tsyncLoaderApiRe.lastIndex = amdLoaderApiRe.lastIndex = 0;\n\t\t\t\treturn (syncLoaderApiRe.test(match) || amdLoaderApiRe.test(match)) ? \"\" : match;\n\t\t\t});\n\n\t\t\t// find and extract all dojo.loadInit applications\n\t\t\twhile((match = syncLoaderApiRe.exec(noCommentText))){\n\t\t\t\tstartSearch = syncLoaderApiRe.lastIndex;\n\t\t\t\tstartApplication = startSearch  - match[0].length;\n\t\t\t\tapplication = extractApplication(noCommentText, startSearch, startApplication);\n\t\t\t\tif(match[2]==\"loadInit\"){\n\t\t\t\t\tloadInitApplications.push(application[0]);\n\t\t\t\t}else{\n\t\t\t\t\totherApplications.push(application[0]);\n\t\t\t\t}\n\t\t\t\tsyncLoaderApiRe.lastIndex = application[1];\n\t\t\t}\n\t\t\tallApplications = loadInitApplications.concat(otherApplications);\n\t\t\tif(allApplications.length || !amdLoaderApiRe.test(noCommentText)){\n\t\t\t\t// either there were some legacy loader API applications or there were no AMD API applications\n\t\t\t\treturn [text.replace(/(^|\\s)dojo\\.loadInit\\s*\\(/g, \"\\n0 && dojo.loadInit(\"), allApplications.join(\"\"), allApplications];\n\t\t\t}else{\n\t\t\t\t// legacy loader API *was not* detected and AMD API *was* detected; therefore, assume it's an AMD module\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t},\n\n\t\ttransformToAmd = function(module, text){\n\t\t\t// This is roughly the equivalent of dojo._xdCreateResource in 1.6-; however, it expresses a v1.6- dojo\n\t\t\t// module in terms of AMD define instead of creating the dojo proprietary xdomain module expression.\n\t\t\t// The module could have originated from several sources:\n\t\t\t//\n\t\t\t//   * amd require() a module, e.g., require([\"my/module\"])\n\t\t\t//   * amd require() a nonmodule, e.g., require([\"my/resource.js\"')\n\t\t\t//   * amd define() deps vector (always a module)\n\t\t\t//   * dojo.require() a module, e.g. dojo.require(\"my.module\")\n\t\t\t//   * dojo.require() a nonmodule, e.g., dojo.require(\"my.module\", true)\n\t\t\t//   * dojo.requireIf/requireAfterIf/platformRequire a module\n\t\t\t//\n\t\t\t// The module is scanned for legacy loader API applications; if none are found, then assume the module is an\n\t\t\t// AMD module and return 0. Otherwise, a synthetic dojo/loadInit plugin resource is created and the module text\n\t\t\t// is rewritten as an AMD module with the single dependency of this synthetic resource. When the dojo/loadInit\n\t\t\t// plugin loaded the synthetic resource, it will cause all dojo.loadInit's to be executed, find all dojo.require's\n\t\t\t// (either directly consequent to dojo.require or indirectly consequent to dojo.require[After]If or\n\t\t\t// dojo.platformRequire, and finally cause loading of all dojo.required modules with the dojo/require plugin. Thus,\n\t\t\t// when the dojo/loadInit plugin reports it has been loaded, all modules required by the given module are guaranteed\n\t\t\t// loaded (but not executed). This then allows the module to execute it's code path without interupts, thereby\n\t\t\t// following the synchronous code path.\n\n\t\t\tvar extractResult, id, names = [], namesAsStrings = [];\n\t\t\tif(buildDetectRe.test(text) || !(extractResult = extractLegacyApiApplications(text))){\n\t\t\t\t// buildDetectRe.test(text) => a built module, always AMD\n\t\t\t\t// extractResult==0 => no sync API\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t// manufacture a synthetic module id that can never be a real mdule id (just like require does)\n\t\t\tid = module.mid + \"-*loadInit\";\n\n\t\t\t// construct the dojo/loadInit names vector which causes any relocated names to be defined as lexical variables under their not-relocated name\n\t\t\t// the dojo/loadInit plugin assumes the first name in names is \"dojo\"\n\n\t\t\tfor(var p in getModule(\"dojo\", module).result.scopeMap){\n\t\t\t\tnames.push(p);\n\t\t\t\tnamesAsStrings.push('\"' + p + '\"');\n\t\t\t}\n\n\t\t\t// rewrite the module as a synthetic dojo/loadInit plugin resource + the module expressed as an AMD module that depends on this synthetic resource\n\t\t\treturn \"// xdomain rewrite of \" + module.path + \"\\n\" +\n\t\t\t\t\"define('\" + id + \"',{\\n\" +\n\t\t\t\t\"\\tnames:\" + dojo.toJson(names) + \",\\n\" +\n\t\t\t\t\"\\tdef:function(\" + names.join(\",\") + \"){\" + extractResult[1] + \"}\" +\n\t\t\t\t\"});\\n\\n\" +\n\t\t\t    \"define(\" + dojo.toJson(names.concat([\"dojo/loadInit!\"+id])) + \", function(\" + names.join(\",\") + \"){\\n\" + extractResult[0] + \"});\";\n\t\t},\n\n\t\tloaderVars = require.initSyncLoader(dojoRequirePlugin, checkDojoRequirePlugin, transformToAmd),\n\n\t\tsync =\n\t\t\tloaderVars.sync,\n\n\t\txd =\n\t\t\tloaderVars.xd,\n\n\t\tarrived =\n\t\t\tloaderVars.arrived,\n\n\t\tnonmodule =\n\t\t\tloaderVars.nonmodule,\n\n\t\texecuting =\n\t\t\tloaderVars.executing,\n\n\t\texecuted =\n\t\t\tloaderVars.executed,\n\n\t\tsyncExecStack =\n\t\t\tloaderVars.syncExecStack,\n\n\t\tmodules =\n\t\t\tloaderVars.modules,\n\n\t\texecQ =\n\t\t\tloaderVars.execQ,\n\n\t\tgetModule =\n\t\t\tloaderVars.getModule,\n\n\t\tinjectModule =\n\t\t\tloaderVars.injectModule,\n\n\t\tsetArrived =\n\t\t\tloaderVars.setArrived,\n\n\t\tsignal =\n\t\t\tloaderVars.signal,\n\n\t\tfinishExec =\n\t\t\tloaderVars.finishExec,\n\n\t\texecModule =\n\t\t\tloaderVars.execModule,\n\n\t\tgetLegacyMode =\n\t\t\tloaderVars.getLegacyMode;\n\n\tdojo.provide = function(mid){\n\t\tvar executingModule = syncExecStack[0],\n\t\t\tmodule = lang.mixin(getModule(slashName(mid), require.module), {\n\t\t\t\texecuted:executing,\n\t\t\t\tresult:lang.getObject(mid, true)\n\t\t\t});\n\t\tsetArrived(module);\n\t\tif(executingModule){\n\t\t\t(executingModule.provides || (executingModule.provides = [])).push(function(){\n\t\t\t\tmodule.result = lang.getObject(mid);\n\t\t\t\tdelete module.provides;\n\t\t\t\tmodule.executed!==executed && finishExec(module);\n\t\t\t});\n\t\t}// else dojo.provide called not consequent to loading; therefore, give up trying to publish module value to loader namespace\n\t\treturn module.result;\n\t};\n\n\thas.add(\"config-publishRequireResult\", 1, 0, 0);\n\n\tdojo.require = function(moduleName, omitModuleCheck) {\n\t\t//\tsummary:\n\t\t//\t\tloads a Javascript module from the appropriate URI\n\t\t//\n\t\t//\tmoduleName: String\n\t\t//\t\tmodule name to load, using periods for separators,\n\t\t//\t\t e.g. \"dojo.date.locale\".  Module paths are de-referenced by dojo's\n\t\t//\t\tinternal mapping of locations to names and are disambiguated by\n\t\t//\t\tlongest prefix. See `dojo.registerModulePath()` for details on\n\t\t//\t\tregistering new modules.\n\t\t//\n\t\t//\tomitModuleCheck: Boolean?\n\t\t//\t\tif `true`, omitModuleCheck skips the step of ensuring that the\n\t\t//\t\tloaded file actually defines the symbol it is referenced by.\n\t\t//\t\tFor example if it called as `dojo.require(\"a.b.c\")` and the\n\t\t//\t\tfile located at `a/b/c.js` does not define an object `a.b.c`,\n\t\t//\t\tand exception will be throws whereas no exception is raised\n\t\t//\t\twhen called as `dojo.require(\"a.b.c\", true)`\n\t\t//\n\t\t//\tdescription:\n\t\t// \t\tModules are loaded via dojo.require by using one of two loaders: the normal loader\n\t\t// \t\tand the xdomain loader. The xdomain loader is used when dojo was built with a\n\t\t// \t\tcustom build that specified loader=xdomain and the module lives on a modulePath\n\t\t// \t\tthat is a whole URL, with protocol and a domain. The versions of Dojo that are on\n\t\t// \t\tthe Google and AOL CDNs use the xdomain loader.\n\t\t//\n\t\t// \t\tIf the module is loaded via the xdomain loader, it is an asynchronous load, since\n\t\t// \t\tthe module is added via a dynamically created script tag. This\n\t\t// \t\tmeans that dojo.require() can return before the module has loaded. However, this\n\t\t// \t\tshould only happen in the case where you do dojo.require calls in the top-level\n\t\t// \t\tHTML page, or if you purposely avoid the loader checking for dojo.require\n\t\t// \t\tdependencies in your module by using a syntax like dojo[\"require\"] to load the module.\n\t\t//\n\t\t// \t\tSometimes it is useful to not have the loader detect the dojo.require calls in the\n\t\t// \t\tmodule so that you can dynamically load the modules as a result of an action on the\n\t\t// \t\tpage, instead of right at module load time.\n\t\t//\n\t\t// \t\tAlso, for script blocks in an HTML page, the loader does not pre-process them, so\n\t\t// \t\tit does not know to download the modules before the dojo.require calls occur.\n\t\t//\n\t\t// \t\tSo, in those two cases, when you want on-the-fly module loading or for script blocks\n\t\t// \t\tin the HTML page, special care must be taken if the dojo.required code is loaded\n\t\t// \t\tasynchronously. To make sure you can execute code that depends on the dojo.required\n\t\t// \t\tmodules, be sure to add the code that depends on the modules in a dojo.addOnLoad()\n\t\t// \t\tcallback. dojo.addOnLoad waits for all outstanding modules to finish loading before\n\t\t// \t\texecuting.\n\t\t//\n\t\t// \t\tThis type of syntax works with both xdomain and normal loaders, so it is good\n\t\t// \t\tpractice to always use this idiom for on-the-fly code loading and in HTML script\n\t\t// \t\tblocks. If at some point you change loaders and where the code is loaded from,\n\t\t// \t\tit will all still work.\n\t\t//\n\t\t// \t\tMore on how dojo.require\n\t\t//\t\t`dojo.require(\"A.B\")` first checks to see if symbol A.B is\n\t\t//\t\tdefined. If it is, it is simply returned (nothing to do).\n\t\t//\n\t\t//\t\tIf it is not defined, it will look for `A/B.js` in the script root\n\t\t//\t\tdirectory.\n\t\t//\n\t\t//\t\t`dojo.require` throws an exception if it cannot find a file\n\t\t//\t\tto load, or if the symbol `A.B` is not defined after loading.\n\t\t//\n\t\t//\t\tIt returns the object `A.B`, but note the caveats above about on-the-fly loading and\n\t\t// \t\tHTML script blocks when the xdomain loader is loading a module.\n\t\t//\n\t\t//\t\t`dojo.require()` does nothing about importing symbols into\n\t\t//\t\tthe current namespace.  It is presumed that the caller will\n\t\t//\t\ttake care of that.\n\t\t//\n\t\t// \texample:\n\t\t// \t\tTo use dojo.require in conjunction with dojo.ready:\n\t\t//\n\t\t//\t\t|\tdojo.require(\"foo\");\n\t\t//\t\t|\tdojo.require(\"bar\");\n\t\t//\t   \t|\tdojo.addOnLoad(function(){\n\t\t//\t   \t|\t\t//you can now safely do something with foo and bar\n\t\t//\t   \t|\t});\n\t\t//\n\t\t//\texample:\n\t\t//\t\tFor example, to import all symbols into a local block, you might write:\n\t\t//\n\t\t//\t\t|\twith (dojo.require(\"A.B\")) {\n\t\t//\t\t|\t\t...\n\t\t//\t\t|\t}\n\t\t//\n\t\t//\t\tAnd to import just the leaf symbol to a local variable:\n\t\t//\n\t\t//\t\t|\tvar B = dojo.require(\"A.B\");\n\t\t//\t   \t|\t...\n\t\t//\n\t\t//\treturns:\n\t\t//\t\tthe required namespace object\n\t\tfunction doRequire(mid, omitModuleCheck){\n\t\t\tvar module = getModule(slashName(mid), require.module);\n\t\t\tif(syncExecStack.length && syncExecStack[0].finish){\n\t\t\t\t// switched to async loading in the middle of evaluating a legacy module; stop\n\t\t\t\t// applying dojo.require so the remaining dojo.requires are applied in order\n\t\t\t\tsyncExecStack[0].finish.push(mid);\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\t// recall module.executed has values {0, executing, executed}; therefore, truthy indicates executing or executed\n\t\t\tif(module.executed){\n\t\t\t\treturn module.result;\n\t\t\t}\n\t\t\tomitModuleCheck && (module.result = nonmodule);\n\n\t\t\tvar currentMode = getLegacyMode();\n\n\t\t\t// recall, in sync mode to inject is to *eval* the module text\n\t\t\t// if the module is a legacy module, this is the same as executing\n\t\t\t// but if the module is an AMD module, this means defining, not executing\n\t\t\tinjectModule(module);\n\t\t\t// the inject may have changed the mode\n\t\t\tcurrentMode = getLegacyMode();\n\n\t\t\t// in sync mode to dojo.require is to execute\n\t\t\tif(module.executed!==executed && module.injected===arrived){\n\t\t\t\t// the module was already here before injectModule was called probably finishing up a xdomain\n\t\t\t\t// load, but maybe a module given to the loader directly rather than having the loader retrieve it\n\t\t\t\tloaderVars.holdIdle();\n\t\t\t\texecModule(module);\n\t\t\t\tloaderVars.releaseIdle();\n\t\t\t}\n\t\t\tif(module.executed){\n\t\t\t\treturn module.result;\n\t\t\t}\n\n\t\t\tif(currentMode==sync){\n\t\t\t\t// the only way to get here is in sync mode and dojo.required a module that\n\t\t\t\t//   * was loaded async in the injectModule application a few lines up\n\t\t\t\t//   * was an AMD module that had deps that are being loaded async and therefore couldn't execute\n\t\t\t\tif(module.cjs){\n\t\t\t\t\t// the module was an AMD module; unshift, not push, which causes the current traversal to be reattempted from the top\n\t\t\t\t\texecQ.unshift(module);\n\t\t\t\t}else{\n\t\t\t\t\t// the module was a legacy module\n\t\t\t\t\tsyncExecStack.length && (syncExecStack[0].finish= [mid]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// the loader wasn't in sync mode on entry; probably async mode; therefore, no expectation of getting\n\t\t\t\t// the module value synchronously; make sure it gets executed though\n\t\t\t\texecQ.push(module);\n\t\t\t}\n\t\t\treturn undefined;\n\t\t}\n\n\t\tvar result = doRequire(moduleName, omitModuleCheck);\n\t\tif(has(\"config-publishRequireResult\") && !lang.exists(moduleName) && result!==undefined){\n\t\t\tlang.setObject(moduleName, result);\n\t\t}\n\t\treturn result;\n\t};\n\n\tdojo.loadInit = function(f) {\n\t\tf();\n\t};\n\n\tdojo.registerModulePath = function(/*String*/moduleName, /*String*/prefix){\n\t\t//\tsummary:\n\t\t//\t\tMaps a module name to a path\n\t\t//\tdescription:\n\t\t//\t\tAn unregistered module is given the default path of ../[module],\n\t\t//\t\trelative to Dojo root. For example, module acme is mapped to\n\t\t//\t\t../acme.  If you want to use a different module name, use\n\t\t//\t\tdojo.registerModulePath.\n\t\t//\texample:\n\t\t//\t\tIf your dojo.js is located at this location in the web root:\n\t\t//\t|\t/myapp/js/dojo/dojo/dojo.js\n\t\t//\t\tand your modules are located at:\n\t\t//\t|\t/myapp/js/foo/bar.js\n\t\t//\t|\t/myapp/js/foo/baz.js\n\t\t//\t|\t/myapp/js/foo/thud/xyzzy.js\n\t\t//\t\tYour application can tell Dojo to locate the \"foo\" namespace by calling:\n\t\t//\t|\tdojo.registerModulePath(\"foo\", \"../../foo\");\n\t\t//\t\tAt which point you can then use dojo.require() to load the\n\t\t//\t\tmodules (assuming they provide() the same things which are\n\t\t//\t\trequired). The full code might be:\n\t\t//\t|\t<script type=\"text/javascript\"\n\t\t//\t|\t\tsrc=\"/myapp/js/dojo/dojo/dojo.js\"></script>\n\t\t//\t|\t<script type=\"text/javascript\">\n\t\t//\t|\t\tdojo.registerModulePath(\"foo\", \"../../foo\");\n\t\t//\t|\t\tdojo.require(\"foo.bar\");\n\t\t//\t|\t\tdojo.require(\"foo.baz\");\n\t\t//\t|\t\tdojo.require(\"foo.thud.xyzzy\");\n\t\t//\t|\t</script>\n\n\t\tvar paths = {};\n\t\tpaths[moduleName.replace(/\\./g, \"/\")] = prefix;\n\t\trequire({paths:paths});\n\t};\n\n\tdojo.platformRequire = function(/*Object*/modMap){\n\t\t//\tsummary:\n\t\t//\t\trequire one or more modules based on which host environment\n\t\t//\t\tDojo is currently operating in\n\t\t//\tdescription:\n\t\t//\t\tThis method takes a \"map\" of arrays which one can use to\n\t\t//\t\toptionally load dojo modules. The map is indexed by the\n\t\t//\t\tpossible dojo.name_ values, with two additional values:\n\t\t//\t\t\"default\" and \"common\". The items in the \"default\" array will\n\t\t//\t\tbe loaded if none of the other items have been choosen based on\n\t\t//\t\tdojo.name_, set by your host environment. The items in the\n\t\t//\t\t\"common\" array will *always* be loaded, regardless of which\n\t\t//\t\tlist is chosen.\n\t\t//\texample:\n \t\t//\t\t|\tdojo.platformRequire({\n\t\t//\t\t|\t\tbrowser: [\n\t\t//\t\t|\t\t\t\"foo.sample\", // simple module\n\t\t//\t\t|\t\t\t\"foo.test\",\n\t\t//\t\t|\t\t\t[\"foo.bar.baz\", true] // skip object check in _loadModule (dojo.require)\n\t\t//\t\t|\t\t],\n\t\t//\t\t|\t\tdefault: [ \"foo.sample._base\" ],\n\t\t//\t\t|\t\tcommon: [ \"important.module.common\" ]\n\t\t//\t\t|\t});\n\n\t\tvar result = (modMap.common || []).concat(modMap[dojo._name] || modMap[\"default\"] || []),\n\t\t\ttemp;\n\t\twhile(result.length){\n\t\t\tif(lang.isArray(temp = result.shift())){\n\t\t\t\tdojo.require.apply(dojo, temp);\n\t\t\t}else{\n\t\t\t\tdojo.require(temp);\n\t\t\t}\n\t\t}\n\t};\n\n\tdojo.requireIf = dojo.requireAfterIf = function(/*Boolean*/ condition, /*String*/ moduleName, /*Boolean?*/omitModuleCheck){\n\t\t// summary:\n\t\t//\t\tIf the condition is true then call `dojo.require()` for the specified\n\t\t//\t\tresource\n\t\t//\n\t\t// example:\n\t\t//\t|\tdojo.requireIf(dojo.isBrowser, \"my.special.Module\");\n\n\t\tif(condition){\n\t\t\tdojo.require(moduleName, omitModuleCheck);\n\t\t}\n\t};\n\n\tdojo.requireLocalization = function(/*String*/moduleName, /*String*/bundleName, /*String?*/locale){\n\t\trequire([\"../i18n\"], function(i18n){\n\t\t\ti18n.getLocalization(moduleName, bundleName, locale);\n\t\t});\n\t};\n\n\treturn {\n\t\textractLegacyApiApplications:extractLegacyApiApplications,\n\t\trequire:loaderVars.dojoRequirePlugin,\n\t\tloadInit:dojoLoadInitPlugin\n\t};\n});\n\n},\n'dojo/json':function(){\ndefine([\"./has\"], function(has){\n\t\"use strict\";\n\tvar hasJSON = typeof JSON != \"undefined\";\n\thas.add(\"json-parse\", hasJSON); // all the parsers work fine\n\t\t// Firefox 3.5/Gecko 1.9 fails to use replacer in stringify properly https://bugzilla.mozilla.org/show_bug.cgi?id=509184\n\thas.add(\"json-stringify\", hasJSON && JSON.stringify({a:0}, function(k,v){return v||1;}) == '{\"a\":1}'); \n\tif(has(\"json-stringify\")){\n\t\treturn JSON;\n\t}\n\telse{\n\t\tvar escapeString = function(/*String*/str){\n\t\t\t//summary:\n\t\t\t//\t\tAdds escape sequences for non-visual characters, double quote and\n\t\t\t//\t\tbackslash and surrounds with double quotes to form a valid string\n\t\t\t//\t\tliteral.\n\t\t\treturn ('\"' + str.replace(/([\"\\\\])/g, '\\\\$1') + '\"').\n\t\t\t\treplace(/[\\f]/g, \"\\\\f\").replace(/[\\b]/g, \"\\\\b\").replace(/[\\n]/g, \"\\\\n\").\n\t\t\t\treplace(/[\\t]/g, \"\\\\t\").replace(/[\\r]/g, \"\\\\r\"); // string\n\t\t};\n\t\treturn {\n\t\t\tparse: has(\"json-parse\") ? JSON.parse : function(str, strict){\n\t\t\t\t// summary:\n\t\t\t\t// \t\tParses a [JSON](http://json.org) string to return a JavaScript object.\n\t\t\t\t// description:\n\t\t\t\t//\t\tThis function follows [native JSON API](https://developer.mozilla.org/en/JSON)\n\t\t\t\t// \t\tThrows for invalid JSON strings. This delegates to eval() if native JSON\n\t\t\t\t// \t\tsupport is not available. By default this will evaluate any valid JS expression.\n\t\t\t\t//\t\tWith the strict parameter set to true, the parser will ensure that only\n\t\t\t\t//\t\tvalid JSON strings are parsed (otherwise throwing an error). Without the strict\n\t\t\t\t// \t\tparameter, the content passed to this method must come\n\t\t\t\t//\t\tfrom a trusted source.\n\t\t\t\t// str:\n\t\t\t\t//\t\ta string literal of a JSON item, for instance:\n\t\t\t\t//\t\t\t`'{ \"foo\": [ \"bar\", 1, { \"baz\": \"thud\" } ] }'`\n\t\t\t\t//\tstrict: \n\t\t\t\t//\t\tWhen set to true, this will ensure that only valid, secure JSON is ever parsed.\n\t\t\t\t// \t\tMake sure this is set to true for untrusted content. Note that on browsers/engines\n\t\t\t\t//\t\twithout native JSON support, setting this to true will run slower.\n\t\t\t\tif(strict && !/^([\\s\\[\\{]*(?:\"(?:\\\\.|[^\"])+\"|-?\\d[\\d\\.]*(?:[Ee][+-]?\\d+)?|null|true|false|)[\\s\\]\\}]*(?:,|:|$))+$/.test(str)){\n\t\t\t\t\tthrow new SyntaxError(\"Invalid characters in JSON\");\n\t\t\t\t}\n\t\t\t\treturn eval('(' + str + ')');\n\t\t\t},\n\t\t\tstringify: function(value, replacer, spacer){\n\t\t\t\t//\tsummary:\n\t\t\t\t//\t\tReturns a [JSON](http://json.org) serialization of an object.\n\t\t\t\t//\tdescription:\n\t\t\t\t//\t\tReturns a [JSON](http://json.org) serialization of an object.\n\t\t\t\t//\t\tThis function follows [native JSON API](https://developer.mozilla.org/en/JSON)\n\t\t\t\t//\t\tNote that this doesn't check for infinite recursion, so don't do that!\n\t\t\t\t//\tvalue:\n\t\t\t\t//\t\tA value to be serialized. \n\t\t\t\t//\treplacer:\n\t\t\t\t//\t\tA replacer function that is called for each value and can return a replacement\n\t\t\t\t//\tspacer:\n\t\t\t\t//\t\tA spacer string to be used for pretty printing of JSON\n\t\t\t\t//\t\t\n\t\t\t\t//\texample:\n\t\t\t\t//\t\tsimple serialization of a trivial object\n\t\t\t\t//\t\t|\tdefine([\"dojo/json\"], function(JSON){\n\t\t\t\t// \t\t|\t\tvar jsonStr = JSON.stringify({ howdy: \"stranger!\", isStrange: true });\n\t\t\t\t//\t\t|\t\tdoh.is('{\"howdy\":\"stranger!\",\"isStrange\":true}', jsonStr);\n\t\t\t\tvar undef;\n\t\t\t\tif(typeof replacer == \"string\"){\n\t\t\t\t\tspacer = replacer;\n\t\t\t\t\treplacer = null;\n\t\t\t\t}\n\t\t\t\tfunction stringify(it, indent, key){\n\t\t\t\t\tif(replacer){\n\t\t\t\t\t\tit = replacer(key, it);\n\t\t\t\t\t}\n\t\t\t\t\tvar val, objtype = typeof it;\n\t\t\t\t\tif(objtype == \"number\"){\n\t\t\t\t\t\treturn isFinite(it) ? it + \"\" : \"null\";\n\t\t\t\t\t}\n\t\t\t\t\tif(objtype == \"boolean\"){\n\t\t\t\t\t\treturn it + \"\";\n\t\t\t\t\t}\n\t\t\t\t\tif(it === null){\n\t\t\t\t\t\treturn \"null\";\n\t\t\t\t\t}\n\t\t\t\t\tif(typeof it == \"string\"){\n\t\t\t\t\t\treturn escapeString(it);\n\t\t\t\t\t}\n\t\t\t\t\tif(objtype == \"function\" || objtype == \"undefined\"){\n\t\t\t\t\t\treturn undef; // undefined\n\t\t\t\t\t}\n\t\t\t\t\t// short-circuit for objects that support \"json\" serialization\n\t\t\t\t\t// if they return \"self\" then just pass-through...\n\t\t\t\t\tif(typeof it.toJSON == \"function\"){\n\t\t\t\t\t\treturn stringify(it.toJSON(key), indent, key);\n\t\t\t\t\t}\n\t\t\t\t\tif(it instanceof Date){\n\t\t\t\t\t\treturn '\"{FullYear}-{Month+}-{Date}T{Hours}:{Minutes}:{Seconds}Z\"'.replace(/\\{(\\w+)(\\+)?\\}/g, function(t, prop, plus){\n\t\t\t\t\t\t\tvar num = it[\"getUTC\" + prop]() + (plus ? 1 : 0);\n\t\t\t\t\t\t\treturn num < 10 ? \"0\" + num : num;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif(it.valueOf() !== it){\n\t\t\t\t\t\t// primitive wrapper, try again unwrapped:\n\t\t\t\t\t\treturn stringify(it.valueOf(), indent, key);\n\t\t\t\t\t}\n\t\t\t\t\tvar nextIndent= spacer ? (indent + spacer) : \"\";\n\t\t\t\t\t/* we used to test for DOM nodes and throw, but FF serializes them as {}, so cross-browser consistency is probably not efficiently attainable */ \n\t\t\t\t\n\t\t\t\t\tvar sep = spacer ? \" \" : \"\";\n\t\t\t\t\tvar newLine = spacer ? \"\\n\" : \"\";\n\t\t\t\t\n\t\t\t\t\t// array\n\t\t\t\t\tif(it instanceof Array){\n\t\t\t\t\t\tvar itl = it.length, res = [];\n\t\t\t\t\t\tfor(key = 0; key < itl; key++){\n\t\t\t\t\t\t\tvar obj = it[key];\n\t\t\t\t\t\t\tval = stringify(obj, nextIndent, key);\n\t\t\t\t\t\t\tif(typeof val != \"string\"){\n\t\t\t\t\t\t\t\tval = \"null\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tres.push(newLine + nextIndent + val);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn \"[\" + res.join(\",\") + newLine + indent + \"]\";\n\t\t\t\t\t}\n\t\t\t\t\t// generic object code path\n\t\t\t\t\tvar output = [];\n\t\t\t\t\tfor(key in it){\n\t\t\t\t\t\tvar keyStr;\n\t\t\t\t\t\tif(typeof key == \"number\"){\n\t\t\t\t\t\t\tkeyStr = '\"' + key + '\"';\n\t\t\t\t\t\t}else if(typeof key == \"string\"){\n\t\t\t\t\t\t\tkeyStr = escapeString(key);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t// skip non-string or number keys\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tval = stringify(it[key], nextIndent, key);\n\t\t\t\t\t\tif(typeof val != \"string\"){\n\t\t\t\t\t\t\t// skip non-serializable values\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// At this point, the most non-IE browsers don't get in this branch \n\t\t\t\t\t\t// (they have native JSON), so push is definitely the way to\n\t\t\t\t\t\toutput.push(newLine + nextIndent + keyStr + \":\" + sep + val);\n\t\t\t\t\t}\n\t\t\t\t\treturn \"{\" + output.join(\",\") + newLine + indent + \"}\"; // String\n\t\t\t\t}\n\t\t\t\treturn stringify(value, \"\", \"\");\n\t\t\t}\n\t\t};\n\t}\n});\n\n},\n'dojo/_base/declare':function(){\ndefine([\"./kernel\", \"../has\", \"./lang\"], function(dojo, has, lang){\n\t// module:\n\t//\t\tdojo/_base/declare\n\t// summary:\n\t//\t\tThis module defines dojo.declare.\n\n\tvar mix = lang.mixin, op = Object.prototype, opts = op.toString,\n\t\txtor = new Function, counter = 0, cname = \"constructor\";\n\n\tfunction err(msg, cls){ throw new Error(\"declare\" + (cls ? \" \" + cls : \"\") + \": \" + msg); }\n\n\t// C3 Method Resolution Order (see http://www.python.org/download/releases/2.3/mro/)\n\tfunction c3mro(bases, className){\n\t\tvar result = [], roots = [{cls: 0, refs: []}], nameMap = {}, clsCount = 1,\n\t\t\tl = bases.length, i = 0, j, lin, base, top, proto, rec, name, refs;\n\n\t\t// build a list of bases naming them if needed\n\t\tfor(; i < l; ++i){\n\t\t\tbase = bases[i];\n\t\t\tif(!base){\n\t\t\t\terr(\"mixin #\" + i + \" is unknown. Did you use dojo.require to pull it in?\", className);\n\t\t\t}else if(opts.call(base) != \"[object Function]\"){\n\t\t\t\terr(\"mixin #\" + i + \" is not a callable constructor.\", className);\n\t\t\t}\n\t\t\tlin = base._meta ? base._meta.bases : [base];\n\t\t\ttop = 0;\n\t\t\t// add bases to the name map\n\t\t\tfor(j = lin.length - 1; j >= 0; --j){\n\t\t\t\tproto = lin[j].prototype;\n\t\t\t\tif(!proto.hasOwnProperty(\"declaredClass\")){\n\t\t\t\t\tproto.declaredClass = \"uniqName_\" + (counter++);\n\t\t\t\t}\n\t\t\t\tname = proto.declaredClass;\n\t\t\t\tif(!nameMap.hasOwnProperty(name)){\n\t\t\t\t\tnameMap[name] = {count: 0, refs: [], cls: lin[j]};\n\t\t\t\t\t++clsCount;\n\t\t\t\t}\n\t\t\t\trec = nameMap[name];\n\t\t\t\tif(top && top !== rec){\n\t\t\t\t\trec.refs.push(top);\n\t\t\t\t\t++top.count;\n\t\t\t\t}\n\t\t\t\ttop = rec;\n\t\t\t}\n\t\t\t++top.count;\n\t\t\troots[0].refs.push(top);\n\t\t}\n\n\t\t// remove classes without external references recursively\n\t\twhile(roots.length){\n\t\t\ttop = roots.pop();\n\t\t\tresult.push(top.cls);\n\t\t\t--clsCount;\n\t\t\t// optimization: follow a single-linked chain\n\t\t\twhile(refs = top.refs, refs.length == 1){\n\t\t\t\ttop = refs[0];\n\t\t\t\tif(!top || --top.count){\n\t\t\t\t\t// branch or end of chain => do not end to roots\n\t\t\t\t\ttop = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tresult.push(top.cls);\n\t\t\t\t--clsCount;\n\t\t\t}\n\t\t\tif(top){\n\t\t\t\t// branch\n\t\t\t\tfor(i = 0, l = refs.length; i < l; ++i){\n\t\t\t\t\ttop = refs[i];\n\t\t\t\t\tif(!--top.count){\n\t\t\t\t\t\troots.push(top);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(clsCount){\n\t\t\terr(\"can't build consistent linearization\", className);\n\t\t}\n\n\t\t// calculate the superclass offset\n\t\tbase = bases[0];\n\t\tresult[0] = base ?\n\t\t\tbase._meta && base === result[result.length - base._meta.bases.length] ?\n\t\t\t\tbase._meta.bases.length : 1 : 0;\n\n\t\treturn result;\n\t}\n\n\tfunction inherited(args, a, f){\n\t\tvar name, chains, bases, caller, meta, base, proto, opf, pos,\n\t\t\tcache = this._inherited = this._inherited || {};\n\n\t\t// crack arguments\n\t\tif(typeof args == \"string\"){\n\t\t\tname = args;\n\t\t\targs = a;\n\t\t\ta = f;\n\t\t}\n\t\tf = 0;\n\n\t\tcaller = args.callee;\n\t\tname = name || caller.nom;\n\t\tif(!name){\n\t\t\terr(\"can't deduce a name to call inherited()\", this.declaredClass);\n\t\t}\n\n\t\tmeta = this.constructor._meta;\n\t\tbases = meta.bases;\n\n\t\tpos = cache.p;\n\t\tif(name != cname){\n\t\t\t// method\n\t\t\tif(cache.c !== caller){\n\t\t\t\t// cache bust\n\t\t\t\tpos = 0;\n\t\t\t\tbase = bases[0];\n\t\t\t\tmeta = base._meta;\n\t\t\t\tif(meta.hidden[name] !== caller){\n\t\t\t\t\t// error detection\n\t\t\t\t\tchains = meta.chains;\n\t\t\t\t\tif(chains && typeof chains[name] == \"string\"){\n\t\t\t\t\t\terr(\"calling chained method with inherited: \" + name, this.declaredClass);\n\t\t\t\t\t}\n\t\t\t\t\t// find caller\n\t\t\t\t\tdo{\n\t\t\t\t\t\tmeta = base._meta;\n\t\t\t\t\t\tproto = base.prototype;\n\t\t\t\t\t\tif(meta && (proto[name] === caller && proto.hasOwnProperty(name) || meta.hidden[name] === caller)){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}while(base = bases[++pos]); // intentional assignment\n\t\t\t\t\tpos = base ? pos : -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// find next\n\t\t\tbase = bases[++pos];\n\t\t\tif(base){\n\t\t\t\tproto = base.prototype;\n\t\t\t\tif(base._meta && proto.hasOwnProperty(name)){\n\t\t\t\t\tf = proto[name];\n\t\t\t\t}else{\n\t\t\t\t\topf = op[name];\n\t\t\t\t\tdo{\n\t\t\t\t\t\tproto = base.prototype;\n\t\t\t\t\t\tf = proto[name];\n\t\t\t\t\t\tif(f && (base._meta ? proto.hasOwnProperty(name) : f !== opf)){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}while(base = bases[++pos]); // intentional assignment\n\t\t\t\t}\n\t\t\t}\n\t\t\tf = base && f || op[name];\n\t\t}else{\n\t\t\t// constructor\n\t\t\tif(cache.c !== caller){\n\t\t\t\t// cache bust\n\t\t\t\tpos = 0;\n\t\t\t\tmeta = bases[0]._meta;\n\t\t\t\tif(meta && meta.ctor !== caller){\n\t\t\t\t\t// error detection\n\t\t\t\t\tchains = meta.chains;\n\t\t\t\t\tif(!chains || chains.constructor !== \"manual\"){\n\t\t\t\t\t\terr(\"calling chained constructor with inherited\", this.declaredClass);\n\t\t\t\t\t}\n\t\t\t\t\t// find caller\n\t\t\t\t\twhile(base = bases[++pos]){ // intentional assignment\n\t\t\t\t\t\tmeta = base._meta;\n\t\t\t\t\t\tif(meta && meta.ctor === caller){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpos = base ? pos : -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// find next\n\t\t\twhile(base = bases[++pos]){\t// intentional assignment\n\t\t\t\tmeta = base._meta;\n\t\t\t\tf = meta ? meta.ctor : base;\n\t\t\t\tif(f){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf = base && f;\n\t\t}\n\n\t\t// cache the found super method\n\t\tcache.c = f;\n\t\tcache.p = pos;\n\n\t\t// now we have the result\n\t\tif(f){\n\t\t\treturn a === true ? f : f.apply(this, a || args);\n\t\t}\n\t\t// intentionally no return if a super method was not found\n\t}\n\n\tfunction getInherited(name, args){\n\t\tif(typeof name == \"string\"){\n\t\t\treturn this.__inherited(name, args, true);\n\t\t}\n\t\treturn this.__inherited(name, true);\n\t}\n\n\tfunction inherited__debug(args, a1, a2){\n\t\tvar f = this.getInherited(args, a1);\n\t\tif(f){ return f.apply(this, a2 || a1 || args); }\n\t\t// intentionally no return if a super method was not found\n\t}\n\n\tvar inheritedImpl = dojo.config.isDebug ? inherited__debug : inherited;\n\n\t// emulation of \"instanceof\"\n\tfunction isInstanceOf(cls){\n\t\tvar bases = this.constructor._meta.bases;\n\t\tfor(var i = 0, l = bases.length; i < l; ++i){\n\t\t\tif(bases[i] === cls){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn this instanceof cls;\n\t}\n\n\tfunction mixOwn(target, source){\n\t\t// add props adding metadata for incoming functions skipping a constructor\n\t\tfor(var name in source){\n\t\t\tif(name != cname && source.hasOwnProperty(name)){\n\t\t\t\ttarget[name] = source[name];\n\t\t\t}\n\t\t}\n\t\tif(has(\"bug-for-in-skips-shadowed\")){\n\t\t\tfor(var extraNames= lang._extraNames, i= extraNames.length; i;){\n\t\t\t\tname = extraNames[--i];\n\t\t\t\tif(name != cname && source.hasOwnProperty(name)){\n\t\t\t\t\t  target[name] = source[name];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// implementation of safe mixin function\n\tfunction safeMixin(target, source){\n\t\tvar name, t;\n\t\t// add props adding metadata for incoming functions skipping a constructor\n\t\tfor(name in source){\n\t\t\tt = source[name];\n\t\t\tif((t !== op[name] || !(name in op)) && name != cname){\n\t\t\t\tif(opts.call(t) == \"[object Function]\"){\n\t\t\t\t\t// non-trivial function method => attach its name\n\t\t\t\t\tt.nom = name;\n\t\t\t\t}\n\t\t\t\ttarget[name] = t;\n\t\t\t}\n\t\t}\n\t\tif(has(\"bug-for-in-skips-shadowed\")){\n\t\t\tfor(var extraNames= lang._extraNames, i= extraNames.length; i;){\n\t\t\t\tname = extraNames[--i];\n\t\t\t\tt = source[name];\n\t\t\t\tif((t !== op[name] || !(name in op)) && name != cname){\n\t\t\t\t\tif(opts.call(t) == \"[object Function]\"){\n\t\t\t\t\t\t// non-trivial function method => attach its name\n\t\t\t\t\t\t  t.nom = name;\n\t\t\t\t\t}\n\t\t\t\t\ttarget[name] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn target;\n\t}\n\n\tfunction extend(source){\n\t\tdeclare.safeMixin(this.prototype, source);\n\t\treturn this;\n\t}\n\n\t// chained constructor compatible with the legacy dojo.declare()\n\tfunction chainedConstructor(bases, ctorSpecial){\n\t\treturn function(){\n\t\t\tvar a = arguments, args = a, a0 = a[0], f, i, m,\n\t\t\t\tl = bases.length, preArgs;\n\n\t\t\tif(!(this instanceof a.callee)){\n\t\t\t\t// not called via new, so force it\n\t\t\t\treturn applyNew(a);\n\t\t\t}\n\n\t\t\t//this._inherited = {};\n\t\t\t// perform the shaman's rituals of the original dojo.declare()\n\t\t\t// 1) call two types of the preamble\n\t\t\tif(ctorSpecial && (a0 && a0.preamble || this.preamble)){\n\t\t\t\t// full blown ritual\n\t\t\t\tpreArgs = new Array(bases.length);\n\t\t\t\t// prepare parameters\n\t\t\t\tpreArgs[0] = a;\n\t\t\t\tfor(i = 0;;){\n\t\t\t\t\t// process the preamble of the 1st argument\n\t\t\t\t\ta0 = a[0];\n\t\t\t\t\tif(a0){\n\t\t\t\t\t\tf = a0.preamble;\n\t\t\t\t\t\tif(f){\n\t\t\t\t\t\t\ta = f.apply(this, a) || a;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// process the preamble of this class\n\t\t\t\t\tf = bases[i].prototype;\n\t\t\t\t\tf = f.hasOwnProperty(\"preamble\") && f.preamble;\n\t\t\t\t\tif(f){\n\t\t\t\t\t\ta = f.apply(this, a) || a;\n\t\t\t\t\t}\n\t\t\t\t\t// one peculiarity of the preamble:\n\t\t\t\t\t// it is called if it is not needed,\n\t\t\t\t\t// e.g., there is no constructor to call\n\t\t\t\t\t// let's watch for the last constructor\n\t\t\t\t\t// (see ticket #9795)\n\t\t\t\t\tif(++i == l){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tpreArgs[i] = a;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 2) call all non-trivial constructors using prepared arguments\n\t\t\tfor(i = l - 1; i >= 0; --i){\n\t\t\t\tf = bases[i];\n\t\t\t\tm = f._meta;\n\t\t\t\tf = m ? m.ctor : f;\n\t\t\t\tif(f){\n\t\t\t\t\tf.apply(this, preArgs ? preArgs[i] : a);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 3) continue the original ritual: call the postscript\n\t\t\tf = this.postscript;\n\t\t\tif(f){\n\t\t\t\tf.apply(this, args);\n\t\t\t}\n\t\t};\n\t}\n\n\n\t// chained constructor compatible with the legacy dojo.declare()\n\tfunction singleConstructor(ctor, ctorSpecial){\n\t\treturn function(){\n\t\t\tvar a = arguments, t = a, a0 = a[0], f;\n\n\t\t\tif(!(this instanceof a.callee)){\n\t\t\t\t// not called via new, so force it\n\t\t\t\treturn applyNew(a);\n\t\t\t}\n\n\t\t\t//this._inherited = {};\n\t\t\t// perform the shaman's rituals of the original dojo.declare()\n\t\t\t// 1) call two types of the preamble\n\t\t\tif(ctorSpecial){\n\t\t\t\t// full blown ritual\n\t\t\t\tif(a0){\n\t\t\t\t\t// process the preamble of the 1st argument\n\t\t\t\t\tf = a0.preamble;\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tt = f.apply(this, t) || t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tf = this.preamble;\n\t\t\t\tif(f){\n\t\t\t\t\t// process the preamble of this class\n\t\t\t\t\tf.apply(this, t);\n\t\t\t\t\t// one peculiarity of the preamble:\n\t\t\t\t\t// it is called even if it is not needed,\n\t\t\t\t\t// e.g., there is no constructor to call\n\t\t\t\t\t// let's watch for the last constructor\n\t\t\t\t\t// (see ticket #9795)\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 2) call a constructor\n\t\t\tif(ctor){\n\t\t\t\tctor.apply(this, a);\n\t\t\t}\n\t\t\t// 3) continue the original ritual: call the postscript\n\t\t\tf = this.postscript;\n\t\t\tif(f){\n\t\t\t\tf.apply(this, a);\n\t\t\t}\n\t\t};\n\t}\n\n\t// plain vanilla constructor (can use inherited() to call its base constructor)\n\tfunction simpleConstructor(bases){\n\t\treturn function(){\n\t\t\tvar a = arguments, i = 0, f, m;\n\n\t\t\tif(!(this instanceof a.callee)){\n\t\t\t\t// not called via new, so force it\n\t\t\t\treturn applyNew(a);\n\t\t\t}\n\n\t\t\t//this._inherited = {};\n\t\t\t// perform the shaman's rituals of the original dojo.declare()\n\t\t\t// 1) do not call the preamble\n\t\t\t// 2) call the top constructor (it can use this.inherited())\n\t\t\tfor(; f = bases[i]; ++i){ // intentional assignment\n\t\t\t\tm = f._meta;\n\t\t\t\tf = m ? m.ctor : f;\n\t\t\t\tif(f){\n\t\t\t\t\tf.apply(this, a);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 3) call the postscript\n\t\t\tf = this.postscript;\n\t\t\tif(f){\n\t\t\t\tf.apply(this, a);\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction chain(name, bases, reversed){\n\t\treturn function(){\n\t\t\tvar b, m, f, i = 0, step = 1;\n\t\t\tif(reversed){\n\t\t\t\ti = bases.length - 1;\n\t\t\t\tstep = -1;\n\t\t\t}\n\t\t\tfor(; b = bases[i]; i += step){ // intentional assignment\n\t\t\t\tm = b._meta;\n\t\t\t\tf = (m ? m.hidden : b.prototype)[name];\n\t\t\t\tif(f){\n\t\t\t\t\tf.apply(this, arguments);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// forceNew(ctor)\n\t// return a new object that inherits from ctor.prototype but\n\t// without actually running ctor on the object.\n\tfunction forceNew(ctor){\n\t\t// create object with correct prototype using a do-nothing\n\t\t// constructor\n\t\txtor.prototype = ctor.prototype;\n\t\tvar t = new xtor;\n\t\txtor.prototype = null;\t// clean up\n\t\treturn t;\n\t}\n\n\t// applyNew(args)\n\t// just like 'new ctor()' except that the constructor and its arguments come\n\t// from args, which must be an array or an arguments object\n\tfunction applyNew(args){\n\t\t// create an object with ctor's prototype but without\n\t\t// calling ctor on it.\n\t\tvar ctor = args.callee, t = forceNew(ctor);\n\t\t// execute the real constructor on the new object\n\t\tctor.apply(t, args);\n\t\treturn t;\n\t}\n\n\tfunction declare(className, superclass, props){\n\t\t// crack parameters\n\t\tif(typeof className != \"string\"){\n\t\t\tprops = superclass;\n\t\t\tsuperclass = className;\n\t\t\tclassName = \"\";\n\t\t}\n\t\tprops = props || {};\n\n\t\tvar proto, i, t, ctor, name, bases, chains, mixins = 1, parents = superclass;\n\n\t\t// build a prototype\n\t\tif(opts.call(superclass) == \"[object Array]\"){\n\t\t\t// C3 MRO\n\t\t\tbases = c3mro(superclass, className);\n\t\t\tt = bases[0];\n\t\t\tmixins = bases.length - t;\n\t\t\tsuperclass = bases[mixins];\n\t\t}else{\n\t\t\tbases = [0];\n\t\t\tif(superclass){\n\t\t\t\tif(opts.call(superclass) == \"[object Function]\"){\n\t\t\t\t\tt = superclass._meta;\n\t\t\t\t\tbases = bases.concat(t ? t.bases : superclass);\n\t\t\t\t}else{\n\t\t\t\t\terr(\"base class is not a callable constructor.\", className);\n\t\t\t\t}\n\t\t\t}else if(superclass !== null){\n\t\t\t\terr(\"unknown base class. Did you use dojo.require to pull it in?\", className);\n\t\t\t}\n\t\t}\n\t\tif(superclass){\n\t\t\tfor(i = mixins - 1;; --i){\n\t\t\t\tproto = forceNew(superclass);\n\t\t\t\tif(!i){\n\t\t\t\t\t// stop if nothing to add (the last base)\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// mix in properties\n\t\t\t\tt = bases[i];\n\t\t\t\t(t._meta ? mixOwn : mix)(proto, t.prototype);\n\t\t\t\t// chain in new constructor\n\t\t\t\tctor = new Function;\n\t\t\t\tctor.superclass = superclass;\n\t\t\t\tctor.prototype = proto;\n\t\t\t\tsuperclass = proto.constructor = ctor;\n\t\t\t}\n\t\t}else{\n\t\t\tproto = {};\n\t\t}\n\t\t// add all properties\n\t\tdeclare.safeMixin(proto, props);\n\t\t// add constructor\n\t\tt = props.constructor;\n\t\tif(t !== op.constructor){\n\t\t\tt.nom = cname;\n\t\t\tproto.constructor = t;\n\t\t}\n\n\t\t// collect chains and flags\n\t\tfor(i = mixins - 1; i; --i){ // intentional assignment\n\t\t\tt = bases[i]._meta;\n\t\t\tif(t && t.chains){\n\t\t\t\tchains = mix(chains || {}, t.chains);\n\t\t\t}\n\t\t}\n\t\tif(proto[\"-chains-\"]){\n\t\t\tchains = mix(chains || {}, proto[\"-chains-\"]);\n\t\t}\n\n\t\t// build ctor\n\t\tt = !chains || !chains.hasOwnProperty(cname);\n\t\tbases[0] = ctor = (chains && chains.constructor === \"manual\") ? simpleConstructor(bases) :\n\t\t\t(bases.length == 1 ? singleConstructor(props.constructor, t) : chainedConstructor(bases, t));\n\n\t\t// add meta information to the constructor\n\t\tctor._meta  = {bases: bases, hidden: props, chains: chains,\n\t\t\tparents: parents, ctor: props.constructor};\n\t\tctor.superclass = superclass && superclass.prototype;\n\t\tctor.extend = extend;\n\t\tctor.prototype = proto;\n\t\tproto.constructor = ctor;\n\n\t\t// add \"standard\" methods to the prototype\n\t\tproto.getInherited = getInherited;\n\t\tproto.isInstanceOf = isInstanceOf;\n\t\tproto.inherited    = inheritedImpl;\n\t\tproto.__inherited  = inherited;\n\n\t\t// add name if specified\n\t\tif(className){\n\t\t\tproto.declaredClass = className;\n\t\t\tlang.setObject(className, ctor);\n\t\t}\n\n\t\t// build chains and add them to the prototype\n\t\tif(chains){\n\t\t\tfor(name in chains){\n\t\t\t\tif(proto[name] && typeof chains[name] == \"string\" && name != cname){\n\t\t\t\t\tt = proto[name] = chain(name, bases, chains[name] === \"after\");\n\t\t\t\t\tt.nom = name;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// chained methods do not return values\n\t\t// no need to chain \"invisible\" functions\n\n\t\treturn ctor;\t// Function\n\t}\n\n\t/*=====\n\tdojo.declare = function(className, superclass, props){\n\t\t//\tsummary:\n\t\t//\t\tCreate a feature-rich constructor from compact notation.\n\t\t//\tclassName: String?:\n\t\t//\t\tThe optional name of the constructor (loosely, a \"class\")\n\t\t//\t\tstored in the \"declaredClass\" property in the created prototype.\n\t\t//\t\tIt will be used as a global name for a created constructor.\n\t\t//\tsuperclass: Function|Function[]:\n\t\t//\t\tMay be null, a Function, or an Array of Functions. This argument\n\t\t//\t\tspecifies a list of bases (the left-most one is the most deepest\n\t\t//\t\tbase).\n\t\t//\tprops: Object:\n\t\t//\t\tAn object whose properties are copied to the created prototype.\n\t\t//\t\tAdd an instance-initialization function by making it a property\n\t\t//\t\tnamed \"constructor\".\n\t\t//\treturns:\n\t\t//\t\tNew constructor function.\n\t\t//\tdescription:\n\t\t//\t\tCreate a constructor using a compact notation for inheritance and\n\t\t//\t\tprototype extension.\n\t\t//\n\t\t//\t\tMixin ancestors provide a type of multiple inheritance.\n\t\t//\t\tPrototypes of mixin ancestors are copied to the new class:\n\t\t//\t\tchanges to mixin prototypes will not affect classes to which\n\t\t//\t\tthey have been mixed in.\n\t\t//\n\t\t//\t\tAncestors can be compound classes created by this version of\n\t\t//\t\tdojo.declare. In complex cases all base classes are going to be\n\t\t//\t\tlinearized according to C3 MRO algorithm\n\t\t//\t\t(see http://www.python.org/download/releases/2.3/mro/ for more\n\t\t//\t\tdetails).\n\t\t//\n\t\t//\t\t\"className\" is cached in \"declaredClass\" property of the new class,\n\t\t//\t\tif it was supplied. The immediate super class will be cached in\n\t\t//\t\t\"superclass\" property of the new class.\n\t\t//\n\t\t//\t\tMethods in \"props\" will be copied and modified: \"nom\" property\n\t\t//\t\t(the declared name of the method) will be added to all copied\n\t\t//\t\tfunctions to help identify them for the internal machinery. Be\n\t\t//\t\tvery careful, while reusing methods: if you use the same\n\t\t//\t\tfunction under different names, it can produce errors in some\n\t\t//\t\tcases.\n\t\t//\n\t\t//\t\tIt is possible to use constructors created \"manually\" (without\n\t\t//\t\tdojo.declare) as bases. They will be called as usual during the\n\t\t//\t\tcreation of an instance, their methods will be chained, and even\n\t\t//\t\tcalled by \"this.inherited()\".\n\t\t//\n\t\t//\t\tSpecial property \"-chains-\" governs how to chain methods. It is\n\t\t//\t\ta dictionary, which uses method names as keys, and hint strings\n\t\t//\t\tas values. If a hint string is \"after\", this method will be\n\t\t//\t\tcalled after methods of its base classes. If a hint string is\n\t\t//\t\t\"before\", this method will be called before methods of its base\n\t\t//\t\tclasses.\n\t\t//\n\t\t//\t\tIf \"constructor\" is not mentioned in \"-chains-\" property, it will\n\t\t//\t\tbe chained using the legacy mode: using \"after\" chaining,\n\t\t//\t\tcalling preamble() method before each constructor, if available,\n\t\t//\t\tand calling postscript() after all constructors were executed.\n\t\t//\t\tIf the hint is \"after\", it is chained as a regular method, but\n\t\t//\t\tpostscript() will be called after the chain of constructors.\n\t\t//\t\t\"constructor\" cannot be chained \"before\", but it allows\n\t\t//\t\ta special hint string: \"manual\", which means that constructors\n\t\t//\t\tare not going to be chained in any way, and programmer will call\n\t\t//\t\tthem manually using this.inherited(). In the latter case\n\t\t//\t\tpostscript() will be called after the construction.\n\t\t//\n\t\t//\t\tAll chaining hints are \"inherited\" from base classes and\n\t\t//\t\tpotentially can be overridden. Be very careful when overriding\n\t\t//\t\thints! Make sure that all chained methods can work in a proposed\n\t\t//\t\tmanner of chaining.\n\t\t//\n\t\t//\t\tOnce a method was chained, it is impossible to unchain it. The\n\t\t//\t\tonly exception is \"constructor\". You don't need to define a\n\t\t//\t\tmethod in order to supply a chaining hint.\n\t\t//\n\t\t//\t\tIf a method is chained, it cannot use this.inherited() because\n\t\t//\t\tall other methods in the hierarchy will be called automatically.\n\t\t//\n\t\t//\t\tUsually constructors and initializers of any kind are chained\n\t\t//\t\tusing \"after\" and destructors of any kind are chained as\n\t\t//\t\t\"before\". Note that chaining assumes that chained methods do not\n\t\t//\t\treturn any value: any returned value will be discarded.\n\t\t//\n\t\t//\texample:\n\t\t//\t|\tdojo.declare(\"my.classes.bar\", my.classes.foo, {\n\t\t//\t|\t\t// properties to be added to the class prototype\n\t\t//\t|\t\tsomeValue: 2,\n\t\t//\t|\t\t// initialization function\n\t\t//\t|\t\tconstructor: function(){\n\t\t//\t|\t\t\tthis.myComplicatedObject = new ReallyComplicatedObject();\n\t\t//\t|\t\t},\n\t\t//\t|\t\t// other functions\n\t\t//\t|\t\tsomeMethod: function(){\n\t\t//\t|\t\t\tdoStuff();\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\n\t\t//\texample:\n\t\t//\t|\tvar MyBase = dojo.declare(null, {\n\t\t//\t|\t\t// constructor, properties, and methods go here\n\t\t//\t|\t\t// ...\n\t\t//\t|\t});\n\t\t//\t|\tvar MyClass1 = dojo.declare(MyBase, {\n\t\t//\t|\t\t// constructor, properties, and methods go here\n\t\t//\t|\t\t// ...\n\t\t//\t|\t});\n\t\t//\t|\tvar MyClass2 = dojo.declare(MyBase, {\n\t\t//\t|\t\t// constructor, properties, and methods go here\n\t\t//\t|\t\t// ...\n\t\t//\t|\t});\n\t\t//\t|\tvar MyDiamond = dojo.declare([MyClass1, MyClass2], {\n\t\t//\t|\t\t// constructor, properties, and methods go here\n\t\t//\t|\t\t// ...\n\t\t//\t|\t});\n\t\t//\n\t\t//\texample:\n\t\t//\t|\tvar F = function(){ console.log(\"raw constructor\"); };\n\t\t//\t|\tF.prototype.method = function(){\n\t\t//\t|\t\tconsole.log(\"raw method\");\n\t\t//\t|\t};\n\t\t//\t|\tvar A = dojo.declare(F, {\n\t\t//\t|\t\tconstructor: function(){\n\t\t//\t|\t\t\tconsole.log(\"A.constructor\");\n\t\t//\t|\t\t},\n\t\t//\t|\t\tmethod: function(){\n\t\t//\t|\t\t\tconsole.log(\"before calling F.method...\");\n\t\t//\t|\t\t\tthis.inherited(arguments);\n\t\t//\t|\t\t\tconsole.log(\"...back in A\");\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\t|\tnew A().method();\n\t\t//\t|\t// will print:\n\t\t//\t|\t// raw constructor\n\t\t//\t|\t// A.constructor\n\t\t//\t|\t// before calling F.method...\n\t\t//\t|\t// raw method\n\t\t//\t|\t// ...back in A\n\t\t//\n\t\t//\texample:\n\t\t//\t|\tvar A = dojo.declare(null, {\n\t\t//\t|\t\t\"-chains-\": {\n\t\t//\t|\t\t\tdestroy: \"before\"\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\t|\tvar B = dojo.declare(A, {\n\t\t//\t|\t\tconstructor: function(){\n\t\t//\t|\t\t\tconsole.log(\"B.constructor\");\n\t\t//\t|\t\t},\n\t\t//\t|\t\tdestroy: function(){\n\t\t//\t|\t\t\tconsole.log(\"B.destroy\");\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\t|\tvar C = dojo.declare(B, {\n\t\t//\t|\t\tconstructor: function(){\n\t\t//\t|\t\t\tconsole.log(\"C.constructor\");\n\t\t//\t|\t\t},\n\t\t//\t|\t\tdestroy: function(){\n\t\t//\t|\t\t\tconsole.log(\"C.destroy\");\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\t|\tnew C().destroy();\n\t\t//\t|\t// prints:\n\t\t//\t|\t// B.constructor\n\t\t//\t|\t// C.constructor\n\t\t//\t|\t// C.destroy\n\t\t//\t|\t// B.destroy\n\t\t//\n\t\t//\texample:\n\t\t//\t|\tvar A = dojo.declare(null, {\n\t\t//\t|\t\t\"-chains-\": {\n\t\t//\t|\t\t\tconstructor: \"manual\"\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\t|\tvar B = dojo.declare(A, {\n\t\t//\t|\t\tconstructor: function(){\n\t\t//\t|\t\t\t// ...\n\t\t//\t|\t\t\t// call the base constructor with new parameters\n\t\t//\t|\t\t\tthis.inherited(arguments, [1, 2, 3]);\n\t\t//\t|\t\t\t// ...\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\n\t\t//\texample:\n\t\t//\t|\tvar A = dojo.declare(null, {\n\t\t//\t|\t\t\"-chains-\": {\n\t\t//\t|\t\t\tm1: \"before\"\n\t\t//\t|\t\t},\n\t\t//\t|\t\tm1: function(){\n\t\t//\t|\t\t\tconsole.log(\"A.m1\");\n\t\t//\t|\t\t},\n\t\t//\t|\t\tm2: function(){\n\t\t//\t|\t\t\tconsole.log(\"A.m2\");\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\t|\tvar B = dojo.declare(A, {\n\t\t//\t|\t\t\"-chains-\": {\n\t\t//\t|\t\t\tm2: \"after\"\n\t\t//\t|\t\t},\n\t\t//\t|\t\tm1: function(){\n\t\t//\t|\t\t\tconsole.log(\"B.m1\");\n\t\t//\t|\t\t},\n\t\t//\t|\t\tm2: function(){\n\t\t//\t|\t\t\tconsole.log(\"B.m2\");\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\t|\tvar x = new B();\n\t\t//\t|\tx.m1();\n\t\t//\t|\t// prints:\n\t\t//\t|\t// B.m1\n\t\t//\t|\t// A.m1\n\t\t//\t|\tx.m2();\n\t\t//\t|\t// prints:\n\t\t//\t|\t// A.m2\n\t\t//\t|\t// B.m2\n\t\treturn new Function(); // Function\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.safeMixin = function(target, source){\n\t\t//\tsummary:\n\t\t//\t\tMix in properties skipping a constructor and decorating functions\n\t\t//\t\tlike it is done by dojo.declare.\n\t\t//\ttarget: Object\n\t\t//\t\tTarget object to accept new properties.\n\t\t//\tsource: Object\n\t\t//\t\tSource object for new properties.\n\t\t//\tdescription:\n\t\t//\t\tThis function is used to mix in properties like lang.mixin does,\n\t\t//\t\tbut it skips a constructor property and decorates functions like\n\t\t//\t\tdojo.declare does.\n\t\t//\n\t\t//\t\tIt is meant to be used with classes and objects produced with\n\t\t//\t\tdojo.declare. Functions mixed in with dojo.safeMixin can use\n\t\t//\t\tthis.inherited() like normal methods.\n\t\t//\n\t\t//\t\tThis function is used to implement extend() method of a constructor\n\t\t//\t\tproduced with dojo.declare().\n\t\t//\n\t\t//\texample:\n\t\t//\t|\tvar A = dojo.declare(null, {\n\t\t//\t|\t\tm1: function(){\n\t\t//\t|\t\t\tconsole.log(\"A.m1\");\n\t\t//\t|\t\t},\n\t\t//\t|\t\tm2: function(){\n\t\t//\t|\t\t\tconsole.log(\"A.m2\");\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\t|\tvar B = dojo.declare(A, {\n\t\t//\t|\t\tm1: function(){\n\t\t//\t|\t\t\tthis.inherited(arguments);\n\t\t//\t|\t\t\tconsole.log(\"B.m1\");\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\t|\tB.extend({\n\t\t//\t|\t\tm2: function(){\n\t\t//\t|\t\t\tthis.inherited(arguments);\n\t\t//\t|\t\t\tconsole.log(\"B.m2\");\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\t|\tvar x = new B();\n\t\t//\t|\tdojo.safeMixin(x, {\n\t\t//\t|\t\tm1: function(){\n\t\t//\t|\t\t\tthis.inherited(arguments);\n\t\t//\t|\t\t\tconsole.log(\"X.m1\");\n\t\t//\t|\t\t},\n\t\t//\t|\t\tm2: function(){\n\t\t//\t|\t\t\tthis.inherited(arguments);\n\t\t//\t|\t\t\tconsole.log(\"X.m2\");\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\t|\tx.m2();\n\t\t//\t|\t// prints:\n\t\t//\t|\t// A.m1\n\t\t//\t|\t// B.m1\n\t\t//\t|\t// X.m1\n\t};\n\t=====*/\n\n\t/*=====\n\tObject.inherited = function(name, args, newArgs){\n\t\t//\tsummary:\n\t\t//\t\tCalls a super method.\n\t\t//\tname: String?\n\t\t//\t\tThe optional method name. Should be the same as the caller's\n\t\t//\t\tname. Usually \"name\" is specified in complex dynamic cases, when\n\t\t//\t\tthe calling method was dynamically added, undecorated by\n\t\t//\t\tdojo.declare, and it cannot be determined.\n\t\t//\targs: Arguments\n\t\t//\t\tThe caller supply this argument, which should be the original\n\t\t//\t\t\"arguments\".\n\t\t//\tnewArgs: Object?\n\t\t//\t\tIf \"true\", the found function will be returned without\n\t\t//\t\texecuting it.\n\t\t//\t\tIf Array, it will be used to call a super method. Otherwise\n\t\t//\t\t\"args\" will be used.\n\t\t//\treturns:\n\t\t//\t\tWhatever is returned by a super method, or a super method itself,\n\t\t//\t\tif \"true\" was specified as newArgs.\n\t\t//\tdescription:\n\t\t//\t\tThis method is used inside method of classes produced with\n\t\t//\t\tdojo.declare to call a super method (next in the chain). It is\n\t\t//\t\tused for manually controlled chaining. Consider using the regular\n\t\t//\t\tchaining, because it is faster. Use \"this.inherited()\" only in\n\t\t//\t\tcomplex cases.\n\t\t//\n\t\t//\t\tThis method cannot me called from automatically chained\n\t\t//\t\tconstructors including the case of a special (legacy)\n\t\t//\t\tconstructor chaining. It cannot be called from chained methods.\n\t\t//\n\t\t//\t\tIf \"this.inherited()\" cannot find the next-in-chain method, it\n\t\t//\t\tdoes nothing and returns \"undefined\". The last method in chain\n\t\t//\t\tcan be a default method implemented in Object, which will be\n\t\t//\t\tcalled last.\n\t\t//\n\t\t//\t\tIf \"name\" is specified, it is assumed that the method that\n\t\t//\t\treceived \"args\" is the parent method for this call. It is looked\n\t\t//\t\tup in the chain list and if it is found the next-in-chain method\n\t\t//\t\tis called. If it is not found, the first-in-chain method is\n\t\t//\t\tcalled.\n\t\t//\n\t\t//\t\tIf \"name\" is not specified, it will be derived from the calling\n\t\t//\t\tmethod (using a methoid property \"nom\").\n\t\t//\n\t\t//\texample:\n\t\t//\t|\tvar B = dojo.declare(A, {\n\t\t//\t|\t\tmethod1: function(a, b, c){\n\t\t//\t|\t\t\tthis.inherited(arguments);\n\t\t//\t|\t\t},\n\t\t//\t|\t\tmethod2: function(a, b){\n\t\t//\t|\t\t\treturn this.inherited(arguments, [a + b]);\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\t|\t// next method is not in the chain list because it is added\n\t\t//\t|\t// manually after the class was created.\n\t\t//\t|\tB.prototype.method3 = function(){\n\t\t//\t|\t\tconsole.log(\"This is a dynamically-added method.\");\n\t\t//\t|\t\tthis.inherited(\"method3\", arguments);\n\t\t//\t|\t};\n\t\t//\texample:\n\t\t//\t|\tvar B = dojo.declare(A, {\n\t\t//\t|\t\tmethod: function(a, b){\n\t\t//\t|\t\t\tvar super = this.inherited(arguments, true);\n\t\t//\t|\t\t\t// ...\n\t\t//\t|\t\t\tif(!super){\n\t\t//\t|\t\t\t\tconsole.log(\"there is no super method\");\n\t\t//\t|\t\t\t\treturn 0;\n\t\t//\t|\t\t\t}\n\t\t//\t|\t\t\treturn super.apply(this, arguments);\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\treturn\t{};\t// Object\n\t}\n\t=====*/\n\n\t/*=====\n\tObject.getInherited = function(name, args){\n\t\t//\tsummary:\n\t\t//\t\tReturns a super method.\n\t\t//\tname: String?\n\t\t//\t\tThe optional method name. Should be the same as the caller's\n\t\t//\t\tname. Usually \"name\" is specified in complex dynamic cases, when\n\t\t//\t\tthe calling method was dynamically added, undecorated by\n\t\t//\t\tdojo.declare, and it cannot be determined.\n\t\t//\targs: Arguments\n\t\t//\t\tThe caller supply this argument, which should be the original\n\t\t//\t\t\"arguments\".\n\t\t//\treturns:\n\t\t//\t\tReturns a super method (Function) or \"undefined\".\n\t\t//\tdescription:\n\t\t//\t\tThis method is a convenience method for \"this.inherited()\".\n\t\t//\t\tIt uses the same algorithm but instead of executing a super\n\t\t//\t\tmethod, it returns it, or \"undefined\" if not found.\n\t\t//\n\t\t//\texample:\n\t\t//\t|\tvar B = dojo.declare(A, {\n\t\t//\t|\t\tmethod: function(a, b){\n\t\t//\t|\t\t\tvar super = this.getInherited(arguments);\n\t\t//\t|\t\t\t// ...\n\t\t//\t|\t\t\tif(!super){\n\t\t//\t|\t\t\t\tconsole.log(\"there is no super method\");\n\t\t//\t|\t\t\t\treturn 0;\n\t\t//\t|\t\t\t}\n\t\t//\t|\t\t\treturn super.apply(this, arguments);\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\treturn\t{};\t// Object\n\t}\n\t=====*/\n\n\t/*=====\n\tObject.isInstanceOf = function(cls){\n\t\t//\tsummary:\n\t\t//\t\tChecks the inheritance chain to see if it is inherited from this\n\t\t//\t\tclass.\n\t\t//\tcls: Function\n\t\t//\t\tClass constructor.\n\t\t//\treturns:\n\t\t//\t\t\"true\", if this object is inherited from this class, \"false\"\n\t\t//\t\totherwise.\n\t\t//\tdescription:\n\t\t//\t\tThis method is used with instances of classes produced with\n\t\t//\t\tdojo.declare to determine of they support a certain interface or\n\t\t//\t\tnot. It models \"instanceof\" operator.\n\t\t//\n\t\t//\texample:\n\t\t//\t|\tvar A = dojo.declare(null, {\n\t\t//\t|\t\t// constructor, properties, and methods go here\n\t\t//\t|\t\t// ...\n\t\t//\t|\t});\n\t\t//\t|\tvar B = dojo.declare(null, {\n\t\t//\t|\t\t// constructor, properties, and methods go here\n\t\t//\t|\t\t// ...\n\t\t//\t|\t});\n\t\t//\t|\tvar C = dojo.declare([A, B], {\n\t\t//\t|\t\t// constructor, properties, and methods go here\n\t\t//\t|\t\t// ...\n\t\t//\t|\t});\n\t\t//\t|\tvar D = dojo.declare(A, {\n\t\t//\t|\t\t// constructor, properties, and methods go here\n\t\t//\t|\t\t// ...\n\t\t//\t|\t});\n\t\t//\t|\n\t\t//\t|\tvar a = new A(), b = new B(), c = new C(), d = new D();\n\t\t//\t|\n\t\t//\t|\tconsole.log(a.isInstanceOf(A)); // true\n\t\t//\t|\tconsole.log(b.isInstanceOf(A)); // false\n\t\t//\t|\tconsole.log(c.isInstanceOf(A)); // true\n\t\t//\t|\tconsole.log(d.isInstanceOf(A)); // true\n\t\t//\t|\n\t\t//\t|\tconsole.log(a.isInstanceOf(B)); // false\n\t\t//\t|\tconsole.log(b.isInstanceOf(B)); // true\n\t\t//\t|\tconsole.log(c.isInstanceOf(B)); // true\n\t\t//\t|\tconsole.log(d.isInstanceOf(B)); // false\n\t\t//\t|\n\t\t//\t|\tconsole.log(a.isInstanceOf(C)); // false\n\t\t//\t|\tconsole.log(b.isInstanceOf(C)); // false\n\t\t//\t|\tconsole.log(c.isInstanceOf(C)); // true\n\t\t//\t|\tconsole.log(d.isInstanceOf(C)); // false\n\t\t//\t|\n\t\t//\t|\tconsole.log(a.isInstanceOf(D)); // false\n\t\t//\t|\tconsole.log(b.isInstanceOf(D)); // false\n\t\t//\t|\tconsole.log(c.isInstanceOf(D)); // false\n\t\t//\t|\tconsole.log(d.isInstanceOf(D)); // true\n\t\treturn\t{};\t// Object\n\t}\n\t=====*/\n\n\t/*=====\n\tObject.extend = function(source){\n\t\t//\tsummary:\n\t\t//\t\tAdds all properties and methods of source to constructor's\n\t\t//\t\tprototype, making them available to all instances created with\n\t\t//\t\tconstructor. This method is specific to constructors created with\n\t\t//\t\tdojo.declare.\n\t\t//\tsource: Object\n\t\t//\t\tSource object which properties are going to be copied to the\n\t\t//\t\tconstructor's prototype.\n\t\t//\tdescription:\n\t\t//\t\tAdds source properties to the constructor's prototype. It can\n\t\t//\t\toverride existing properties.\n\t\t//\n\t\t//\t\tThis method is similar to dojo.extend function, but it is specific\n\t\t//\t\tto constructors produced by dojo.declare. It is implemented\n\t\t//\t\tusing dojo.safeMixin, and it skips a constructor property,\n\t\t//\t\tand properly decorates copied functions.\n\t\t//\n\t\t//\texample:\n\t\t//\t|\tvar A = dojo.declare(null, {\n\t\t//\t|\t\tm1: function(){},\n\t\t//\t|\t\ts1: \"Popokatepetl\"\n\t\t//\t|\t});\n\t\t//\t|\tA.extend({\n\t\t//\t|\t\tm1: function(){},\n\t\t//\t|\t\tm2: function(){},\n\t\t//\t|\t\tf1: true,\n\t\t//\t|\t\td1: 42\n\t\t//\t|\t});\n\t};\n\t=====*/\n\n\tdojo.safeMixin = declare.safeMixin = safeMixin;\n\tdojo.declare = declare;\n\n\treturn declare;\n});\n\n},\n'dojo/dom':function(){\ndefine([\"./_base/sniff\", \"./_base/lang\", \"./_base/window\"],\n\t\tfunction(has, lang, win){\n\t// module:\n\t//\t\tdojo/dom\n\t// summary:\n\t//\t\tThis module defines the core dojo DOM API.\n\n\t// FIXME: need to add unit tests for all the semi-public methods\n\n\t\ttry{\n\t\tdocument.execCommand(\"BackgroundImageCache\", false, true);\n\t}catch(e){\n\t\t// sane browsers don't have cache \"issues\"\n\t}\n\t\n\t// =============================\n\t// DOM Functions\n\t// =============================\n\n\t/*=====\n\tdojo.byId = function(id, doc){\n\t\t// summary:\n\t\t//\t\tReturns DOM node with matching `id` attribute or `null`\n\t\t//\t\tif not found. If `id` is a DomNode, this function is a no-op.\n\t\t//\n\t\t// id: String|DOMNode\n\t\t//\t \tA string to match an HTML id attribute or a reference to a DOM Node\n\t\t//\n\t\t// doc: Document?\n\t\t//\t\tDocument to work in. Defaults to the current value of\n\t\t//\t\tdojo.doc.  Can be used to retrieve\n\t\t//\t\tnode references from other documents.\n\t\t//\n\t\t// example:\n\t\t//\t\tLook up a node by ID:\n\t\t//\t|\tvar n = dojo.byId(\"foo\");\n\t\t//\n\t\t// example:\n\t\t//\t\tCheck if a node exists, and use it.\n\t\t//\t|\tvar n = dojo.byId(\"bar\");\n\t\t//\t|\tif(n){ doStuff() ... }\n\t\t//\n\t\t// example:\n\t\t//\t\tAllow string or DomNode references to be passed to a custom function:\n\t\t//\t|\tvar foo = function(nodeOrId){\n\t\t//\t|\t\tnodeOrId = dojo.byId(nodeOrId);\n\t\t//\t|\t\t// ... more stuff\n\t\t//\t|\t}\n\t=====*/\n\n\t/*=====\n\tdojo.isDescendant = function(node, ancestor){\n\t\t// summary:\n\t\t//\t\tReturns true if node is a descendant of ancestor\n\t\t// node: DOMNode|String\n\t\t//\t\tstring id or node reference to test\n\t\t// ancestor: DOMNode|String\n\t\t//\t\tstring id or node reference of potential parent to test against\n\t\t//\n\t\t// example:\n\t\t//\t\tTest is node id=\"bar\" is a descendant of node id=\"foo\"\n\t\t//\t|\tif(dojo.isDescendant(\"bar\", \"foo\")){ ... }\n\t};\n\t=====*/\n\n\t// TODO: do we need this function in the base?\n\n\t/*=====\n\tdojo.setSelectable = function(node, selectable){\n\t\t// summary:\n\t\t//\t\tEnable or disable selection on a node\n\t\t// node: DOMNode|String\n\t\t//\t\tid or reference to node\n\t\t// selectable: Boolean\n\t\t//\t\tstate to put the node in. false indicates unselectable, true\n\t\t//\t\tallows selection.\n\t\t// example:\n\t\t//\t\tMake the node id=\"bar\" unselectable\n\t\t//\t|\tdojo.setSelectable(\"bar\");\n\t\t// example:\n\t\t//\t\tMake the node id=\"bar\" selectable\n\t\t//\t|\tdojo.setSelectable(\"bar\", true);\n\t};\n\t=====*/\n\n\tvar dom = {};   // the result object\n\n\t\tif(has(\"ie\")){\n\t\tdom.byId = function(id, doc){\n\t\t\tif(typeof id != \"string\"){\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\tvar _d = doc || win.doc, te = id && _d.getElementById(id);\n\t\t\t// attributes.id.value is better than just id in case the\n\t\t\t// user has a name=id inside a form\n\t\t\tif(te && (te.attributes.id.value == id || te.id == id)){\n\t\t\t\treturn te;\n\t\t\t}else{\n\t\t\t\tvar eles = _d.all[id];\n\t\t\t\tif(!eles || eles.nodeName){\n\t\t\t\t\teles = [eles];\n\t\t\t\t}\n\t\t\t\t// if more than 1, choose first with the correct id\n\t\t\t\tvar i = 0;\n\t\t\t\twhile((te = eles[i++])){\n\t\t\t\t\tif((te.attributes && te.attributes.id && te.attributes.id.value == id) || te.id == id){\n\t\t\t\t\t\treturn te;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}else{\n\t\t\tdom.byId = function(id, doc){\n\t\t\t// inline'd type check.\n\t\t\t// be sure to return null per documentation, to match IE branch.\n\t\t\treturn ((typeof id == \"string\") ? (doc || win.doc).getElementById(id) : id) || null; // DOMNode\n\t\t};\n\t\t}\n\t\t/*=====\n\t};\n\t=====*/\n\n\tdom.isDescendant = function(/*DOMNode|String*/node, /*DOMNode|String*/ancestor){\n\t\ttry{\n\t\t\tnode = dom.byId(node);\n\t\t\tancestor = dom.byId(ancestor);\n\t\t\twhile(node){\n\t\t\t\tif(node == ancestor){\n\t\t\t\t\treturn true; // Boolean\n\t\t\t\t}\n\t\t\t\tnode = node.parentNode;\n\t\t\t}\n\t\t}catch(e){ /* squelch, return false */ }\n\t\treturn false; // Boolean\n\t};\n\n\t// TODO: do we need this function in the base?\n\n\tdom.setSelectable = function(/*DOMNode|String*/node, /*Boolean*/selectable){\n\t\tnode = dom.byId(node);\n\t\t\t\tif(has(\"mozilla\")){\n\t\t\tnode.style.MozUserSelect = selectable ? \"\" : \"none\";\n\t\t}else if(has(\"khtml\") || has(\"webkit\")){\n\t\t\t\t\tnode.style.KhtmlUserSelect = selectable ? \"auto\" : \"none\";\n\t\t\t\t}else if(has(\"ie\")){\n\t\t\tvar v = (node.unselectable = selectable ? \"\" : \"on\"),\n\t\t\t\tcs = node.getElementsByTagName(\"*\"), i = 0, l = cs.length;\n\t\t\tfor(; i < l; ++i){\n\t\t\t\tcs.item(i).unselectable = v;\n\t\t\t}\n\t\t}\n\t\t\t\t//FIXME: else?  Opera?\n\t};\n\n\treturn dom;\n});\n\n},\n'dojo/_base/browser':function(){\nif(require.has){\n\trequire.has.add(\"config-selectorEngine\", \"acme\");\n}\ndefine(\"dojo/_base/browser\", [\n\t\"../ready\",\n\t\"./kernel\",\n\t\"./connect\", // until we decide if connect is going back into non-browser environments\n\t\"./unload\",\n\t\"./window\",\n\t\"./event\",\n\t\"./html\",\n\t\"./NodeList\",\n\t\"../query\",\n\t\"./xhr\",\n\t\"./fx\"], function(dojo) {\n\t// module:\n\t//\t\tdojo/_base/browser\n\t// summary:\n\t//\t\tThis module causes the browser-only base modules to be loaded.\n\treturn dojo;\n});\n\n},\n'dojo/selector/acme':function(){\ndefine([\"../_base/kernel\", \"../has\", \"../dom\", \"../_base/sniff\", \"../_base/array\", \"../_base/lang\", \"../_base/window\"], function(dojo, has, dom){\n  //  module:\n  //    dojo/selector/acme\n  //  summary:\n  //    This module defines the Acme selector engine\n\n/*\n\tacme architectural overview:\n\n\t\tacme is a relatively full-featured CSS3 query library. It is\n\t\tdesigned to take any valid CSS3 selector and return the nodes matching\n\t\tthe selector. To do this quickly, it processes queries in several\n\t\tsteps, applying caching where profitable.\n\n\t\tThe steps (roughly in reverse order of the way they appear in the code):\n\t\t\t1.) check to see if we already have a \"query dispatcher\"\n\t\t\t\t- if so, use that with the given parameterization. Skip to step 4.\n\t\t\t2.) attempt to determine which branch to dispatch the query to:\n\t\t\t\t- JS (optimized DOM iteration)\n\t\t\t\t- native (FF3.1+, Safari 3.1+, IE 8+)\n\t\t\t3.) tokenize and convert to executable \"query dispatcher\"\n\t\t\t\t- this is where the lion's share of the complexity in the\n\t\t\t\t\tsystem lies. In the DOM version, the query dispatcher is\n\t\t\t\t\tassembled as a chain of \"yes/no\" test functions pertaining to\n\t\t\t\t\ta section of a simple query statement (\".blah:nth-child(odd)\"\n\t\t\t\t\tbut not \"div div\", which is 2 simple statements). Individual\n\t\t\t\t\tstatement dispatchers are cached (to prevent re-definition)\n\t\t\t\t\tas are entire dispatch chains (to make re-execution of the\n\t\t\t\t\tsame query fast)\n\t\t\t4.) the resulting query dispatcher is called in the passed scope\n\t\t\t\t\t(by default the top-level document)\n\t\t\t\t- for DOM queries, this results in a recursive, top-down\n\t\t\t\t\tevaluation of nodes based on each simple query section\n\t\t\t\t- for native implementations, this may mean working around spec\n\t\t\t\t\tbugs. So be it.\n\t\t\t5.) matched nodes are pruned to ensure they are unique (if necessary)\n*/\n\n\n\t////////////////////////////////////////////////////////////////////////\n\t// Toolkit aliases\n\t////////////////////////////////////////////////////////////////////////\n\n\t// if you are extracting acme for use in your own system, you will\n\t// need to provide these methods and properties. No other porting should be\n\t// necessary, save for configuring the system to use a class other than\n\t// dojo.NodeList as the return instance instantiator\n\tvar trim = \t\t\tdojo.trim;\n\tvar each = \t\t\tdojo.forEach;\n\t// \t\t\t\t\td.isIE; // float\n\t// \t\t\t\t\td.isSafari; // float\n\t// \t\t\t\t\td.isOpera; // float\n\t// \t\t\t\t\td.isWebKit; // float\n\t// \t\t\t\t\td.doc ; // document element\n\n\tvar getDoc = function(){ return dojo.doc; };\n\t// NOTE(alex): the spec is idiotic. CSS queries should ALWAYS be case-sensitive, but nooooooo\n\tvar cssCaseBug = ((dojo.isWebKit||dojo.isMozilla) && ((getDoc().compatMode) == \"BackCompat\"));\n\n\t////////////////////////////////////////////////////////////////////////\n\t// Global utilities\n\t////////////////////////////////////////////////////////////////////////\n\n\n\tvar specials = \">~+\";\n\n\t// global thunk to determine whether we should treat the current query as\n\t// case sensitive or not. This switch is flipped by the query evaluator\n\t// based on the document passed as the context to search.\n\tvar caseSensitive = false;\n\n\t// how high?\n\tvar yesman = function(){ return true; };\n\n\t////////////////////////////////////////////////////////////////////////\n\t// Tokenizer\n\t////////////////////////////////////////////////////////////////////////\n\n\tvar getQueryParts = function(query){\n\t\t//\tsummary:\n\t\t//\t\tstate machine for query tokenization\n\t\t//\tdescription:\n\t\t//\t\tinstead of using a brittle and slow regex-based CSS parser,\n\t\t//\t\tacme implements an AST-style query representation. This\n\t\t//\t\trepresentation is only generated once per query. For example,\n\t\t//\t\tthe same query run multiple times or under different root nodes\n\t\t//\t\tdoes not re-parse the selector expression but instead uses the\n\t\t//\t\tcached data structure. The state machine implemented here\n\t\t//\t\tterminates on the last \" \" (space) character and returns an\n\t\t//\t\tordered array of query component structures (or \"parts\"). Each\n\t\t//\t\tpart represents an operator or a simple CSS filtering\n\t\t//\t\texpression. The structure for parts is documented in the code\n\t\t//\t\tbelow.\n\n\n\t\t// NOTE:\n\t\t//\t\tthis code is designed to run fast and compress well. Sacrifices\n\t\t//\t\tto readability and maintainability have been made.  Your best\n\t\t//\t\tbet when hacking the tokenizer is to put The Donnas on *really*\n\t\t//\t\tloud (may we recommend their \"Spend The Night\" release?) and\n\t\t//\t\tjust assume you're gonna make mistakes. Keep the unit tests\n\t\t//\t\topen and run them frequently. Knowing is half the battle ;-)\n\t\tif(specials.indexOf(query.slice(-1)) >= 0){\n\t\t\t// if we end with a \">\", \"+\", or \"~\", that means we're implicitly\n\t\t\t// searching all children, so make it explicit\n\t\t\tquery += \" * \"\n\t\t}else{\n\t\t\t// if you have not provided a terminator, one will be provided for\n\t\t\t// you...\n\t\t\tquery += \" \";\n\t\t}\n\n\t\tvar ts = function(/*Integer*/ s, /*Integer*/ e){\n\t\t\t// trim and slice.\n\n\t\t\t// take an index to start a string slice from and an end position\n\t\t\t// and return a trimmed copy of that sub-string\n\t\t\treturn trim(query.slice(s, e));\n\t\t};\n\n\t\t// the overall data graph of the full query, as represented by queryPart objects\n\t\tvar queryParts = [];\n\n\n\t\t// state keeping vars\n\t\tvar inBrackets = -1, inParens = -1, inMatchFor = -1,\n\t\t\tinPseudo = -1, inClass = -1, inId = -1, inTag = -1,\n\t\t\tlc = \"\", cc = \"\", pStart;\n\n\t\t// iteration vars\n\t\tvar x = 0, // index in the query\n\t\t\tql = query.length,\n\t\t\tcurrentPart = null, // data structure representing the entire clause\n\t\t\t_cp = null; // the current pseudo or attr matcher\n\n\t\t// several temporary variables are assigned to this structure during a\n\t\t// potential sub-expression match:\n\t\t//\t\tattr:\n\t\t//\t\t\ta string representing the current full attribute match in a\n\t\t//\t\t\tbracket expression\n\t\t//\t\ttype:\n\t\t//\t\t\tif there's an operator in a bracket expression, this is\n\t\t//\t\t\tused to keep track of it\n\t\t//\t\tvalue:\n\t\t//\t\t\tthe internals of parenthetical expression for a pseudo. for\n\t\t//\t\t\t:nth-child(2n+1), value might be \"2n+1\"\n\n\t\tvar endTag = function(){\n\t\t\t// called when the tokenizer hits the end of a particular tag name.\n\t\t\t// Re-sets state variables for tag matching and sets up the matcher\n\t\t\t// to handle the next type of token (tag or operator).\n\t\t\tif(inTag >= 0){\n\t\t\t\tvar tv = (inTag == x) ? null : ts(inTag, x); // .toLowerCase();\n\t\t\t\tcurrentPart[ (specials.indexOf(tv) < 0) ? \"tag\" : \"oper\" ] = tv;\n\t\t\t\tinTag = -1;\n\t\t\t}\n\t\t};\n\n\t\tvar endId = function(){\n\t\t\t// called when the tokenizer might be at the end of an ID portion of a match\n\t\t\tif(inId >= 0){\n\t\t\t\tcurrentPart.id = ts(inId, x).replace(/\\\\/g, \"\");\n\t\t\t\tinId = -1;\n\t\t\t}\n\t\t};\n\n\t\tvar endClass = function(){\n\t\t\t// called when the tokenizer might be at the end of a class name\n\t\t\t// match. CSS allows for multiple classes, so we augment the\n\t\t\t// current item with another class in its list\n\t\t\tif(inClass >= 0){\n\t\t\t\tcurrentPart.classes.push(ts(inClass + 1, x).replace(/\\\\/g, \"\"));\n\t\t\t\tinClass = -1;\n\t\t\t}\n\t\t};\n\n\t\tvar endAll = function(){\n\t\t\t// at the end of a simple fragment, so wall off the matches\n\t\t\tendId();\n\t\t\tendTag();\n\t\t\tendClass();\n\t\t};\n\n\t\tvar endPart = function(){\n\t\t\tendAll();\n\t\t\tif(inPseudo >= 0){\n\t\t\t\tcurrentPart.pseudos.push({ name: ts(inPseudo + 1, x) });\n\t\t\t}\n\t\t\t// hint to the selector engine to tell it whether or not it\n\t\t\t// needs to do any iteration. Many simple selectors don't, and\n\t\t\t// we can avoid significant construction-time work by advising\n\t\t\t// the system to skip them\n\t\t\tcurrentPart.loops = (\n\t\t\t\t\tcurrentPart.pseudos.length ||\n\t\t\t\t\tcurrentPart.attrs.length ||\n\t\t\t\t\tcurrentPart.classes.length\t);\n\n\t\t\tcurrentPart.oquery = currentPart.query = ts(pStart, x); // save the full expression as a string\n\n\n\t\t\t// otag/tag are hints to suggest to the system whether or not\n\t\t\t// it's an operator or a tag. We save a copy of otag since the\n\t\t\t// tag name is cast to upper-case in regular HTML matches. The\n\t\t\t// system has a global switch to figure out if the current\n\t\t\t// expression needs to be case sensitive or not and it will use\n\t\t\t// otag or tag accordingly\n\t\t\tcurrentPart.otag = currentPart.tag = (currentPart[\"oper\"]) ? null : (currentPart.tag || \"*\");\n\n\t\t\tif(currentPart.tag){\n\t\t\t\t// if we're in a case-insensitive HTML doc, we likely want\n\t\t\t\t// the toUpperCase when matching on element.tagName. If we\n\t\t\t\t// do it here, we can skip the string op per node\n\t\t\t\t// comparison\n\t\t\t\tcurrentPart.tag = currentPart.tag.toUpperCase();\n\t\t\t}\n\n\t\t\t// add the part to the list\n\t\t\tif(queryParts.length && (queryParts[queryParts.length-1].oper)){\n\t\t\t\t// operators are always infix, so we remove them from the\n\t\t\t\t// list and attach them to the next match. The evaluator is\n\t\t\t\t// responsible for sorting out how to handle them.\n\t\t\t\tcurrentPart.infixOper = queryParts.pop();\n\t\t\t\tcurrentPart.query = currentPart.infixOper.query + \" \" + currentPart.query;\n\t\t\t\t/*\n\t\t\t\tconsole.debug(\t\"swapping out the infix\",\n\t\t\t\t\t\t\t\tcurrentPart.infixOper,\n\t\t\t\t\t\t\t\t\"and attaching it to\",\n\t\t\t\t\t\t\t\tcurrentPart);\n\t\t\t\t*/\n\t\t\t}\n\t\t\tqueryParts.push(currentPart);\n\n\t\t\tcurrentPart = null;\n\t\t};\n\n\t\t// iterate over the query, character by character, building up a\n\t\t// list of query part objects\n\t\tfor(; lc=cc, cc=query.charAt(x), x < ql; x++){\n\t\t\t//\t\tcc: the current character in the match\n\t\t\t//\t\tlc: the last character (if any)\n\n\t\t\t// someone is trying to escape something, so don't try to match any\n\t\t\t// fragments. We assume we're inside a literal.\n\t\t\tif(lc == \"\\\\\"){ continue; }\n\t\t\tif(!currentPart){ // a part was just ended or none has yet been created\n\t\t\t\t// NOTE: I hate all this alloc, but it's shorter than writing tons of if's\n\t\t\t\tpStart = x;\n\t\t\t\t//\trules describe full CSS sub-expressions, like:\n\t\t\t\t//\t\t#someId\n\t\t\t\t//\t\t.className:first-child\n\t\t\t\t//\tbut not:\n\t\t\t\t//\t\tthinger > div.howdy[type=thinger]\n\t\t\t\t//\tthe indidual components of the previous query would be\n\t\t\t\t//\tsplit into 3 parts that would be represented a structure\n\t\t\t\t//\tlike:\n\t\t\t\t//\t\t[\n\t\t\t\t//\t\t\t{\n\t\t\t\t//\t\t\t\tquery: \"thinger\",\n\t\t\t\t//\t\t\t\ttag: \"thinger\",\n\t\t\t\t//\t\t\t},\n\t\t\t\t//\t\t\t{\n\t\t\t\t//\t\t\t\tquery: \"div.howdy[type=thinger]\",\n\t\t\t\t//\t\t\t\tclasses: [\"howdy\"],\n\t\t\t\t//\t\t\t\tinfixOper: {\n\t\t\t\t//\t\t\t\t\tquery: \">\",\n\t\t\t\t//\t\t\t\t\toper: \">\",\n\t\t\t\t//\t\t\t\t}\n\t\t\t\t//\t\t\t},\n\t\t\t\t//\t\t]\n\t\t\t\tcurrentPart = {\n\t\t\t\t\tquery: null, // the full text of the part's rule\n\t\t\t\t\tpseudos: [], // CSS supports multiple pseud-class matches in a single rule\n\t\t\t\t\tattrs: [],\t// CSS supports multi-attribute match, so we need an array\n\t\t\t\t\tclasses: [], // class matches may be additive, e.g.: .thinger.blah.howdy\n\t\t\t\t\ttag: null,\t// only one tag...\n\t\t\t\t\toper: null, // ...or operator per component. Note that these wind up being exclusive.\n\t\t\t\t\tid: null,\t// the id component of a rule\n\t\t\t\t\tgetTag: function(){\n\t\t\t\t\t\treturn (caseSensitive) ? this.otag : this.tag;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// if we don't have a part, we assume we're going to start at\n\t\t\t\t// the beginning of a match, which should be a tag name. This\n\t\t\t\t// might fault a little later on, but we detect that and this\n\t\t\t\t// iteration will still be fine.\n\t\t\t\tinTag = x;\n\t\t\t}\n\n\t\t\tif(inBrackets >= 0){\n\t\t\t\t// look for a the close first\n\t\t\t\tif(cc == \"]\"){ // if we're in a [...] clause and we end, do assignment\n\t\t\t\t\tif(!_cp.attr){\n\t\t\t\t\t\t// no attribute match was previously begun, so we\n\t\t\t\t\t\t// assume this is an attribute existence match in the\n\t\t\t\t\t\t// form of [someAttributeName]\n\t\t\t\t\t\t_cp.attr = ts(inBrackets+1, x);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// we had an attribute already, so we know that we're\n\t\t\t\t\t\t// matching some sort of value, as in [attrName=howdy]\n\t\t\t\t\t\t_cp.matchFor = ts((inMatchFor||inBrackets+1), x);\n\t\t\t\t\t}\n\t\t\t\t\tvar cmf = _cp.matchFor;\n\t\t\t\t\tif(cmf){\n\t\t\t\t\t\t// try to strip quotes from the matchFor value. We want\n\t\t\t\t\t\t// [attrName=howdy] to match the same\n\t\t\t\t\t\t//\tas [attrName = 'howdy' ]\n\t\t\t\t\t\tif(\t(cmf.charAt(0) == '\"') || (cmf.charAt(0) == \"'\") ){\n\t\t\t\t\t\t\t_cp.matchFor = cmf.slice(1, -1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// end the attribute by adding it to the list of attributes.\n\t\t\t\t\tcurrentPart.attrs.push(_cp);\n\t\t\t\t\t_cp = null; // necessary?\n\t\t\t\t\tinBrackets = inMatchFor = -1;\n\t\t\t\t}else if(cc == \"=\"){\n\t\t\t\t\t// if the last char was an operator prefix, make sure we\n\t\t\t\t\t// record it along with the \"=\" operator.\n\t\t\t\t\tvar addToCc = (\"|~^$*\".indexOf(lc) >=0 ) ? lc : \"\";\n\t\t\t\t\t_cp.type = addToCc+cc;\n\t\t\t\t\t_cp.attr = ts(inBrackets+1, x-addToCc.length);\n\t\t\t\t\tinMatchFor = x+1;\n\t\t\t\t}\n\t\t\t\t// now look for other clause parts\n\t\t\t}else if(inParens >= 0){\n\t\t\t\t// if we're in a parenthetical expression, we need to figure\n\t\t\t\t// out if it's attached to a pseudo-selector rule like\n\t\t\t\t// :nth-child(1)\n\t\t\t\tif(cc == \")\"){\n\t\t\t\t\tif(inPseudo >= 0){\n\t\t\t\t\t\t_cp.value = ts(inParens+1, x);\n\t\t\t\t\t}\n\t\t\t\t\tinPseudo = inParens = -1;\n\t\t\t\t}\n\t\t\t}else if(cc == \"#\"){\n\t\t\t\t// start of an ID match\n\t\t\t\tendAll();\n\t\t\t\tinId = x+1;\n\t\t\t}else if(cc == \".\"){\n\t\t\t\t// start of a class match\n\t\t\t\tendAll();\n\t\t\t\tinClass = x;\n\t\t\t}else if(cc == \":\"){\n\t\t\t\t// start of a pseudo-selector match\n\t\t\t\tendAll();\n\t\t\t\tinPseudo = x;\n\t\t\t}else if(cc == \"[\"){\n\t\t\t\t// start of an attribute match.\n\t\t\t\tendAll();\n\t\t\t\tinBrackets = x;\n\t\t\t\t// provide a new structure for the attribute match to fill-in\n\t\t\t\t_cp = {\n\t\t\t\t\t/*=====\n\t\t\t\t\tattr: null, type: null, matchFor: null\n\t\t\t\t\t=====*/\n\t\t\t\t};\n\t\t\t}else if(cc == \"(\"){\n\t\t\t\t// we really only care if we've entered a parenthetical\n\t\t\t\t// expression if we're already inside a pseudo-selector match\n\t\t\t\tif(inPseudo >= 0){\n\t\t\t\t\t// provide a new structure for the pseudo match to fill-in\n\t\t\t\t\t_cp = {\n\t\t\t\t\t\tname: ts(inPseudo+1, x),\n\t\t\t\t\t\tvalue: null\n\t\t\t\t\t};\n\t\t\t\t\tcurrentPart.pseudos.push(_cp);\n\t\t\t\t}\n\t\t\t\tinParens = x;\n\t\t\t}else if(\n\t\t\t\t(cc == \" \") &&\n\t\t\t\t// if it's a space char and the last char is too, consume the\n\t\t\t\t// current one without doing more work\n\t\t\t\t(lc != cc)\n\t\t\t){\n\t\t\t\tendPart();\n\t\t\t}\n\t\t}\n\t\treturn queryParts;\n\t};\n\n\n\t////////////////////////////////////////////////////////////////////////\n\t// DOM query infrastructure\n\t////////////////////////////////////////////////////////////////////////\n\n\tvar agree = function(first, second){\n\t\t// the basic building block of the yes/no chaining system. agree(f1,\n\t\t// f2) generates a new function which returns the boolean results of\n\t\t// both of the passed functions to a single logical-anded result. If\n\t\t// either are not passed, the other is used exclusively.\n\t\tif(!first){ return second; }\n\t\tif(!second){ return first; }\n\n\t\treturn function(){\n\t\t\treturn first.apply(window, arguments) && second.apply(window, arguments);\n\t\t}\n\t};\n\n\tvar getArr = function(i, arr){\n\t\t// helps us avoid array alloc when we don't need it\n\t\tvar r = arr||[]; // FIXME: should this be 'new d._NodeListCtor()' ?\n\t\tif(i){ r.push(i); }\n\t\treturn r;\n\t};\n\n\tvar _isElement = function(n){ return (1 == n.nodeType); };\n\n\t// FIXME: need to coalesce _getAttr with defaultGetter\n\tvar blank = \"\";\n\tvar _getAttr = function(elem, attr){\n\t\tif(!elem){ return blank; }\n\t\tif(attr == \"class\"){\n\t\t\treturn elem.className || blank;\n\t\t}\n\t\tif(attr == \"for\"){\n\t\t\treturn elem.htmlFor || blank;\n\t\t}\n\t\tif(attr == \"style\"){\n\t\t\treturn elem.style.cssText || blank;\n\t\t}\n\t\treturn (caseSensitive ? elem.getAttribute(attr) : elem.getAttribute(attr, 2)) || blank;\n\t};\n\n\tvar attrs = {\n\t\t\"*=\": function(attr, value){\n\t\t\treturn function(elem){\n\t\t\t\t// E[foo*=\"bar\"]\n\t\t\t\t//\t\tan E element whose \"foo\" attribute value contains\n\t\t\t\t//\t\tthe substring \"bar\"\n\t\t\t\treturn (_getAttr(elem, attr).indexOf(value)>=0);\n\t\t\t}\n\t\t},\n\t\t\"^=\": function(attr, value){\n\t\t\t// E[foo^=\"bar\"]\n\t\t\t//\t\tan E element whose \"foo\" attribute value begins exactly\n\t\t\t//\t\twith the string \"bar\"\n\t\t\treturn function(elem){\n\t\t\t\treturn (_getAttr(elem, attr).indexOf(value)==0);\n\t\t\t}\n\t\t},\n\t\t\"$=\": function(attr, value){\n\t\t\t// E[foo$=\"bar\"]\n\t\t\t//\t\tan E element whose \"foo\" attribute value ends exactly\n\t\t\t//\t\twith the string \"bar\"\n\t\t\treturn function(elem){\n\t\t\t\tvar ea = \" \"+_getAttr(elem, attr);\n\t\t\t\treturn (ea.lastIndexOf(value)==(ea.length-value.length));\n\t\t\t}\n\t\t},\n\t\t\"~=\": function(attr, value){\n\t\t\t// E[foo~=\"bar\"]\n\t\t\t//\t\tan E element whose \"foo\" attribute value is a list of\n\t\t\t//\t\tspace-separated values, one of which is exactly equal\n\t\t\t//\t\tto \"bar\"\n\n\t\t\t// return \"[contains(concat(' ',@\"+attr+\",' '), ' \"+ value +\" ')]\";\n\t\t\tvar tval = \" \"+value+\" \";\n\t\t\treturn function(elem){\n\t\t\t\tvar ea = \" \"+_getAttr(elem, attr)+\" \";\n\t\t\t\treturn (ea.indexOf(tval)>=0);\n\t\t\t}\n\t\t},\n\t\t\"|=\": function(attr, value){\n\t\t\t// E[hreflang|=\"en\"]\n\t\t\t//\t\tan E element whose \"hreflang\" attribute has a\n\t\t\t//\t\thyphen-separated list of values beginning (from the\n\t\t\t//\t\tleft) with \"en\"\n\t\t\tvar valueDash = value+\"-\";\n\t\t\treturn function(elem){\n\t\t\t\tvar ea = _getAttr(elem, attr);\n\t\t\t\treturn (\n\t\t\t\t\t(ea == value) ||\n\t\t\t\t\t(ea.indexOf(valueDash)==0)\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\t\t\"=\": function(attr, value){\n\t\t\treturn function(elem){\n\t\t\t\treturn (_getAttr(elem, attr) == value);\n\t\t\t}\n\t\t}\n\t};\n\n\t// avoid testing for node type if we can. Defining this in the negative\n\t// here to avoid negation in the fast path.\n\tvar _noNES = (typeof getDoc().firstChild.nextElementSibling == \"undefined\");\n\tvar _ns = !_noNES ? \"nextElementSibling\" : \"nextSibling\";\n\tvar _ps = !_noNES ? \"previousElementSibling\" : \"previousSibling\";\n\tvar _simpleNodeTest = (_noNES ? _isElement : yesman);\n\n\tvar _lookLeft = function(node){\n\t\t// look left\n\t\twhile(node = node[_ps]){\n\t\t\tif(_simpleNodeTest(node)){ return false; }\n\t\t}\n\t\treturn true;\n\t};\n\n\tvar _lookRight = function(node){\n\t\t// look right\n\t\twhile(node = node[_ns]){\n\t\t\tif(_simpleNodeTest(node)){ return false; }\n\t\t}\n\t\treturn true;\n\t};\n\n\tvar getNodeIndex = function(node){\n\t\tvar root = node.parentNode;\n\t\tvar i = 0,\n\t\t\ttret = root.children || root.childNodes,\n\t\t\tci = (node[\"_i\"]||-1),\n\t\t\tcl = (root[\"_l\"]||-1);\n\n\t\tif(!tret){ return -1; }\n\t\tvar l = tret.length;\n\n\t\t// we calculate the parent length as a cheap way to invalidate the\n\t\t// cache. It's not 100% accurate, but it's much more honest than what\n\t\t// other libraries do\n\t\tif( cl == l && ci >= 0 && cl >= 0 ){\n\t\t\t// if it's legit, tag and release\n\t\t\treturn ci;\n\t\t}\n\n\t\t// else re-key things\n\t\troot[\"_l\"] = l;\n\t\tci = -1;\n\t\tfor(var te = root[\"firstElementChild\"]||root[\"firstChild\"]; te; te = te[_ns]){\n\t\t\tif(_simpleNodeTest(te)){\n\t\t\t\tte[\"_i\"] = ++i;\n\t\t\t\tif(node === te){\n\t\t\t\t\t// NOTE:\n\t\t\t\t\t//\tshortcutting the return at this step in indexing works\n\t\t\t\t\t//\tvery well for benchmarking but we avoid it here since\n\t\t\t\t\t//\tit leads to potential O(n^2) behavior in sequential\n\t\t\t\t\t//\tgetNodexIndex operations on a previously un-indexed\n\t\t\t\t\t//\tparent. We may revisit this at a later time, but for\n\t\t\t\t\t//\tnow we just want to get the right answer more often\n\t\t\t\t\t//\tthan not.\n\t\t\t\t\tci = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ci;\n\t};\n\n\tvar isEven = function(elem){\n\t\treturn !((getNodeIndex(elem)) % 2);\n\t};\n\n\tvar isOdd = function(elem){\n\t\treturn ((getNodeIndex(elem)) % 2);\n\t};\n\n\tvar pseudos = {\n\t\t\"checked\": function(name, condition){\n\t\t\treturn function(elem){\n\t\t\t\treturn !!(\"checked\" in elem ? elem.checked : elem.selected);\n\t\t\t}\n\t\t},\n\t\t\"first-child\": function(){ return _lookLeft; },\n\t\t\"last-child\": function(){ return _lookRight; },\n\t\t\"only-child\": function(name, condition){\n\t\t\treturn function(node){\n\t\t\t\treturn _lookLeft(node) && _lookRight(node);\n\t\t\t};\n\t\t},\n\t\t\"empty\": function(name, condition){\n\t\t\treturn function(elem){\n\t\t\t\t// DomQuery and jQuery get this wrong, oddly enough.\n\t\t\t\t// The CSS 3 selectors spec is pretty explicit about it, too.\n\t\t\t\tvar cn = elem.childNodes;\n\t\t\t\tvar cnl = elem.childNodes.length;\n\t\t\t\t// if(!cnl){ return true; }\n\t\t\t\tfor(var x=cnl-1; x >= 0; x--){\n\t\t\t\t\tvar nt = cn[x].nodeType;\n\t\t\t\t\tif((nt === 1)||(nt == 3)){ return false; }\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\t\"contains\": function(name, condition){\n\t\t\tvar cz = condition.charAt(0);\n\t\t\tif( cz == '\"' || cz == \"'\" ){ //remove quote\n\t\t\t\tcondition = condition.slice(1, -1);\n\t\t\t}\n\t\t\treturn function(elem){\n\t\t\t\treturn (elem.innerHTML.indexOf(condition) >= 0);\n\t\t\t}\n\t\t},\n\t\t\"not\": function(name, condition){\n\t\t\tvar p = getQueryParts(condition)[0];\n\t\t\tvar ignores = { el: 1 };\n\t\t\tif(p.tag != \"*\"){\n\t\t\t\tignores.tag = 1;\n\t\t\t}\n\t\t\tif(!p.classes.length){\n\t\t\t\tignores.classes = 1;\n\t\t\t}\n\t\t\tvar ntf = getSimpleFilterFunc(p, ignores);\n\t\t\treturn function(elem){\n\t\t\t\treturn (!ntf(elem));\n\t\t\t}\n\t\t},\n\t\t\"nth-child\": function(name, condition){\n\t\t\tvar pi = parseInt;\n\t\t\t// avoid re-defining function objects if we can\n\t\t\tif(condition == \"odd\"){\n\t\t\t\treturn isOdd;\n\t\t\t}else if(condition == \"even\"){\n\t\t\t\treturn isEven;\n\t\t\t}\n\t\t\t// FIXME: can we shorten this?\n\t\t\tif(condition.indexOf(\"n\") != -1){\n\t\t\t\tvar tparts = condition.split(\"n\", 2);\n\t\t\t\tvar pred = tparts[0] ? ((tparts[0] == '-') ? -1 : pi(tparts[0])) : 1;\n\t\t\t\tvar idx = tparts[1] ? pi(tparts[1]) : 0;\n\t\t\t\tvar lb = 0, ub = -1;\n\t\t\t\tif(pred > 0){\n\t\t\t\t\tif(idx < 0){\n\t\t\t\t\t\tidx = (idx % pred) && (pred + (idx % pred));\n\t\t\t\t\t}else if(idx>0){\n\t\t\t\t\t\tif(idx >= pred){\n\t\t\t\t\t\t\tlb = idx - idx % pred;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tidx = idx % pred;\n\t\t\t\t\t}\n\t\t\t\t}else if(pred<0){\n\t\t\t\t\tpred *= -1;\n\t\t\t\t\t// idx has to be greater than 0 when pred is negative;\n\t\t\t\t\t// shall we throw an error here?\n\t\t\t\t\tif(idx > 0){\n\t\t\t\t\t\tub = idx;\n\t\t\t\t\t\tidx = idx % pred;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(pred > 0){\n\t\t\t\t\treturn function(elem){\n\t\t\t\t\t\tvar i = getNodeIndex(elem);\n\t\t\t\t\t\treturn (i>=lb) && (ub<0 || i<=ub) && ((i % pred) == idx);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tcondition = idx;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar ncount = pi(condition);\n\t\t\treturn function(elem){\n\t\t\t\treturn (getNodeIndex(elem) == ncount);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar defaultGetter = (dojo.isIE && (dojo.isIE < 9 || dojo.isQuirks)) ? function(cond){\n\t\tvar clc = cond.toLowerCase();\n\t\tif(clc == \"class\"){ cond = \"className\"; }\n\t\treturn function(elem){\n\t\t\treturn (caseSensitive ? elem.getAttribute(cond) : elem[cond]||elem[clc]);\n\t\t}\n\t} : function(cond){\n\t\treturn function(elem){\n\t\t\treturn (elem && elem.getAttribute && elem.hasAttribute(cond));\n\t\t}\n\t};\n\n\tvar getSimpleFilterFunc = function(query, ignores){\n\t\t// generates a node tester function based on the passed query part. The\n\t\t// query part is one of the structures generated by the query parser\n\t\t// when it creates the query AST. The \"ignores\" object specifies which\n\t\t// (if any) tests to skip, allowing the system to avoid duplicating\n\t\t// work where it may have already been taken into account by other\n\t\t// factors such as how the nodes to test were fetched in the first\n\t\t// place\n\t\tif(!query){ return yesman; }\n\t\tignores = ignores||{};\n\n\t\tvar ff = null;\n\n\t\tif(!(\"el\" in ignores)){\n\t\t\tff = agree(ff, _isElement);\n\t\t}\n\n\t\tif(!(\"tag\" in ignores)){\n\t\t\tif(query.tag != \"*\"){\n\t\t\t\tff = agree(ff, function(elem){\n\t\t\t\t\treturn (elem && (elem.tagName == query.getTag()));\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif(!(\"classes\" in ignores)){\n\t\t\teach(query.classes, function(cname, idx, arr){\n\t\t\t\t// get the class name\n\t\t\t\t/*\n\t\t\t\tvar isWildcard = cname.charAt(cname.length-1) == \"*\";\n\t\t\t\tif(isWildcard){\n\t\t\t\t\tcname = cname.substr(0, cname.length-1);\n\t\t\t\t}\n\t\t\t\t// I dislike the regex thing, even if memoized in a cache, but it's VERY short\n\t\t\t\tvar re = new RegExp(\"(?:^|\\\\s)\" + cname + (isWildcard ? \".*\" : \"\") + \"(?:\\\\s|$)\");\n\t\t\t\t*/\n\t\t\t\tvar re = new RegExp(\"(?:^|\\\\s)\" + cname + \"(?:\\\\s|$)\");\n\t\t\t\tff = agree(ff, function(elem){\n\t\t\t\t\treturn re.test(elem.className);\n\t\t\t\t});\n\t\t\t\tff.count = idx;\n\t\t\t});\n\t\t}\n\n\t\tif(!(\"pseudos\" in ignores)){\n\t\t\teach(query.pseudos, function(pseudo){\n\t\t\t\tvar pn = pseudo.name;\n\t\t\t\tif(pseudos[pn]){\n\t\t\t\t\tff = agree(ff, pseudos[pn](pn, pseudo.value));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif(!(\"attrs\" in ignores)){\n\t\t\teach(query.attrs, function(attr){\n\t\t\t\tvar matcher;\n\t\t\t\tvar a = attr.attr;\n\t\t\t\t// type, attr, matchFor\n\t\t\t\tif(attr.type && attrs[attr.type]){\n\t\t\t\t\tmatcher = attrs[attr.type](a, attr.matchFor);\n\t\t\t\t}else if(a.length){\n\t\t\t\t\tmatcher = defaultGetter(a);\n\t\t\t\t}\n\t\t\t\tif(matcher){\n\t\t\t\t\tff = agree(ff, matcher);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif(!(\"id\" in ignores)){\n\t\t\tif(query.id){\n\t\t\t\tff = agree(ff, function(elem){\n\t\t\t\t\treturn (!!elem && (elem.id == query.id));\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif(!ff){\n\t\t\tif(!(\"default\" in ignores)){\n\t\t\t\tff = yesman;\n\t\t\t}\n\t\t}\n\t\treturn ff;\n\t};\n\n\tvar _nextSibling = function(filterFunc){\n\t\treturn function(node, ret, bag){\n\t\t\twhile(node = node[_ns]){\n\t\t\t\tif(_noNES && (!_isElement(node))){ continue; }\n\t\t\t\tif(\n\t\t\t\t\t(!bag || _isUnique(node, bag)) &&\n\t\t\t\t\tfilterFunc(node)\n\t\t\t\t){\n\t\t\t\t\tret.push(node);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n\n\tvar _nextSiblings = function(filterFunc){\n\t\treturn function(root, ret, bag){\n\t\t\tvar te = root[_ns];\n\t\t\twhile(te){\n\t\t\t\tif(_simpleNodeTest(te)){\n\t\t\t\t\tif(bag && !_isUnique(te, bag)){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(filterFunc(te)){\n\t\t\t\t\t\tret.push(te);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tte = te[_ns];\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n\n\t// get an array of child *elements*, skipping text and comment nodes\n\tvar _childElements = function(filterFunc){\n\t\tfilterFunc = filterFunc||yesman;\n\t\treturn function(root, ret, bag){\n\t\t\t// get an array of child elements, skipping text and comment nodes\n\t\t\tvar te, x = 0, tret = root.children || root.childNodes;\n\t\t\twhile(te = tret[x++]){\n\t\t\t\tif(\n\t\t\t\t\t_simpleNodeTest(te) &&\n\t\t\t\t\t(!bag || _isUnique(te, bag)) &&\n\t\t\t\t\t(filterFunc(te, x))\n\t\t\t\t){\n\t\t\t\t\tret.push(te);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t};\n\n\t/*\n\t// thanks, Dean!\n\tvar itemIsAfterRoot = d.isIE ? function(item, root){\n\t\treturn (item.sourceIndex > root.sourceIndex);\n\t} : function(item, root){\n\t\treturn (item.compareDocumentPosition(root) == 2);\n\t};\n\t*/\n\n\t// test to see if node is below root\n\tvar _isDescendant = function(node, root){\n\t\tvar pn = node.parentNode;\n\t\twhile(pn){\n\t\t\tif(pn == root){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpn = pn.parentNode;\n\t\t}\n\t\treturn !!pn;\n\t};\n\n\tvar _getElementsFuncCache = {};\n\n\tvar getElementsFunc = function(query){\n\t\tvar retFunc = _getElementsFuncCache[query.query];\n\t\t// if we've got a cached dispatcher, just use that\n\t\tif(retFunc){ return retFunc; }\n\t\t// else, generate a new on\n\n\t\t// NOTE:\n\t\t//\t\tthis function returns a function that searches for nodes and\n\t\t//\t\tfilters them.  The search may be specialized by infix operators\n\t\t//\t\t(\">\", \"~\", or \"+\") else it will default to searching all\n\t\t//\t\tdescendants (the \" \" selector). Once a group of children is\n\t\t//\t\tfound, a test function is applied to weed out the ones we\n\t\t//\t\tdon't want. Many common cases can be fast-pathed. We spend a\n\t\t//\t\tlot of cycles to create a dispatcher that doesn't do more work\n\t\t//\t\tthan necessary at any point since, unlike this function, the\n\t\t//\t\tdispatchers will be called every time. The logic of generating\n\t\t//\t\tefficient dispatchers looks like this in pseudo code:\n\t\t//\n\t\t//\t\t# if it's a purely descendant query (no \">\", \"+\", or \"~\" modifiers)\n\t\t//\t\tif infixOperator == \" \":\n\t\t//\t\t\tif only(id):\n\t\t//\t\t\t\treturn def(root):\n\t\t//\t\t\t\t\treturn d.byId(id, root);\n\t\t//\n\t\t//\t\t\telif id:\n\t\t//\t\t\t\treturn def(root):\n\t\t//\t\t\t\t\treturn filter(d.byId(id, root));\n\t\t//\n\t\t//\t\t\telif cssClass && getElementsByClassName:\n\t\t//\t\t\t\treturn def(root):\n\t\t//\t\t\t\t\treturn filter(root.getElementsByClassName(cssClass));\n\t\t//\n\t\t//\t\t\telif only(tag):\n\t\t//\t\t\t\treturn def(root):\n\t\t//\t\t\t\t\treturn root.getElementsByTagName(tagName);\n\t\t//\n\t\t//\t\t\telse:\n\t\t//\t\t\t\t# search by tag name, then filter\n\t\t//\t\t\t\treturn def(root):\n\t\t//\t\t\t\t\treturn filter(root.getElementsByTagName(tagName||\"*\"));\n\t\t//\n\t\t//\t\telif infixOperator == \">\":\n\t\t//\t\t\t# search direct children\n\t\t//\t\t\treturn def(root):\n\t\t//\t\t\t\treturn filter(root.children);\n\t\t//\n\t\t//\t\telif infixOperator == \"+\":\n\t\t//\t\t\t# search next sibling\n\t\t//\t\t\treturn def(root):\n\t\t//\t\t\t\treturn filter(root.nextElementSibling);\n\t\t//\n\t\t//\t\telif infixOperator == \"~\":\n\t\t//\t\t\t# search rightward siblings\n\t\t//\t\t\treturn def(root):\n\t\t//\t\t\t\treturn filter(nextSiblings(root));\n\n\t\tvar io = query.infixOper;\n\t\tvar oper = (io ? io.oper : \"\");\n\t\t// the default filter func which tests for all conditions in the query\n\t\t// part. This is potentially inefficient, so some optimized paths may\n\t\t// re-define it to test fewer things.\n\t\tvar filterFunc = getSimpleFilterFunc(query, { el: 1 });\n\t\tvar qt = query.tag;\n\t\tvar wildcardTag = (\"*\" == qt);\n\t\tvar ecs = getDoc()[\"getElementsByClassName\"];\n\n\t\tif(!oper){\n\t\t\t// if there's no infix operator, then it's a descendant query. ID\n\t\t\t// and \"elements by class name\" variants can be accelerated so we\n\t\t\t// call them out explicitly:\n\t\t\tif(query.id){\n\t\t\t\t// testing shows that the overhead of yesman() is acceptable\n\t\t\t\t// and can save us some bytes vs. re-defining the function\n\t\t\t\t// everywhere.\n\t\t\t\tfilterFunc = (!query.loops && wildcardTag) ?\n\t\t\t\t\tyesman :\n\t\t\t\t\tgetSimpleFilterFunc(query, { el: 1, id: 1 });\n\n\t\t\t\tretFunc = function(root, arr){\n\t\t\t\t\tvar te = dom.byId(query.id, (root.ownerDocument||root));\n\t\t\t\t\tif(!te || !filterFunc(te)){ return; }\n\t\t\t\t\tif(9 == root.nodeType){ // if root's a doc, we just return directly\n\t\t\t\t\t\treturn getArr(te, arr);\n\t\t\t\t\t}else{ // otherwise check ancestry\n\t\t\t\t\t\tif(_isDescendant(te, root)){\n\t\t\t\t\t\t\treturn getArr(te, arr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(\n\t\t\t\tecs &&\n\t\t\t\t// isAlien check. Workaround for Prototype.js being totally evil/dumb.\n\t\t\t\t/\\{\\s*\\[native code\\]\\s*\\}/.test(String(ecs)) &&\n\t\t\t\tquery.classes.length &&\n\t\t\t\t!cssCaseBug\n\t\t\t){\n\t\t\t\t// it's a class-based query and we've got a fast way to run it.\n\n\t\t\t\t// ignore class and ID filters since we will have handled both\n\t\t\t\tfilterFunc = getSimpleFilterFunc(query, { el: 1, classes: 1, id: 1 });\n\t\t\t\tvar classesString = query.classes.join(\" \");\n\t\t\t\tretFunc = function(root, arr, bag){\n\t\t\t\t\tvar ret = getArr(0, arr), te, x=0;\n\t\t\t\t\tvar tret = root.getElementsByClassName(classesString);\n\t\t\t\t\twhile((te = tret[x++])){\n\t\t\t\t\t\tif(filterFunc(te, root) && _isUnique(te, bag)){\n\t\t\t\t\t\t\tret.push(te);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t};\n\n\t\t\t}else if(!wildcardTag && !query.loops){\n\t\t\t\t// it's tag only. Fast-path it.\n\t\t\t\tretFunc = function(root, arr, bag){\n\t\t\t\t\tvar ret = getArr(0, arr), te, x=0;\n\t\t\t\t\tvar tret = root.getElementsByTagName(query.getTag());\n\t\t\t\t\twhile((te = tret[x++])){\n\t\t\t\t\t\tif(_isUnique(te, bag)){\n\t\t\t\t\t\t\tret.push(te);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t};\n\t\t\t}else{\n\t\t\t\t// the common case:\n\t\t\t\t//\t\ta descendant selector without a fast path. By now it's got\n\t\t\t\t//\t\tto have a tag selector, even if it's just \"*\" so we query\n\t\t\t\t//\t\tby that and filter\n\t\t\t\tfilterFunc = getSimpleFilterFunc(query, { el: 1, tag: 1, id: 1 });\n\t\t\t\tretFunc = function(root, arr, bag){\n\t\t\t\t\tvar ret = getArr(0, arr), te, x=0;\n\t\t\t\t\t// we use getTag() to avoid case sensitivity issues\n\t\t\t\t\tvar tret = root.getElementsByTagName(query.getTag());\n\t\t\t\t\twhile((te = tret[x++])){\n\t\t\t\t\t\tif(filterFunc(te, root) && _isUnique(te, bag)){\n\t\t\t\t\t\t\tret.push(te);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t};\n\t\t\t}\n\t\t}else{\n\t\t\t// the query is scoped in some way. Instead of querying by tag we\n\t\t\t// use some other collection to find candidate nodes\n\t\t\tvar skipFilters = { el: 1 };\n\t\t\tif(wildcardTag){\n\t\t\t\tskipFilters.tag = 1;\n\t\t\t}\n\t\t\tfilterFunc = getSimpleFilterFunc(query, skipFilters);\n\t\t\tif(\"+\" == oper){\n\t\t\t\tretFunc = _nextSibling(filterFunc);\n\t\t\t}else if(\"~\" == oper){\n\t\t\t\tretFunc = _nextSiblings(filterFunc);\n\t\t\t}else if(\">\" == oper){\n\t\t\t\tretFunc = _childElements(filterFunc);\n\t\t\t}\n\t\t}\n\t\t// cache it and return\n\t\treturn _getElementsFuncCache[query.query] = retFunc;\n\t};\n\n\tvar filterDown = function(root, queryParts){\n\t\t// NOTE:\n\t\t//\t\tthis is the guts of the DOM query system. It takes a list of\n\t\t//\t\tparsed query parts and a root and finds children which match\n\t\t//\t\tthe selector represented by the parts\n\t\tvar candidates = getArr(root), qp, x, te, qpl = queryParts.length, bag, ret;\n\n\t\tfor(var i = 0; i < qpl; i++){\n\t\t\tret = [];\n\t\t\tqp = queryParts[i];\n\t\t\tx = candidates.length - 1;\n\t\t\tif(x > 0){\n\t\t\t\t// if we have more than one root at this level, provide a new\n\t\t\t\t// hash to use for checking group membership but tell the\n\t\t\t\t// system not to post-filter us since we will already have been\n\t\t\t\t// gauranteed to be unique\n\t\t\t\tbag = {};\n\t\t\t\tret.nozip = true;\n\t\t\t}\n\t\t\tvar gef = getElementsFunc(qp);\n\t\t\tfor(var j = 0; (te = candidates[j]); j++){\n\t\t\t\t// for every root, get the elements that match the descendant\n\t\t\t\t// selector, adding them to the \"ret\" array and filtering them\n\t\t\t\t// via membership in this level's bag. If there are more query\n\t\t\t\t// parts, then this level's return will be used as the next\n\t\t\t\t// level's candidates\n\t\t\t\tgef(te, ret, bag);\n\t\t\t}\n\t\t\tif(!ret.length){ break; }\n\t\t\tcandidates = ret;\n\t\t}\n\t\treturn ret;\n\t};\n\n\t////////////////////////////////////////////////////////////////////////\n\t// the query runner\n\t////////////////////////////////////////////////////////////////////////\n\n\t// these are the primary caches for full-query results. The query\n\t// dispatcher functions are generated then stored here for hash lookup in\n\t// the future\n\tvar _queryFuncCacheDOM = {},\n\t\t_queryFuncCacheQSA = {};\n\n\t// this is the second level of spliting, from full-length queries (e.g.,\n\t// \"div.foo .bar\") into simple query expressions (e.g., [\"div.foo\",\n\t// \".bar\"])\n\tvar getStepQueryFunc = function(query){\n\t\tvar qparts = getQueryParts(trim(query));\n\n\t\t// if it's trivial, avoid iteration and zipping costs\n\t\tif(qparts.length == 1){\n\t\t\t// we optimize this case here to prevent dispatch further down the\n\t\t\t// chain, potentially slowing things down. We could more elegantly\n\t\t\t// handle this in filterDown(), but it's slower for simple things\n\t\t\t// that need to be fast (e.g., \"#someId\").\n\t\t\tvar tef = getElementsFunc(qparts[0]);\n\t\t\treturn function(root){\n\t\t\t\tvar r = tef(root, []);\n\t\t\t\tif(r){ r.nozip = true; }\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\t// otherwise, break it up and return a runner that iterates over the parts recursively\n\t\treturn function(root){\n\t\t\treturn filterDown(root, qparts);\n\t\t}\n\t};\n\n\t// NOTES:\n\t//\t* we can't trust QSA for anything but document-rooted queries, so\n\t//\t  caching is split into DOM query evaluators and QSA query evaluators\n\t//\t* caching query results is dirty and leak-prone (or, at a minimum,\n\t//\t  prone to unbounded growth). Other toolkits may go this route, but\n\t//\t  they totally destroy their own ability to manage their memory\n\t//\t  footprint. If we implement it, it should only ever be with a fixed\n\t//\t  total element reference # limit and an LRU-style algorithm since JS\n\t//\t  has no weakref support. Caching compiled query evaluators is also\n\t//\t  potentially problematic, but even on large documents the size of the\n\t//\t  query evaluators is often < 100 function objects per evaluator (and\n\t//\t  LRU can be applied if it's ever shown to be an issue).\n\t//\t* since IE's QSA support is currently only for HTML documents and even\n\t//\t  then only in IE 8's \"standards mode\", we have to detect our dispatch\n\t//\t  route at query time and keep 2 separate caches. Ugg.\n\n\t// we need to determine if we think we can run a given query via\n\t// querySelectorAll or if we'll need to fall back on DOM queries to get\n\t// there. We need a lot of information about the environment and the query\n\t// to make the determiniation (e.g. does it support QSA, does the query in\n\t// question work in the native QSA impl, etc.).\n\tvar nua = navigator.userAgent;\n\t// some versions of Safari provided QSA, but it was buggy and crash-prone.\n\t// We need te detect the right \"internal\" webkit version to make this work.\n\tvar wk = \"WebKit/\";\n\tvar is525 = (\n\t\tdojo.isWebKit &&\n\t\t(nua.indexOf(wk) > 0) &&\n\t\t(parseFloat(nua.split(wk)[1]) > 528)\n\t);\n\n\t// IE QSA queries may incorrectly include comment nodes, so we throw the\n\t// zipping function into \"remove\" comments mode instead of the normal \"skip\n\t// it\" which every other QSA-clued browser enjoys\n\tvar noZip = dojo.isIE ? \"commentStrip\" : \"nozip\";\n\n\tvar qsa = \"querySelectorAll\";\n\tvar qsaAvail = (\n\t\t!!getDoc()[qsa] &&\n\t\t// see #5832\n\t\t(!dojo.isSafari || (dojo.isSafari > 3.1) || is525 )\n\t);\n\n\t//Don't bother with n+3 type of matches, IE complains if we modify those.\n\tvar infixSpaceRe = /n\\+\\d|([^ ])?([>~+])([^ =])?/g;\n\tvar infixSpaceFunc = function(match, pre, ch, post){\n\t\treturn ch ? (pre ? pre + \" \" : \"\") + ch + (post ? \" \" + post : \"\") : /*n+3*/ match;\n\t};\n\n\tvar getQueryFunc = function(query, forceDOM){\n\t\t//Normalize query. The CSS3 selectors spec allows for omitting spaces around\n\t\t//infix operators, >, ~ and +\n\t\t//Do the work here since detection for spaces is used as a simple \"not use QSA\"\n\t\t//test below.\n\t\tquery = query.replace(infixSpaceRe, infixSpaceFunc);\n\n\t\tif(qsaAvail){\n\t\t\t// if we've got a cached variant and we think we can do it, run it!\n\t\t\tvar qsaCached = _queryFuncCacheQSA[query];\n\t\t\tif(qsaCached && !forceDOM){ return qsaCached; }\n\t\t}\n\n\t\t// else if we've got a DOM cached variant, assume that we already know\n\t\t// all we need to and use it\n\t\tvar domCached = _queryFuncCacheDOM[query];\n\t\tif(domCached){ return domCached; }\n\n\t\t// TODO:\n\t\t//\t\ttoday we're caching DOM and QSA branches separately so we\n\t\t//\t\trecalc useQSA every time. If we had a way to tag root+query\n\t\t//\t\tefficiently, we'd be in good shape to do a global cache.\n\n\t\tvar qcz = query.charAt(0);\n\t\tvar nospace = (-1 == query.indexOf(\" \"));\n\n\t\t// byId searches are wicked fast compared to QSA, even when filtering\n\t\t// is required\n\t\tif( (query.indexOf(\"#\") >= 0) && (nospace) ){\n\t\t\tforceDOM = true;\n\t\t}\n\n\t\tvar useQSA = (\n\t\t\tqsaAvail && (!forceDOM) &&\n\t\t\t// as per CSS 3, we can't currently start w/ combinator:\n\t\t\t//\t\thttp://www.w3.org/TR/css3-selectors/#w3cselgrammar\n\t\t\t(specials.indexOf(qcz) == -1) &&\n\t\t\t// IE's QSA impl sucks on pseudos\n\t\t\t(!dojo.isIE || (query.indexOf(\":\") == -1)) &&\n\n\t\t\t(!(cssCaseBug && (query.indexOf(\".\") >= 0))) &&\n\n\t\t\t// FIXME:\n\t\t\t//\t\tneed to tighten up browser rules on \":contains\" and \"|=\" to\n\t\t\t//\t\tfigure out which aren't good\n\t\t\t//\t\tLatest webkit (around 531.21.8) does not seem to do well with :checked on option\n\t\t\t//\t\telements, even though according to spec, selected options should\n\t\t\t//\t\tmatch :checked. So go nonQSA for it:\n\t\t\t//\t\thttp://bugs.dojotoolkit.org/ticket/5179\n\t\t\t(query.indexOf(\":contains\") == -1) && (query.indexOf(\":checked\") == -1) &&\n\t\t\t(query.indexOf(\"|=\") == -1) // some browsers don't grok it\n\t\t);\n\n\t\t// TODO:\n\t\t//\t\tif we've got a descendant query (e.g., \"> .thinger\" instead of\n\t\t//\t\tjust \".thinger\") in a QSA-able doc, but are passed a child as a\n\t\t//\t\troot, it should be possible to give the item a synthetic ID and\n\t\t//\t\ttrivially rewrite the query to the form \"#synid > .thinger\" to\n\t\t//\t\tuse the QSA branch\n\n\n\t\tif(useQSA){\n\t\t\tvar tq = (specials.indexOf(query.charAt(query.length-1)) >= 0) ?\n\t\t\t\t\t\t(query + \" *\") : query;\n\t\t\treturn _queryFuncCacheQSA[query] = function(root){\n\t\t\t\ttry{\n\t\t\t\t\t// the QSA system contains an egregious spec bug which\n\t\t\t\t\t// limits us, effectively, to only running QSA queries over\n\t\t\t\t\t// entire documents.  See:\n\t\t\t\t\t//\t\thttp://ejohn.org/blog/thoughts-on-queryselectorall/\n\t\t\t\t\t//\tdespite this, we can also handle QSA runs on simple\n\t\t\t\t\t//\tselectors, but we don't want detection to be expensive\n\t\t\t\t\t//\tso we're just checking for the presence of a space char\n\t\t\t\t\t//\tright now. Not elegant, but it's cheaper than running\n\t\t\t\t\t//\tthe query parser when we might not need to\n\t\t\t\t\tif(!((9 == root.nodeType) || nospace)){ throw \"\"; }\n\t\t\t\t\tvar r = root[qsa](tq);\n\t\t\t\t\t// skip expensive duplication checks and just wrap in a NodeList\n\t\t\t\t\tr[noZip] = true;\n\t\t\t\t\treturn r;\n\t\t\t\t}catch(e){\n\t\t\t\t\t// else run the DOM branch on this query, ensuring that we\n\t\t\t\t\t// default that way in the future\n\t\t\t\t\treturn getQueryFunc(query, true)(root);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\t// DOM branch\n\t\t\tvar parts = query.split(/\\s*,\\s*/);\n\t\t\treturn _queryFuncCacheDOM[query] = ((parts.length < 2) ?\n\t\t\t\t// if not a compound query (e.g., \".foo, .bar\"), cache and return a dispatcher\n\t\t\t\tgetStepQueryFunc(query) :\n\t\t\t\t// if it *is* a complex query, break it up into its\n\t\t\t\t// constituent parts and return a dispatcher that will\n\t\t\t\t// merge the parts when run\n\t\t\t\tfunction(root){\n\t\t\t\t\tvar pindex = 0, // avoid array alloc for every invocation\n\t\t\t\t\t\tret = [],\n\t\t\t\t\t\ttp;\n\t\t\t\t\twhile((tp = parts[pindex++])){\n\t\t\t\t\t\tret = ret.concat(getStepQueryFunc(tp)(root));\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t};\n\n\tvar _zipIdx = 0;\n\n\t// NOTE:\n\t//\t\tthis function is Moo inspired, but our own impl to deal correctly\n\t//\t\twith XML in IE\n\tvar _nodeUID = dojo.isIE ? function(node){\n\t\tif(caseSensitive){\n\t\t\t// XML docs don't have uniqueID on their nodes\n\t\t\treturn (node.getAttribute(\"_uid\") || node.setAttribute(\"_uid\", ++_zipIdx) || _zipIdx);\n\n\t\t}else{\n\t\t\treturn node.uniqueID;\n\t\t}\n\t} :\n\tfunction(node){\n\t\treturn (node._uid || (node._uid = ++_zipIdx));\n\t};\n\n\t// determine if a node in is unique in a \"bag\". In this case we don't want\n\t// to flatten a list of unique items, but rather just tell if the item in\n\t// question is already in the bag. Normally we'd just use hash lookup to do\n\t// this for us but IE's DOM is busted so we can't really count on that. On\n\t// the upside, it gives us a built in unique ID function.\n\tvar _isUnique = function(node, bag){\n\t\tif(!bag){ return 1; }\n\t\tvar id = _nodeUID(node);\n\t\tif(!bag[id]){ return bag[id] = 1; }\n\t\treturn 0;\n\t};\n\n\t// attempt to efficiently determine if an item in a list is a dupe,\n\t// returning a list of \"uniques\", hopefully in doucment order\n\tvar _zipIdxName = \"_zipIdx\";\n\tvar _zip = function(arr){\n\t\tif(arr && arr.nozip){\n\t\t\treturn arr;\n\t\t}\n\t\tvar ret = [];\n\t\tif(!arr || !arr.length){ return ret; }\n\t\tif(arr[0]){\n\t\t\tret.push(arr[0]);\n\t\t}\n\t\tif(arr.length < 2){ return ret; }\n\n\t\t_zipIdx++;\n\n\t\t// we have to fork here for IE and XML docs because we can't set\n\t\t// expandos on their nodes (apparently). *sigh*\n\t\tif(dojo.isIE && caseSensitive){\n\t\t\tvar szidx = _zipIdx+\"\";\n\t\t\tarr[0].setAttribute(_zipIdxName, szidx);\n\t\t\tfor(var x = 1, te; te = arr[x]; x++){\n\t\t\t\tif(arr[x].getAttribute(_zipIdxName) != szidx){\n\t\t\t\t\tret.push(te);\n\t\t\t\t}\n\t\t\t\tte.setAttribute(_zipIdxName, szidx);\n\t\t\t}\n\t\t}else if(dojo.isIE && arr.commentStrip){\n\t\t\ttry{\n\t\t\t\tfor(var x = 1, te; te = arr[x]; x++){\n\t\t\t\t\tif(_isElement(te)){\n\t\t\t\t\t\tret.push(te);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}catch(e){ /* squelch */ }\n\t\t}else{\n\t\t\tif(arr[0]){ arr[0][_zipIdxName] = _zipIdx; }\n\t\t\tfor(var x = 1, te; te = arr[x]; x++){\n\t\t\t\tif(arr[x][_zipIdxName] != _zipIdx){\n\t\t\t\t\tret.push(te);\n\t\t\t\t}\n\t\t\t\tte[_zipIdxName] = _zipIdx;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t};\n\n\t// the main executor\n\tvar query = function(/*String*/ query, /*String|DOMNode?*/ root){\n\t\t//\tsummary:\n\t\t//\t\tReturns nodes which match the given CSS3 selector, searching the\n\t\t//\t\tentire document by default but optionally taking a node to scope\n\t\t//\t\tthe search by. Returns an array.\n\t\t//\tdescription:\n\t\t//\t\tdojo.query() is the swiss army knife of DOM node manipulation in\n\t\t//\t\tDojo. Much like Prototype's \"$$\" (bling-bling) function or JQuery's\n\t\t//\t\t\"$\" function, dojo.query provides robust, high-performance\n\t\t//\t\tCSS-based node selector support with the option of scoping searches\n\t\t//\t\tto a particular sub-tree of a document.\n\t\t//\n\t\t//\t\tSupported Selectors:\n\t\t//\t\t--------------------\n\t\t//\n\t\t//\t\tacme supports a rich set of CSS3 selectors, including:\n\t\t//\n\t\t//\t\t\t* class selectors (e.g., `.foo`)\n\t\t//\t\t\t* node type selectors like `span`\n\t\t//\t\t\t* ` ` descendant selectors\n\t\t//\t\t\t* `>` child element selectors\n\t\t//\t\t\t* `#foo` style ID selectors\n\t\t//\t\t\t* `*` universal selector\n\t\t//\t\t\t* `~`, the preceded-by sibling selector\n\t\t//\t\t\t* `+`, the immediately preceded-by sibling selector\n\t\t//\t\t\t* attribute queries:\n\t\t//\t\t\t|\t* `[foo]` attribute presence selector\n\t\t//\t\t\t|\t* `[foo='bar']` attribute value exact match\n\t\t//\t\t\t|\t* `[foo~='bar']` attribute value list item match\n\t\t//\t\t\t|\t* `[foo^='bar']` attribute start match\n\t\t//\t\t\t|\t* `[foo$='bar']` attribute end match\n\t\t//\t\t\t|\t* `[foo*='bar']` attribute substring match\n\t\t//\t\t\t* `:first-child`, `:last-child`, and `:only-child` positional selectors\n\t\t//\t\t\t* `:empty` content emtpy selector\n\t\t//\t\t\t* `:checked` pseudo selector\n\t\t//\t\t\t* `:nth-child(n)`, `:nth-child(2n+1)` style positional calculations\n\t\t//\t\t\t* `:nth-child(even)`, `:nth-child(odd)` positional selectors\n\t\t//\t\t\t* `:not(...)` negation pseudo selectors\n\t\t//\n\t\t//\t\tAny legal combination of these selectors will work with\n\t\t//\t\t`dojo.query()`, including compound selectors (\",\" delimited).\n\t\t//\t\tVery complex and useful searches can be constructed with this\n\t\t//\t\tpalette of selectors and when combined with functions for\n\t\t//\t\tmanipulation presented by dojo.NodeList, many types of DOM\n\t\t//\t\tmanipulation operations become very straightforward.\n\t\t//\n\t\t//\t\tUnsupported Selectors:\n\t\t//\t\t----------------------\n\t\t//\n\t\t//\t\tWhile dojo.query handles many CSS3 selectors, some fall outside of\n\t\t//\t\twhat's reasonable for a programmatic node querying engine to\n\t\t//\t\thandle. Currently unsupported selectors include:\n\t\t//\n\t\t//\t\t\t* namespace-differentiated selectors of any form\n\t\t//\t\t\t* all `::` pseduo-element selectors\n\t\t//\t\t\t* certain pseduo-selectors which don't get a lot of day-to-day use:\n\t\t//\t\t\t|\t* `:root`, `:lang()`, `:target`, `:focus`\n\t\t//\t\t\t* all visual and state selectors:\n\t\t//\t\t\t|\t* `:root`, `:active`, `:hover`, `:visisted`, `:link`,\n\t\t//\t\t\t\t  `:enabled`, `:disabled`\n\t\t//\t\t\t* `:*-of-type` pseudo selectors\n\t\t//\n\t\t//\t\tdojo.query and XML Documents:\n\t\t//\t\t-----------------------------\n\t\t//\n\t\t//\t\t`dojo.query` (as of dojo 1.2) supports searching XML documents\n\t\t//\t\tin a case-sensitive manner. If an HTML document is served with\n\t\t//\t\ta doctype that forces case-sensitivity (e.g., XHTML 1.1\n\t\t//\t\tStrict), dojo.query() will detect this and \"do the right\n\t\t//\t\tthing\". Case sensitivity is dependent upon the document being\n\t\t//\t\tsearched and not the query used. It is therefore possible to\n\t\t//\t\tuse case-sensitive queries on strict sub-documents (iframes,\n\t\t//\t\tetc.) or XML documents while still assuming case-insensitivity\n\t\t//\t\tfor a host/root document.\n\t\t//\n\t\t//\t\tNon-selector Queries:\n\t\t//\t\t---------------------\n\t\t//\n\t\t//\t\tIf something other than a String is passed for the query,\n\t\t//\t\t`dojo.query` will return a new `dojo.NodeList` instance\n\t\t//\t\tconstructed from that parameter alone and all further\n\t\t//\t\tprocessing will stop. This means that if you have a reference\n\t\t//\t\tto a node or NodeList, you can quickly construct a new NodeList\n\t\t//\t\tfrom the original by calling `dojo.query(node)` or\n\t\t//\t\t`dojo.query(list)`.\n\t\t//\n\t\t//\tquery:\n\t\t//\t\tThe CSS3 expression to match against. For details on the syntax of\n\t\t//\t\tCSS3 selectors, see <http://www.w3.org/TR/css3-selectors/#selectors>\n\t\t//\troot:\n\t\t//\t\tA DOMNode (or node id) to scope the search from. Optional.\n\t\t//\treturns: Array\n\t\t//\texample:\n\t\t//\t\tsearch the entire document for elements with the class \"foo\":\n\t\t//\t|\tdojo.query(\".foo\");\n\t\t//\t\tthese elements will match:\n\t\t//\t|\t<span class=\"foo\"></span>\n\t\t//\t|\t<span class=\"foo bar\"></span>\n\t\t//\t|\t<p class=\"thud foo\"></p>\n\t\t//\texample:\n\t\t//\t\tsearch the entire document for elements with the classes \"foo\" *and* \"bar\":\n\t\t//\t|\tdojo.query(\".foo.bar\");\n\t\t//\t\tthese elements will match:\n\t\t//\t|\t<span class=\"foo bar\"></span>\n\t\t//\t\twhile these will not:\n\t\t//\t|\t<span class=\"foo\"></span>\n\t\t//\t|\t<p class=\"thud foo\"></p>\n\t\t//\texample:\n\t\t//\t\tfind `<span>` elements which are descendants of paragraphs and\n\t\t//\t\twhich have a \"highlighted\" class:\n\t\t//\t|\tdojo.query(\"p span.highlighted\");\n\t\t//\t\tthe innermost span in this fragment matches:\n\t\t//\t|\t<p class=\"foo\">\n\t\t//\t|\t\t<span>...\n\t\t//\t|\t\t\t<span class=\"highlighted foo bar\">...</span>\n\t\t//\t|\t\t</span>\n\t\t//\t|\t</p>\n\t\t//\texample:\n\t\t//\t\tset an \"odd\" class on all odd table rows inside of the table\n\t\t//\t\t`#tabular_data`, using the `>` (direct child) selector to avoid\n\t\t//\t\taffecting any nested tables:\n\t\t//\t|\tdojo.query(\"#tabular_data > tbody > tr:nth-child(odd)\").addClass(\"odd\");\n\t\t//\texample:\n\t\t//\t\tremove all elements with the class \"error\" from the document\n\t\t//\t\tand store them in a list:\n\t\t//\t|\tvar errors = dojo.query(\".error\").orphan();\n\t\t//\texample:\n\t\t//\t\tadd an onclick handler to every submit button in the document\n\t\t//\t\twhich causes the form to be sent via Ajax instead:\n\t\t//\t|\tdojo.query(\"input[type='submit']\").onclick(function(e){\n\t\t//\t|\t\tdojo.stopEvent(e); // prevent sending the form\n\t\t//\t|\t\tvar btn = e.target;\n\t\t//\t|\t\tdojo.xhrPost({\n\t\t//\t|\t\t\tform: btn.form,\n\t\t//\t|\t\t\tload: function(data){\n\t\t//\t|\t\t\t\t// replace the form with the response\n\t\t//\t|\t\t\t\tvar div = dojo.doc.createElement(\"div\");\n\t\t//\t|\t\t\t\tdojo.place(div, btn.form, \"after\");\n\t\t//\t|\t\t\t\tdiv.innerHTML = data;\n\t\t//\t|\t\t\t\tdojo.style(btn.form, \"display\", \"none\");\n\t\t//\t|\t\t\t}\n\t\t//\t|\t\t});\n\t\t//\t|\t});\n\n\t\troot = root||getDoc();\n\t\tvar od = root.ownerDocument||root.documentElement;\n\n\t\t// throw the big case sensitivity switch\n\n\t\t// NOTE:\n\t\t//\t\tOpera in XHTML mode doesn't detect case-sensitivity correctly\n\t\t//\t\tand it's not clear that there's any way to test for it\n\t\tcaseSensitive = (root.contentType && root.contentType==\"application/xml\") ||\n\t\t\t\t\t\t(dojo.isOpera && (root.doctype || od.toString() == \"[object XMLDocument]\")) ||\n\t\t\t\t\t\t(!!od) &&\n\t\t\t\t(dojo.isIE ? od.xml : (root.xmlVersion || od.xmlVersion));\n\n\t\t// NOTE:\n\t\t//\t\tadding \"true\" as the 2nd argument to getQueryFunc is useful for\n\t\t//\t\ttesting the DOM branch without worrying about the\n\t\t//\t\tbehavior/performance of the QSA branch.\n\t\tvar r = getQueryFunc(query)(root);\n\n\t\t// FIXME:\n\t\t//\t\tneed to investigate this branch WRT #8074 and #8075\n\t\tif(r && r.nozip){\n\t\t\treturn r;\n\t\t}\n\t\treturn _zip(r); // dojo.NodeList\n\t};\n\tquery.filter = function(/*Node[]*/ nodeList, /*String*/ filter, /*String|DOMNode?*/ root){\n\t\t// summary:\n\t\t// \t\tfunction for filtering a NodeList based on a selector, optimized for simple selectors\n\t\tvar tmpNodeList = [],\n\t\t\tparts = getQueryParts(filter),\n\t\t\tfilterFunc =\n\t\t\t\t(parts.length == 1 && !/[^\\w#\\.]/.test(filter)) ?\n\t\t\t\tgetSimpleFilterFunc(parts[0]) :\n\t\t\t\tfunction(node){\n\t\t\t\t\treturn dojo.query(filter, root).indexOf(node) != -1;\n\t\t\t\t};\n\t\tfor(var x = 0, te; te = nodeList[x]; x++){\n\t\t\tif(filterFunc(te)){ tmpNodeList.push(te); }\n\t\t}\n\t\treturn tmpNodeList;\n\t};\n\treturn query;\n});//end defineQuery\n\n},\n'dojo/dom-style':function(){\ndefine([\"./_base/sniff\", \"./dom\"], function(has, dom){\n\t// module:\n\t//\t\tdojo/dom-style\n\t// summary:\n\t//\t\tThis module defines the core dojo DOM style API.\n\n\t// =============================\n\t// Style Functions\n\t// =============================\n\n\t// getComputedStyle drives most of the style code.\n\t// Wherever possible, reuse the returned object.\n\t//\n\t// API functions below that need to access computed styles accept an\n\t// optional computedStyle parameter.\n\t// If this parameter is omitted, the functions will call getComputedStyle themselves.\n\t// This way, calling code can access computedStyle once, and then pass the reference to\n\t// multiple API functions.\n\n\t/*=====\n\tdojo.getComputedStyle = function(node){\n\t\t// summary:\n\t\t//\t\tReturns a \"computed style\" object.\n\t\t//\n\t\t// description:\n\t\t//\t\tGets a \"computed style\" object which can be used to gather\n\t\t//\t\tinformation about the current state of the rendered node.\n\t\t//\n\t\t//\t\tNote that this may behave differently on different browsers.\n\t\t//\t\tValues may have different formats and value encodings across\n\t\t//\t\tbrowsers.\n\t\t//\n\t\t//\t\tNote also that this method is expensive.  Wherever possible,\n\t\t//\t\treuse the returned object.\n\t\t//\n\t\t//\t\tUse the dojo.style() method for more consistent (pixelized)\n\t\t//\t\treturn values.\n\t\t//\n\t\t// node: DOMNode\n\t\t//\t\tA reference to a DOM node. Does NOT support taking an\n\t\t//\t\tID string for speed reasons.\n\t\t// example:\n\t\t//\t|\tdojo.getComputedStyle(dojo.byId('foo')).borderWidth;\n\t\t//\n\t\t// example:\n\t\t//\t\tReusing the returned object, avoiding multiple lookups:\n\t\t//\t|\tvar cs = dojo.getComputedStyle(dojo.byId(\"someNode\"));\n\t\t//\t|\tvar w = cs.width, h = cs.height;\n\t\treturn; // CSS2Properties\n\t}\n\t=====*/\n\n\t/*=====\n\tdojo.toPixelValue = function(node, value){\n\t\t// summary:\n\t\t//      converts style value to pixels on IE or return a numeric value.\n\t\t// node: DOMNode\n\t\t// value: String\n\t\t// returns: Number\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo._toPixelValue = function(node, value){\n\t\t// summary:\n\t\t//\t\tExisting alias for `dojo._toPixelValue`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.getStyle = function(node, name){\n\t\t// summary:\n\t\t//\t\tAccesses styles on a node.\n\t\t// description:\n\t\t//\t\tGetting the style value uses the computed style for the node, so the value\n\t\t//\t\twill be a calculated value, not just the immediate node.style value.\n\t\t//\t\tAlso when getting values, use specific style names,\n\t\t//\t\tlike \"borderBottomWidth\" instead of \"border\" since compound values like\n\t\t//\t\t\"border\" are not necessarily reflected as expected.\n\t\t//\t\tIf you want to get node dimensions, use `dojo.marginBox()`,\n\t\t//\t\t`dojo.contentBox()` or `dojo.position()`.\n\t\t// node: DOMNode|String\n\t\t//\t\tid or reference to node to get style for\n\t\t// name: String?\n\t\t//\t\tthe style property to get\n\t\t// example:\n\t\t//\t\tPassing only an ID or node returns the computed style object of\n\t\t//\t\tthe node:\n\t\t//\t|\tdojo.getStyle(\"thinger\");\n\t\t// example:\n\t\t//\t\tPassing a node and a style property returns the current\n\t\t//\t\tnormalized, computed value for that property:\n\t\t//\t|\tdojo.getStyle(\"thinger\", \"opacity\"); // 1 by default\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.setStyle = function(node, name, value){\n\t\t// summary:\n\t\t//\t\tSets styles on a node.\n\t\t// node: DOMNode|String\n\t\t//\t\tid or reference to node to set style for\n\t\t// name: String|Object\n\t\t//\t\tthe style property to set in DOM-accessor format\n\t\t//\t\t(\"borderWidth\", not \"border-width\") or an object with key/value\n\t\t//\t\tpairs suitable for setting each property.\n\t\t// value: String?\n\t\t//\t\tIf passed, sets value on the node for style, handling\n\t\t//\t\tcross-browser concerns.  When setting a pixel value,\n\t\t//\t\tbe sure to include \"px\" in the value. For instance, top: \"200px\".\n\t\t//\t\tOtherwise, in some cases, some browsers will not apply the style.\n\t\t//\n\t\t// example:\n\t\t//\t\tPassing a node, a style property, and a value changes the\n\t\t//\t\tcurrent display of the node and returns the new computed value\n\t\t//\t|\tdojo.setStyle(\"thinger\", \"opacity\", 0.5); // == 0.5\n\t\t//\n\t\t// example:\n\t\t//\t\tPassing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:\n\t\t//\t|\tdojo.setStyle(\"thinger\", {\n\t\t//\t|\t\t\"opacity\": 0.5,\n\t\t//\t|\t\t\"border\": \"3px solid black\",\n\t\t//\t|\t\t\"height\": \"300px\"\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\t\tWhen the CSS style property is hyphenated, the JavaScript property is camelCased.\n\t\t//\t\tfont-size becomes fontSize, and so on.\n\t\t//\t|\tdojo.setStyle(\"thinger\",{\n\t\t//\t|\t\tfontSize:\"14pt\",\n\t\t//\t|\t\tletterSpacing:\"1.2em\"\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\t\tdojo.NodeList implements .style() using the same syntax, omitting the \"node\" parameter, calling\n\t\t//\t\tdojo.style() on every element of the list. See: `dojo.query()` and `dojo.NodeList()`\n\t\t//\t|\tdojo.query(\".someClassName\").style(\"visibility\",\"hidden\");\n\t\t//\t|\t// or\n\t\t//\t|\tdojo.query(\"#baz > div\").style({\n\t\t//\t|\t\topacity:0.75,\n\t\t//\t|\t\tfontSize:\"13pt\"\n\t\t//\t|\t});\n\t};\n\t=====*/\n\n\t// Although we normally eschew argument validation at this\n\t// level, here we test argument 'node' for (duck)type,\n\t// by testing nodeType, ecause 'document' is the 'parentNode' of 'body'\n\t// it is frequently sent to this function even\n\t// though it is not Element.\n\tvar getComputedStyle, style = {};\n\t\tif(has(\"webkit\")){\n\t\t\tgetComputedStyle = function(/*DomNode*/node){\n\t\t\tvar s;\n\t\t\tif(node.nodeType == 1){\n\t\t\t\tvar dv = node.ownerDocument.defaultView;\n\t\t\t\ts = dv.getComputedStyle(node, null);\n\t\t\t\tif(!s && node.style){\n\t\t\t\t\tnode.style.display = \"\";\n\t\t\t\t\ts = dv.getComputedStyle(node, null);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn s || {};\n\t\t};\n\t\t}else if(has(\"ie\") && (has(\"ie\") < 9 || has(\"quirks\"))){\n\t\tgetComputedStyle = function(node){\n\t\t\t// IE (as of 7) doesn't expose Element like sane browsers\n\t\t\treturn node.nodeType == 1 /* ELEMENT_NODE*/ ? node.currentStyle : {};\n\t\t};\n\t}else{\n\t\tgetComputedStyle = function(node){\n\t\t\treturn node.nodeType == 1 ?\n\t\t\t\tnode.ownerDocument.defaultView.getComputedStyle(node, null) : {};\n\t\t};\n\t}\n\t\tstyle.getComputedStyle = getComputedStyle;\n\n\tvar toPixel;\n\t\tif(!has(\"ie\")){\n\t\t\ttoPixel = function(element, value){\n\t\t\t// style values can be floats, client code may want\n\t\t\t// to round for integer pixels.\n\t\t\treturn parseFloat(value) || 0;\n\t\t};\n\t\t}else{\n\t\ttoPixel = function(element, avalue){\n\t\t\tif(!avalue){ return 0; }\n\t\t\t// on IE7, medium is usually 4 pixels\n\t\t\tif(avalue == \"medium\"){ return 4; }\n\t\t\t// style values can be floats, client code may\n\t\t\t// want to round this value for integer pixels.\n\t\t\tif(avalue.slice && avalue.slice(-2) == 'px'){ return parseFloat(avalue); }\n\t\t\tvar s = element.style, rs = element.runtimeStyle, cs = element.currentStyle,\n\t\t\t\tsLeft = s.left, rsLeft = rs.left;\n\t\t\trs.left = cs.left;\n\t\t\ttry{\n\t\t\t\t// 'avalue' may be incompatible with style.left, which can cause IE to throw\n\t\t\t\t// this has been observed for border widths using \"thin\", \"medium\", \"thick\" constants\n\t\t\t\t// those particular constants could be trapped by a lookup\n\t\t\t\t// but perhaps there are more\n\t\t\t\ts.left = avalue;\n\t\t\t\tavalue = s.pixelLeft;\n\t\t\t}catch(e){\n\t\t\t\tavalue = 0;\n\t\t\t}\n\t\t\ts.left = sLeft;\n\t\t\trs.left = rsLeft;\n\t\t\treturn avalue;\n\t\t}\n\t}\n\t\tstyle.toPixelValue = toPixel;\n\n\t// FIXME: there opacity quirks on FF that we haven't ported over. Hrm.\n\n\t\tvar astr = \"DXImageTransform.Microsoft.Alpha\";\n\tvar af = function(n, f){\n\t\ttry{\n\t\t\treturn n.filters.item(astr);\n\t\t}catch(e){\n\t\t\treturn f ? {} : null;\n\t\t}\n\t};\n\n\t\tvar _getOpacity =\n\t\t\thas(\"ie\") < 9 || (has(\"ie\") && has(\"quirks\")) ? function(node){\n\t\t\ttry{\n\t\t\t\treturn af(node).Opacity / 100; // Number\n\t\t\t}catch(e){\n\t\t\t\treturn 1; // Number\n\t\t\t}\n\t\t} :\n\t\t\tfunction(node){\n\t\t\treturn getComputedStyle(node).opacity;\n\t\t};\n\n\tvar _setOpacity =\n\t\t\t\thas(\"ie\") < 9 || (has(\"ie\") && has(\"quirks\")) ? function(/*DomNode*/node, /*Number*/opacity){\n\t\t\tvar ov = opacity * 100, opaque = opacity == 1;\n\t\t\tnode.style.zoom = opaque ? \"\" : 1;\n\n\t\t\tif(!af(node)){\n\t\t\t\tif(opaque){\n\t\t\t\t\treturn opacity;\n\t\t\t\t}\n\t\t\t\tnode.style.filter += \" progid:\" + astr + \"(Opacity=\" + ov + \")\";\n\t\t\t}else{\n\t\t\t\taf(node, 1).Opacity = ov;\n\t\t\t}\n\n\t\t\t// on IE7 Alpha(Filter opacity=100) makes text look fuzzy so disable it altogether (bug #2661),\n\t\t\t//but still update the opacity value so we can get a correct reading if it is read later.\n\t\t\taf(node, 1).Enabled = !opaque;\n\n\t\t\tif(node.tagName.toLowerCase() == \"tr\"){\n\t\t\t\tfor(var td = node.firstChild; td; td = td.nextSibling){\n\t\t\t\t\tif(td.tagName.toLowerCase() == \"td\"){\n\t\t\t\t\t\t_setOpacity(td, opacity);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn opacity;\n\t\t} :\n\t\t\t\tfunction(node, opacity){\n\t\t\treturn node.style.opacity = opacity;\n\t\t};\n\n\tvar _pixelNamesCache = {\n\t\tleft: true, top: true\n\t};\n\tvar _pixelRegExp = /margin|padding|width|height|max|min|offset/; // |border\n\tfunction _toStyleValue(node, type, value){\n\t\t//TODO: should we really be doing string case conversion here? Should we cache it? Need to profile!\n\t\ttype = type.toLowerCase();\n\t\t\t\tif(has(\"ie\")){\n\t\t\tif(value == \"auto\"){\n\t\t\t\tif(type == \"height\"){ return node.offsetHeight; }\n\t\t\t\tif(type == \"width\"){ return node.offsetWidth; }\n\t\t\t}\n\t\t\tif(type == \"fontweight\"){\n\t\t\t\tswitch(value){\n\t\t\t\t\tcase 700: return \"bold\";\n\t\t\t\t\tcase 400:\n\t\t\t\t\tdefault: return \"normal\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\tif(!(type in _pixelNamesCache)){\n\t\t\t_pixelNamesCache[type] = _pixelRegExp.test(type);\n\t\t}\n\t\treturn _pixelNamesCache[type] ? toPixel(node, value) : value;\n\t}\n\n\tvar _floatStyle = has(\"ie\") ? \"styleFloat\" : \"cssFloat\",\n\t\t_floatAliases = {\"cssFloat\": _floatStyle, \"styleFloat\": _floatStyle, \"float\": _floatStyle};\n\n\t// public API\n\n\tstyle.get = function getStyle(/*DOMNode|String*/ node, /*String?*/ name){\n\t\tvar n = dom.byId(node), l = arguments.length, op = (name == \"opacity\");\n\t\tif(l == 2 && op){\n\t\t\treturn _getOpacity(n);\n\t\t}\n\t\tname = _floatAliases[name] || name;\n\t\tvar s = style.getComputedStyle(n);\n\t\treturn (l == 1) ? s : _toStyleValue(n, name, s[name] || n.style[name]); /* CSS2Properties||String||Number */\n\t};\n\n\tstyle.set = function setStyle(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){\n\t\tvar n = dom.byId(node), l = arguments.length, op = (name == \"opacity\");\n\t\tname = _floatAliases[name] || name;\n\t\tif(l == 3){\n\t\t\treturn op ? _setOpacity(n, value) : n.style[name] = value; // Number\n\t\t}\n\t\tfor(var x in name){\n\t\t\tstyle.set(node, x, name[x]);\n\t\t}\n\t\treturn style.getComputedStyle(n);\n\t};\n\n\treturn style;\n});\n\n},\n'dojo/dom-geometry':function(){\ndefine([\"./_base/sniff\", \"./_base/window\",\"./dom\", \"./dom-style\"],\n\t\tfunction(has, win, dom, style){\n\t// module:\n\t//\t\tdojo/dom-geometry\n\t// summary:\n\t//\t\tThis module defines the core dojo DOM geometry API.\n\n\tvar geom = {};  // the result object\n\n\t// Box functions will assume this model.\n\t// On IE/Opera, BORDER_BOX will be set if the primary document is in quirks mode.\n\t// Can be set to change behavior of box setters.\n\n\t// can be either:\n\t//\t\"border-box\"\n\t//\t\"content-box\" (default)\n\tgeom.boxModel = \"content-box\";\n\n\t// We punt per-node box mode testing completely.\n\t// If anybody cares, we can provide an additional (optional) unit\n\t// that overrides existing code to include per-node box sensitivity.\n\n\t// Opera documentation claims that Opera 9 uses border-box in BackCompat mode.\n\t// but experiments (Opera 9.10.8679 on Windows Vista) indicate that it actually continues to use content-box.\n\t// IIRC, earlier versions of Opera did in fact use border-box.\n\t// Opera guys, this is really confusing. Opera being broken in quirks mode is not our fault.\n\n\t\tif(has(\"ie\") /*|| has(\"opera\")*/){\n\t\t// client code may have to adjust if compatMode varies across iframes\n\t\tgeom.boxModel = document.compatMode == \"BackCompat\" ? \"border-box\" : \"content-box\";\n\t}\n\t\n\t// =============================\n\t// Box Functions\n\t// =============================\n\n\t/*=====\n\tdojo.getPadExtents = function(node, computedStyle){\n\t\t// summary:\n\t\t//\t\tReturns object with special values specifically useful for node\n\t\t//\t\tfitting.\n\t\t// description:\n\t\t//\t\tReturns an object with `w`, `h`, `l`, `t` properties:\n\t\t//\t|\t\tl/t/r/b = left/top/right/bottom padding (respectively)\n\t\t//\t|\t\tw = the total of the left and right padding\n\t\t//\t|\t\th = the total of the top and bottom padding\n\t\t//\t\tIf 'node' has position, l/t forms the origin for child nodes.\n\t\t//\t\tThe w/h are used for calculating boxes.\n\t\t//\t\tNormally application code will not need to invoke this\n\t\t//\t\tdirectly, and will use the ...box... functions instead.\n\t\t// node: DOMNode\n\t\t// computedStyle: Object?\n\t\t// \t\tThis parameter accepts computed styles object.\n\t\t// \t\tIf this parameter is omitted, the functions will call \n\t\t//\t\tdojo.getComputedStyle to get one. It is a better way, calling \n\t\t//\t\tdojo.computedStyle once, and then pass the reference to this \n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned \n\t\t//\t\tobject of dojo.getComputedStyle.\n\n\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo._getPadExtents = function(node, computedStyle){\n\t\t// summary:\n\t\t//\t\tExisting alias for `dojo.getPadExtents`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.getBorderExtents = function(node, computedStyle){\n\t\t// summary:\n\t\t//\t\treturns an object with properties useful for noting the border\n\t\t//\t\tdimensions.\n\t\t// description:\n\t\t//\t\t* l/t/r/b = the sum of left/top/right/bottom border (respectively)\n\t\t//\t\t* w = the sum of the left and right border\n\t\t//\t\t* h = the sum of the top and bottom border\n\t\t//\n\t\t//\t\tThe w/h are used for calculating boxes.\n\t\t//\t\tNormally application code will not need to invoke this\n\t\t//\t\tdirectly, and will use the ...box... functions instead.\n\t\t// node: DOMNode\n\t\t// computedStyle: Object?\n\t\t// \t\tThis parameter accepts computed styles object.\n\t\t// \t\tIf this parameter is omitted, the functions will call \n\t\t//\t\tdojo.getComputedStyle to get one. It is a better way, calling \n\t\t//\t\tdojo.computedStyle once, and then pass the reference to this \n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned \n\t\t//\t\tobject of dojo.getComputedStyle.\n\n\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo._getBorderExtents = function(node, computedStyle){\n\t\t// summary:\n\t\t//\t\tExisting alias for `dojo.getBorderExtents`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.getPadBorderExtents = function(node, computedStyle){\n\t\t// summary:\n\t\t//\t\tReturns object with properties useful for box fitting with\n\t\t//\t\tregards to padding.\n\t\t// description:\n\t\t//\t\t* l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)\n\t\t//\t\t* w = the sum of the left and right padding and border\n\t\t//\t\t* h = the sum of the top and bottom padding and border\n\t\t//\n\t\t//\t\tThe w/h are used for calculating boxes.\n\t\t//\t\tNormally application code will not need to invoke this\n\t\t//\t\tdirectly, and will use the ...box... functions instead.\n\t\t// node: DOMNode\n\t\t// computedStyle: Object?\n\t\t// \t\tThis parameter accepts computed styles object.\n\t\t// \t\tIf this parameter is omitted, the functions will call \n\t\t//\t\tdojo.getComputedStyle to get one. It is a better way, calling \n\t\t//\t\tdojo.computedStyle once, and then pass the reference to this \n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned \n\t\t//\t\tobject of dojo.getComputedStyle.\n\n\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo._getPadBorderExtents = function(node, computedStyle){\n\t\t// summary:\n\t\t//\t\tExisting alias for `dojo.getPadBorderExtents`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.getMarginExtents = function(node, computedStyle){\n\t\t// summary:\n\t\t//\t\treturns object with properties useful for box fitting with\n\t\t//\t\tregards to box margins (i.e., the outer-box).\n\t\t//\n\t\t//\t\t* l/t = marginLeft, marginTop, respectively\n\t\t//\t\t* w = total width, margin inclusive\n\t\t//\t\t* h = total height, margin inclusive\n\t\t//\n\t\t//\t\tThe w/h are used for calculating boxes.\n\t\t//\t\tNormally application code will not need to invoke this\n\t\t//\t\tdirectly, and will use the ...box... functions instead.\n\t\t// node: DOMNode\n\t\t// computedStyle: Object?\n\t\t// \t\tThis parameter accepts computed styles object.\n\t\t// \t\tIf this parameter is omitted, the functions will call \n\t\t//\t\tdojo.getComputedStyle to get one. It is a better way, calling \n\t\t//\t\tdojo.computedStyle once, and then pass the reference to this \n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned \n\t\t//\t\tobject of dojo.getComputedStyle.\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo._getMarginExtents = function(node, computedStyle){\n\t\t// summary:\n\t\t//\t\tExisting alias for `dojo.getMarginExtents`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.getMarginSize = function(node, computedStyle){\n\t\t// summary:\n\t\t//\t\treturns an object that encodes the width and height of\n\t\t//\t\tthe node's margin box\n\t\t// node: DOMNode|String\n\t\t// computedStyle: Object?\n\t\t// \t\tThis parameter accepts computed styles object.\n\t\t// \t\tIf this parameter is omitted, the functions will call \n\t\t//\t\tdojo.getComputedStyle to get one. It is a better way, calling \n\t\t//\t\tdojo.computedStyle once, and then pass the reference to this \n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned \n\t\t//\t\tobject of dojo.getComputedStyle.\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo._getMarginSize = function(node, computedStyle){\n\t\t// summary:\n\t\t//\t\tExisting alias for `dojo.getMarginSize`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.getMarginBox = function(node, computedStyle){\n\t\t// summary:\n\t\t//\t\treturns an object that encodes the width, height, left and top\n\t\t//\t\tpositions of the node's margin box.\n\t\t// node: DOMNode\n\t\t// computedStyle: Object?\n\t\t// \t\tThis parameter accepts computed styles object.\n\t\t// \t\tIf this parameter is omitted, the functions will call \n\t\t//\t\tdojo.getComputedStyle to get one. It is a better way, calling \n\t\t//\t\tdojo.computedStyle once, and then pass the reference to this \n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned \n\t\t//\t\tobject of dojo.getComputedStyle.\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo._getMarginBox = function(node, computedStyle){\n\t\t// summary:\n\t\t//\t\tExisting alias for `dojo.getMarginBox`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.setMarginBox = function(node, box, computedStyle){\n\t\t// summary:\n\t\t//\t\tsets the size of the node's margin box and placement\n\t\t//\t\t(left/top), irrespective of box model. Think of it as a\n\t\t//\t\tpassthrough to setBox that handles box-model vagaries for\n\t\t//\t\tyou.\n\t\t// node: DOMNode\n\t\t// box: Object\n\t\t//      hash with optional \"l\", \"t\", \"w\", and \"h\" properties for \"left\", \"right\", \"width\", and \"height\"\n\t\t//      respectively. All specified properties should have numeric values in whole pixels.\n\t\t// computedStyle: Object?\n\t\t// \t\tThis parameter accepts computed styles object.\n\t\t// \t\tIf this parameter is omitted, the functions will call \n\t\t//\t\tdojo.getComputedStyle to get one. It is a better way, calling \n\t\t//\t\tdojo.computedStyle once, and then pass the reference to this \n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned \n\t\t//\t\tobject of dojo.getComputedStyle.\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.getContentBox = function(node, computedStyle){\n\t\t// summary:\n\t\t//\t\tReturns an object that encodes the width, height, left and top\n\t\t//\t\tpositions of the node's content box, irrespective of the\n\t\t//\t\tcurrent box model.\n\t\t// node: DOMNode\n\t\t// computedStyle: Object?\n\t\t// \t\tThis parameter accepts computed styles object.\n\t\t// \t\tIf this parameter is omitted, the functions will call \n\t\t//\t\tdojo.getComputedStyle to get one. It is a better way, calling \n\t\t//\t\tdojo.computedStyle once, and then pass the reference to this \n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned \n\t\t//\t\tobject of dojo.getComputedStyle.\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo._getContentBox = function(node, computedStyle){\n\t\t// summary:\n\t\t//\t\tExisting alias for `dojo.getContentBox`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.setContentSize = function(node, box, computedStyle){\n\t\t// summary:\n\t\t//\t\tSets the size of the node's contents, irrespective of margins,\n\t\t//\t\tpadding, or borders.\n\t\t// node: DOMNode\n\t\t// box: Object\n\t\t//      hash with optional \"w\", and \"h\" properties for \"width\", and \"height\"\n\t\t//      respectively. All specified properties should have numeric values in whole pixels.\n\t\t// computedStyle: Object?\n\t\t// \t\tThis parameter accepts computed styles object.\n\t\t// \t\tIf this parameter is omitted, the functions will call \n\t\t//\t\tdojo.getComputedStyle to get one. It is a better way, calling \n\t\t//\t\tdojo.computedStyle once, and then pass the reference to this \n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned \n\t\t//\t\tobject of dojo.getComputedStyle.\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.isBodyLtr = function(){\n\t\t// summary:\n\t\t//      Returns true if the current language is left-to-right, and false otherwise.\n\t\t// returns: Boolean\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo._isBodyLtr = function(){\n\t\t// summary:\n\t\t//\t\tExisting alias for `dojo.isBodyLtr`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.docScroll = function(){\n\t\t// summary:\n\t\t//      Returns an object with {node, x, y} with corresponding offsets.\n\t\t// returns: Object\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo._docScroll = function(){\n\t\t// summary:\n\t\t//\t\tExisting alias for `dojo.docScroll`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.getIeDocumentElementOffset = function(){\n\t\t// summary:\n\t\t//\t\treturns the offset in x and y from the document body to the\n\t\t//\t\tvisual edge of the page for IE\n\t\t// description:\n\t\t//\t\tThe following values in IE contain an offset:\n\t\t//\t|\t\tevent.clientX\n\t\t//\t|\t\tevent.clientY\n\t\t//\t|\t\tnode.getBoundingClientRect().left\n\t\t//\t|\t\tnode.getBoundingClientRect().top\n\t\t//\t\tBut other position related values do not contain this offset,\n\t\t//\t\tsuch as node.offsetLeft, node.offsetTop, node.style.left and\n\t\t//\t\tnode.style.top. The offset is always (2, 2) in LTR direction.\n\t\t//\t\tWhen the body is in RTL direction, the offset counts the width\n\t\t//\t\tof left scroll bar's width.  This function computes the actual\n\t\t//\t\toffset.\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo._getIeDocumentElementOffset = function(){\n\t\t// summary:\n\t\t//\t\tExisting alias for `dojo.getIeDocumentElementOffset`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.fixIeBiDiScrollLeft = function(scrollLeft){\n\t\t// summary:\n\t\t//      In RTL direction, scrollLeft should be a negative value, but IE\n\t\t//      returns a positive one. All codes using documentElement.scrollLeft\n\t\t//      must call this function to fix this error, otherwise the position\n\t\t//      will offset to right when there is a horizontal scrollbar.\n\t\t// scrollLeft: NUmber\n\t\t// returns: Number\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo._fixIeBiDiScrollLeft = function(scrollLeft){\n\t\t// summary:\n\t\t//\t\tExisting alias for `dojo.fixIeBiDiScrollLeft`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.position = function(node, includeScroll){\n\t\t// summary:\n\t\t//\t\tGets the position and size of the passed element relative to\n\t\t//\t\tthe viewport (if includeScroll==false), or relative to the\n\t\t//\t\tdocument root (if includeScroll==true).\n\t\t//\n\t\t// description:\n\t\t//\t\tReturns an object of the form:\n\t\t//\t\t\t{ x: 100, y: 300, w: 20, h: 15 }\n\t\t//\t\tIf includeScroll==true, the x and y values will include any\n\t\t//\t\tdocument offsets that may affect the position relative to the\n\t\t//\t\tviewport.\n\t\t//\t\tUses the border-box model (inclusive of border and padding but\n\t\t//\t\tnot margin).  Does not act as a setter.\n\t\t// node: DOMNode|String\n\t\t// includeScroll: Boolean?\n\t\t// returns: Object\n\t};\n\t=====*/\n\n\tgeom.getPadExtents = function getPadExtents(/*DomNode*/node, /*Object*/computedStyle){\n\t\tnode = dom.byId(node);\n\t\tvar s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue,\n\t\t\tl = px(node, s.paddingLeft), t = px(node, s.paddingTop), r = px(node, s.paddingRight), b = px(node, s.paddingBottom);\n\t\treturn {l: l, t: t, r: r, b: b, w: l + r, h: t + b};\n\t};\n\n\tvar none = \"none\";\n\n\tgeom.getBorderExtents = function getBorderExtents(/*DomNode*/node, /*Object*/computedStyle){\n\t\tnode = dom.byId(node);\n\t\tvar px = style.toPixelValue, s = computedStyle || style.getComputedStyle(node),\n\t\t\tl = s.borderLeftStyle != none ? px(node, s.borderLeftWidth) : 0,\n\t\t\tt = s.borderTopStyle != none ? px(node, s.borderTopWidth) : 0,\n\t\t\tr = s.borderRightStyle != none ? px(node, s.borderRightWidth) : 0,\n\t\t\tb = s.borderBottomStyle != none ? px(node, s.borderBottomWidth) : 0;\n\t\treturn {l: l, t: t, r: r, b: b, w: l + r, h: t + b};\n\t};\n\n\tgeom.getPadBorderExtents = function getPadBorderExtents(/*DomNode*/node, /*Object*/computedStyle){\n\t\tnode = dom.byId(node);\n\t\tvar s = computedStyle || style.getComputedStyle(node),\n\t\t\tp = geom.getPadExtents(node, s),\n\t\t\tb = geom.getBorderExtents(node, s);\n\t\treturn {\n\t\t\tl: p.l + b.l,\n\t\t\tt: p.t + b.t,\n\t\t\tr: p.r + b.r,\n\t\t\tb: p.b + b.b,\n\t\t\tw: p.w + b.w,\n\t\t\th: p.h + b.h\n\t\t};\n\t};\n\n\tgeom.getMarginExtents = function getMarginExtents(node, computedStyle){\n\t\tnode = dom.byId(node);\n\t\tvar s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue,\n\t\t\tl = px(node, s.marginLeft), t = px(node, s.marginTop), r = px(node, s.marginRight), b = px(node, s.marginBottom);\n\t\tif(has(\"webkit\") && (s.position != \"absolute\")){\n\t\t\t// FIXME: Safari's version of the computed right margin\n\t\t\t// is the space between our right edge and the right edge\n\t\t\t// of our offsetParent.\n\t\t\t// What we are looking for is the actual margin value as\n\t\t\t// determined by CSS.\n\t\t\t// Hack solution is to assume left/right margins are the same.\n\t\t\tr = l;\n\t\t}\n\t\treturn {l: l, t: t, r: r, b: b, w: l + r, h: t + b};\n\t};\n\n\t// Box getters work in any box context because offsetWidth/clientWidth\n\t// are invariant wrt box context\n\t//\n\t// They do *not* work for display: inline objects that have padding styles\n\t// because the user agent ignores padding (it's bogus styling in any case)\n\t//\n\t// Be careful with IMGs because they are inline or block depending on\n\t// browser and browser mode.\n\n\t// Although it would be easier to read, there are not separate versions of\n\t// _getMarginBox for each browser because:\n\t// 1. the branching is not expensive\n\t// 2. factoring the shared code wastes cycles (function call overhead)\n\t// 3. duplicating the shared code wastes bytes\n\n\tgeom.getMarginBox = function getMarginBox(/*DomNode*/node, /*Object*/computedStyle){\n\t\t// summary:\n\t\t//\t\treturns an object that encodes the width, height, left and top\n\t\t//\t\tpositions of the node's margin box.\n\t\tnode = dom.byId(node);\n\t\tvar s = computedStyle || style.getComputedStyle(node), me = geom.getMarginExtents(node, s),\n\t\t\tl = node.offsetLeft - me.l, t = node.offsetTop - me.t, p = node.parentNode, px = style.toPixelValue, pcs;\n\t\t\t\tif(has(\"mozilla\")){\n\t\t\t// Mozilla:\n\t\t\t// If offsetParent has a computed overflow != visible, the offsetLeft is decreased\n\t\t\t// by the parent's border.\n\t\t\t// We don't want to compute the parent's style, so instead we examine node's\n\t\t\t// computed left/top which is more stable.\n\t\t\tvar sl = parseFloat(s.left), st = parseFloat(s.top);\n\t\t\tif(!isNaN(sl) && !isNaN(st)){\n\t\t\t\tl = sl, t = st;\n\t\t\t}else{\n\t\t\t\t// If child's computed left/top are not parseable as a number (e.g. \"auto\"), we\n\t\t\t\t// have no choice but to examine the parent's computed style.\n\t\t\t\tif(p && p.style){\n\t\t\t\t\tpcs = style.getComputedStyle(p);\n\t\t\t\t\tif(pcs.overflow != \"visible\"){\n\t\t\t\t\t\tl += pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;\n\t\t\t\t\t\tt += pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(has(\"opera\") || (has(\"ie\") == 8 && !has(\"quirks\"))){\n\t\t\t// On Opera and IE 8, offsetLeft/Top includes the parent's border\n\t\t\tif(p){\n\t\t\t\tpcs = style.getComputedStyle(p);\n\t\t\t\tl -= pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;\n\t\t\t\tt -= pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;\n\t\t\t}\n\t\t}\n\t\t\t\treturn {l: l, t: t, w: node.offsetWidth + me.w, h: node.offsetHeight + me.h};\n\t};\n\n\tgeom.getContentBox = function getContentBox(node, computedStyle){\n\t\t// clientWidth/Height are important since the automatically account for scrollbars\n\t\t// fallback to offsetWidth/Height for special cases (see #3378)\n\t\tnode = dom.byId(node);\n\t\tvar s = computedStyle || style.getComputedStyle(node), w = node.clientWidth, h,\n\t\t\tpe = geom.getPadExtents(node, s), be = geom.getBorderExtents(node, s);\n\t\tif(!w){\n\t\t\tw = node.offsetWidth;\n\t\t\th = node.offsetHeight;\n\t\t}else{\n\t\t\th = node.clientHeight;\n\t\t\tbe.w = be.h = 0;\n\t\t}\n\t\t// On Opera, offsetLeft includes the parent's border\n\t\t\t\tif(has(\"opera\")){\n\t\t\tpe.l += be.l;\n\t\t\tpe.t += be.t;\n\t\t}\n\t\t\t\treturn {l: pe.l, t: pe.t, w: w - pe.w - be.w, h: h - pe.h - be.h};\n\t};\n\n\t// Box setters depend on box context because interpretation of width/height styles\n\t// vary wrt box context.\n\t//\n\t// The value of dojo.boxModel is used to determine box context.\n\t// dojo.boxModel can be set directly to change behavior.\n\t//\n\t// Beware of display: inline objects that have padding styles\n\t// because the user agent ignores padding (it's a bogus setup anyway)\n\t//\n\t// Be careful with IMGs because they are inline or block depending on\n\t// browser and browser mode.\n\t//\n\t// Elements other than DIV may have special quirks, like built-in\n\t// margins or padding, or values not detectable via computedStyle.\n\t// In particular, margins on TABLE do not seems to appear\n\t// at all in computedStyle on Mozilla.\n\n\tfunction setBox(/*DomNode*/node, /*Number?*/l, /*Number?*/t, /*Number?*/w, /*Number?*/h, /*String?*/u){\n\t\t// summary:\n\t\t//\t\tsets width/height/left/top in the current (native) box-model\n\t\t//\t\tdimensions. Uses the unit passed in u.\n\t\t// node:\n\t\t//\t\tDOM Node reference. Id string not supported for performance\n\t\t//\t\treasons.\n\t\t// l:\n\t\t//\t\tleft offset from parent.\n\t\t// t:\n\t\t//\t\ttop offset from parent.\n\t\t// w:\n\t\t//\t\twidth in current box model.\n\t\t// h:\n\t\t//\t\twidth in current box model.\n\t\t// u:\n\t\t//\t\tunit measure to use for other measures. Defaults to \"px\".\n\t\tu = u || \"px\";\n\t\tvar s = node.style;\n\t\tif(!isNaN(l)){\n\t\t\ts.left = l + u;\n\t\t}\n\t\tif(!isNaN(t)){\n\t\t\ts.top = t + u;\n\t\t}\n\t\tif(w >= 0){\n\t\t\ts.width = w + u;\n\t\t}\n\t\tif(h >= 0){\n\t\t\ts.height = h + u;\n\t\t}\n\t}\n\n\tfunction isButtonTag(/*DomNode*/node){\n\t\t// summary:\n\t\t//\t\tTrue if the node is BUTTON or INPUT.type=\"button\".\n\t\treturn node.tagName.toLowerCase() == \"button\" ||\n\t\t\tnode.tagName.toLowerCase() == \"input\" && (node.getAttribute(\"type\") || \"\").toLowerCase() == \"button\"; // boolean\n\t}\n\n\tfunction usesBorderBox(/*DomNode*/node){\n\t\t// summary:\n\t\t//\t\tTrue if the node uses border-box layout.\n\n\t\t// We could test the computed style of node to see if a particular box\n\t\t// has been specified, but there are details and we choose not to bother.\n\n\t\t// TABLE and BUTTON (and INPUT type=button) are always border-box by default.\n\t\t// If you have assigned a different box to either one via CSS then\n\t\t// box functions will break.\n\n\t\treturn geom.boxModel == \"border-box\" || node.tagName.toLowerCase() == \"table\" || isButtonTag(node); // boolean\n\t}\n\n\tgeom.setContentSize = function setContentSize(/*DomNode*/node, /*Object*/box, /*Object*/computedStyle){\n\t\t// summary:\n\t\t//\t\tSets the size of the node's contents, irrespective of margins,\n\t\t//\t\tpadding, or borders.\n\n\t\tnode = dom.byId(node);\n\t\tvar w = box.w, h = box.h;\n\t\tif(usesBorderBox(node)){\n\t\t\tvar pb = geom.getPadBorderExtents(node, computedStyle);\n\t\t\tif(w >= 0){\n\t\t\t\tw += pb.w;\n\t\t\t}\n\t\t\tif(h >= 0){\n\t\t\t\th += pb.h;\n\t\t\t}\n\t\t}\n\t\tsetBox(node, NaN, NaN, w, h);\n\t};\n\n\tvar nilExtents = {l: 0, t: 0, w: 0, h: 0};\n\n\tgeom.setMarginBox = function setMarginBox(/*DomNode*/node, /*Object*/box, /*Object*/computedStyle){\n\t\tnode = dom.byId(node);\n\t\tvar s = computedStyle || style.getComputedStyle(node), w = box.w, h = box.h,\n\t\t// Some elements have special padding, margin, and box-model settings.\n\t\t// To use box functions you may need to set padding, margin explicitly.\n\t\t// Controlling box-model is harder, in a pinch you might set dojo.boxModel.\n\t\t\tpb = usesBorderBox(node) ? nilExtents : geom.getPadBorderExtents(node, s),\n\t\t\tmb = geom.getMarginExtents(node, s);\n\t\tif(has(\"webkit\")){\n\t\t\t// on Safari (3.1.2), button nodes with no explicit size have a default margin\n\t\t\t// setting an explicit size eliminates the margin.\n\t\t\t// We have to swizzle the width to get correct margin reading.\n\t\t\tif(isButtonTag(node)){\n\t\t\t\tvar ns = node.style;\n\t\t\t\tif(w >= 0 && !ns.width){\n\t\t\t\t\tns.width = \"4px\";\n\t\t\t\t}\n\t\t\t\tif(h >= 0 && !ns.height){\n\t\t\t\t\tns.height = \"4px\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(w >= 0){\n\t\t\tw = Math.max(w - pb.w - mb.w, 0);\n\t\t}\n\t\tif(h >= 0){\n\t\t\th = Math.max(h - pb.h - mb.h, 0);\n\t\t}\n\t\tsetBox(node, box.l, box.t, w, h);\n\t};\n\n\t// =============================\n\t// Positioning\n\t// =============================\n\n\tgeom.isBodyLtr = function isBodyLtr(){\n\t\treturn (win.body().dir || win.doc.documentElement.dir || \"ltr\").toLowerCase() == \"ltr\"; // Boolean\n\t};\n\n\tgeom.docScroll = function docScroll(){\n\t\tvar node = win.doc.parentWindow || win.doc.defaultView;   // use UI window, not dojo.global window\n\t\treturn \"pageXOffset\" in node ? {x: node.pageXOffset, y: node.pageYOffset } :\n\t\t\t(node = has(\"quirks\") ? win.body() : win.doc.documentElement,\n\t\t\t\t{x: geom.fixIeBiDiScrollLeft(node.scrollLeft || 0), y: node.scrollTop || 0 });\n\t};\n\n\t\tgeom.getIeDocumentElementOffset = function getIeDocumentElementOffset(){\n\t\t//NOTE: assumes we're being called in an IE browser\n\n\t\tvar de = win.doc.documentElement; // only deal with HTML element here, position() handles body/quirks\n\n\t\tif(has(\"ie\") < 8){\n\t\t\tvar r = de.getBoundingClientRect(), // works well for IE6+\n\t\t\t\tl = r.left, t = r.top;\n\t\t\tif(has(\"ie\") < 7){\n\t\t\t\tl += de.clientLeft;\t// scrollbar size in strict/RTL, or,\n\t\t\t\tt += de.clientTop;\t// HTML border size in strict\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tx: l < 0 ? 0 : l, // FRAME element border size can lead to inaccurate negative values\n\t\t\t\ty: t < 0 ? 0 : t\n\t\t\t};\n\t\t}else{\n\t\t\treturn {\n\t\t\t\tx: 0,\n\t\t\t\ty: 0\n\t\t\t};\n\t\t}\n\t};\n\t\n\tgeom.fixIeBiDiScrollLeft = function fixIeBiDiScrollLeft(/*Integer*/ scrollLeft){\n\t\t// In RTL direction, scrollLeft should be a negative value, but IE\n\t\t// returns a positive one. All codes using documentElement.scrollLeft\n\t\t// must call this function to fix this error, otherwise the position\n\t\t// will offset to right when there is a horizontal scrollbar.\n\n\t\t\t\tvar ie = has(\"ie\");\n\t\tif(ie && !geom.isBodyLtr()){\n\t\t\tvar qk = has(\"quirks\"),\n\t\t\t\tde = qk ? win.body() : win.doc.documentElement;\n\t\t\tif(ie == 6 && !qk && win.global.frameElement && de.scrollHeight > de.clientHeight){\n\t\t\t\tscrollLeft += de.clientLeft; // workaround ie6+strict+rtl+iframe+vertical-scrollbar bug where clientWidth is too small by clientLeft pixels\n\t\t\t}\n\t\t\treturn (ie < 8 || qk) ? (scrollLeft + de.clientWidth - de.scrollWidth) : -scrollLeft; // Integer\n\t\t}\n\t\t\t\treturn scrollLeft; // Integer\n\t};\n\n\tgeom.position = function(/*DomNode*/node, /*Boolean?*/includeScroll){\n\t\tnode = dom.byId(node);\n\t\tvar\tdb = win.body(),\n\t\t\tdh = db.parentNode,\n\t\t\tret = node.getBoundingClientRect();\n\t\tret = {x: ret.left, y: ret.top, w: ret.right - ret.left, h: ret.bottom - ret.top};\n\t\t\t\tif(has(\"ie\")){\n\t\t\t// On IE there's a 2px offset that we need to adjust for, see dojo.getIeDocumentElementOffset()\n\t\t\tvar offset = geom.getIeDocumentElementOffset();\n\n\t\t\t// fixes the position in IE, quirks mode\n\t\t\tret.x -= offset.x + (has(\"quirks\") ? db.clientLeft + db.offsetLeft : 0);\n\t\t\tret.y -= offset.y + (has(\"quirks\") ? db.clientTop + db.offsetTop : 0);\n\t\t}else if(has(\"ff\") == 3){\n\t\t\t// In FF3 you have to subtract the document element margins.\n\t\t\t// Fixed in FF3.5 though.\n\t\t\tvar cs = style.getComputedStyle(dh), px = style.toPixelValue;\n\t\t\tret.x -= px(dh, cs.marginLeft) + px(dh, cs.borderLeftWidth);\n\t\t\tret.y -= px(dh, cs.marginTop) + px(dh, cs.borderTopWidth);\n\t\t}\n\t\t\t\t// account for document scrolling\n\t\t// if offsetParent is used, ret value already includes scroll position\n\t\t// so we may have to actually remove that value if !includeScroll\n\t\tif(includeScroll){\n\t\t\tvar scroll = geom.docScroll();\n\t\t\tret.x += scroll.x;\n\t\t\tret.y += scroll.y;\n\t\t}\n\n\t\treturn ret; // Object\n\t};\n\n\t// random \"private\" functions wildly used throughout the toolkit\n\n\tgeom.getMarginSize = function getMarginSize(/*DomNode*/node, /*Object*/computedStyle){\n\t\tnode = dom.byId(node);\n\t\tvar me = geom.getMarginExtents(node, computedStyle || style.getComputedStyle(node));\n\t\tvar size = node.getBoundingClientRect();\n\t\treturn {\n\t\t\tw: (size.right - size.left) + me.w,\n\t\t\th: (size.bottom - size.top) + me.h\n\t\t}\n\t};\n\n\tgeom.normalizeEvent = function(event){\n\t\t// summary:\n\t\t// \t\tNormalizes the geometry of a DOM event, normalizing the pageX, pageY,\n\t\t// \t\toffsetX, offsetY, layerX, and layerX properties\n\t\t// event: Object\n\t\tif(!(\"layerX\" in event)){\n\t\t\tevent.layerX = event.offsetX;\n\t\t\tevent.layerY = event.offsetY;\n\t\t}\n\t\tif(!has(\"dom-addeventlistener\")){\n\t\t\t// old IE version\n\t\t\t// FIXME: scroll position query is duped from dojo.html to\n\t\t\t// avoid dependency on that entire module. Now that HTML is in\n\t\t\t// Base, we should convert back to something similar there.\n\t\t\tvar se = event.target;\n\t\t\tvar doc = (se && se.ownerDocument) || document;\n\t\t\t// DO NOT replace the following to use dojo.body(), in IE, document.documentElement should be used\n\t\t\t// here rather than document.body\n\t\t\tvar docBody = has(\"quirks\") ? doc.body : doc.documentElement;\n\t\t\tvar offset = geom.getIeDocumentElementOffset();\n\t\t\tevent.pageX = event.clientX + geom.fixIeBiDiScrollLeft(docBody.scrollLeft || 0) - offset.x;\n\t\t\tevent.pageY = event.clientY + (docBody.scrollTop || 0) - offset.y;\n\t\t}\n\t};\n\n\t// TODO: evaluate separate getters/setters for position and sizes?\n\n\treturn geom;\n});\n\n},\n'dojo/dom-prop':function(){\ndefine(\"dojo/dom-prop\", [\"exports\", \"./_base/kernel\", \"./_base/sniff\", \"./_base/lang\", \"./dom\", \"./dom-style\", \"./dom-construct\", \"./_base/connect\"],\n\t\tfunction(exports, dojo, has, lang, dom, style, ctr, conn){\n\t// module:\n\t//\t\tdojo/dom-prop\n\t// summary:\n\t//\t\tThis module defines the core dojo DOM properties API.\n\t//      Indirectly depends on dojo.empty() and dojo.toDom().\n\n\t// =============================\n\t// Element properties Functions\n\t// =============================\n\n\t/*=====\n\tprop.get = function(node, name){\n\t\t// summary:\n\t\t//\t\tGets a property on an HTML element.\n\t\t// description:\n\t\t//\t\tHandles normalized getting of properties on DOM nodes.\n\t\t//\n\t\t// node: DOMNode|String\n\t\t//\t\tid or reference to the element to get the property on\n\t\t// name: String\n\t\t//\t\tthe name of the property to get.\n\t\t// returns:\n\t\t//\t\tthe value of the requested property or its default value\n\t\t//\n\t\t// example:\n\t\t//\t|\t// get the current value of the \"foo\" property on a node\n\t\t//\t|\tdojo.getProp(dojo.byId(\"nodeId\"), \"foo\");\n\t\t//\t|\t// or we can just pass the id:\n\t\t//\t|\tdojo.getProp(\"nodeId\", \"foo\");\n\t};\n\t=====*/\n\n\t/*=====\n\tprop.set = function(node, name, value){\n\t\t// summary:\n\t\t//\t\tSets a property on an HTML element.\n\t\t// description:\n\t\t//\t\tHandles normalized setting of properties on DOM nodes.\n\t\t//\n\t\t//\t\tWhen passing functions as values, note that they will not be\n\t\t//\t\tdirectly assigned to slots on the node, but rather the default\n\t\t//\t\tbehavior will be removed and the new behavior will be added\n\t\t//\t\tusing `dojo.connect()`, meaning that event handler properties\n\t\t//\t\twill be normalized and that some caveats with regards to\n\t\t//\t\tnon-standard behaviors for onsubmit apply. Namely that you\n\t\t//\t\tshould cancel form submission using `dojo.stopEvent()` on the\n\t\t//\t\tpassed event object instead of returning a boolean value from\n\t\t//\t\tthe handler itself.\n\t\t// node: DOMNode|String\n\t\t//\t\tid or reference to the element to set the property on\n\t\t// name: String|Object\n\t\t//\t\tthe name of the property to set, or a hash object to set\n\t\t//\t\tmultiple properties at once.\n\t\t// value: String?\n\t\t//\t\tThe value to set for the property\n\t\t// returns:\n\t\t//\t\tthe DOM node\n\t\t//\n\t\t// example:\n\t\t//\t|\t// use prop() to set the tab index\n\t\t//\t|\tdojo.setProp(\"nodeId\", \"tabIndex\", 3);\n\t\t//\t|\n\t\t//\n\t\t// example:\n\t\t//\tSet multiple values at once, including event handlers:\n\t\t//\t|\tdojo.setProp(\"formId\", {\n\t\t//\t|\t\t\"foo\": \"bar\",\n\t\t//\t|\t\t\"tabIndex\": -1,\n\t\t//\t|\t\t\"method\": \"POST\",\n\t\t//\t|\t\t\"onsubmit\": function(e){\n\t\t//\t|\t\t\t// stop submitting the form. Note that the IE behavior\n\t\t//\t|\t\t\t// of returning true or false will have no effect here\n\t\t//\t|\t\t\t// since our handler is connect()ed to the built-in\n\t\t//\t|\t\t\t// onsubmit behavior and so we need to use\n\t\t//\t|\t\t\t// dojo.stopEvent() to ensure that the submission\n\t\t//\t|\t\t\t// doesn't proceed.\n\t\t//\t|\t\t\tdojo.stopEvent(e);\n\t\t//\t|\n\t\t//\t|\t\t\t// submit the form with Ajax\n\t\t//\t|\t\t\tdojo.xhrPost({ form: \"formId\" });\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\tStyle is s special case: Only set with an object hash of styles\n\t\t//\t|\tdojo.setProp(\"someNode\",{\n\t\t//\t|\t\tid:\"bar\",\n\t\t//\t|\t\tstyle:{\n\t\t//\t|\t\t\twidth:\"200px\", height:\"100px\", color:\"#000\"\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\tAgain, only set style as an object hash of styles:\n\t\t//\t|\tvar obj = { color:\"#fff\", backgroundColor:\"#000\" };\n\t\t//\t|\tdojo.setProp(\"someNode\", \"style\", obj);\n\t\t//\t|\n\t\t//\t|\t// though shorter to use `dojo.style()` in this case:\n\t\t//\t|\tdojo.style(\"someNode\", obj);\n\t};\n\t=====*/\n\n\t// helper to connect events\n\tvar _evtHdlrMap = {}, _ctr = 0, _attrId = dojo._scopeName + \"attrid\";\n\n\t\t// the next dictionary lists elements with read-only innerHTML on IE\n\tvar _roInnerHtml = {col: 1, colgroup: 1,\n\t\t\t// frameset: 1, head: 1, html: 1, style: 1,\n\t\t\ttable: 1, tbody: 1, tfoot: 1, thead: 1, tr: 1, title: 1};\n\t\n\texports.names = {\n\t\t// properties renamed to avoid clashes with reserved words\n\t\t\"class\": \"className\",\n\t\t\"for\": \"htmlFor\",\n\t\t// properties written as camelCase\n\t\ttabindex: \"tabIndex\",\n\t\treadonly: \"readOnly\",\n\t\tcolspan: \"colSpan\",\n\t\tframeborder: \"frameBorder\",\n\t\trowspan: \"rowSpan\",\n\t\tvaluetype: \"valueType\"\n\t};\n\n\texports.get = function getProp(/*DOMNode|String*/node, /*String*/name){\n\t\tnode = dom.byId(node);\n\t\tvar lc = name.toLowerCase(), propName = exports.names[lc] || name;\n\t\treturn node[propName];\t// Anything\n\t};\n\n\texports.set = function setProp(/*DOMNode|String*/node, /*String|Object*/name, /*String?*/value){\n\t\tnode = dom.byId(node);\n\t\tvar l = arguments.length;\n\t\tif(l == 2 && typeof name != \"string\"){ // inline'd type check\n\t\t\t// the object form of setter: the 2nd argument is a dictionary\n\t\t\tfor(var x in name){\n\t\t\t\texports.set(node, x, name[x]);\n\t\t\t}\n\t\t\treturn node; // DomNode\n\t\t}\n\t\tvar lc = name.toLowerCase(), propName = exports.names[lc] || name;\n\t\tif(propName == \"style\" && typeof value != \"string\"){ // inline'd type check\n\t\t\t// special case: setting a style\n\t\t\tstyle.style(node, value);\n\t\t\treturn node; // DomNode\n\t\t}\n\t\tif(propName == \"innerHTML\"){\n\t\t\t// special case: assigning HTML\n\t\t\t\t\t\tif(has(\"ie\") && node.tagName.toLowerCase() in _roInnerHtml){\n\t\t\t\tctr.empty(node);\n\t\t\t\tnode.appendChild(ctr.toDom(value, node.ownerDocument));\n\t\t\t}else{\n\t\t\t\t\t\t\tnode[propName] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn node; // DomNode\n\t\t}\n\t\tif(lang.isFunction(value)){\n\t\t\t// special case: assigning an event handler\n\t\t\t// clobber if we can\n\t\t\tvar attrId = node[_attrId];\n\t\t\tif(!attrId){\n\t\t\t\tattrId = _ctr++;\n\t\t\t\tnode[_attrId] = attrId;\n\t\t\t}\n\t\t\tif(!_evtHdlrMap[attrId]){\n\t\t\t\t_evtHdlrMap[attrId] = {};\n\t\t\t}\n\t\t\tvar h = _evtHdlrMap[attrId][propName];\n\t\t\tif(h){\n\t\t\t\t//h.remove();\n\t\t\t\tconn.disconnect(h);\n\t\t\t}else{\n\t\t\t\ttry{\n\t\t\t\t\tdelete node[propName];\n\t\t\t\t}catch(e){}\n\t\t\t}\n\t\t\t// ensure that event objects are normalized, etc.\n\t\t\tif(value){\n\t\t\t\t//_evtHdlrMap[attrId][propName] = on(node, propName, value);\n\t\t\t\t_evtHdlrMap[attrId][propName] = conn.connect(node, propName, value);\n\t\t\t}else{\n\t\t\t\tnode[propName] = null;\n\t\t\t}\n\t\t\treturn node; // DomNode\n\t\t}\n\t\tnode[propName] = value;\n\t\treturn node;\t// DomNode\n\t};\n});\n\n},\n'dojo/dom-attr':function(){\ndefine([\"exports\", \"./_base/sniff\", \"./_base/lang\", \"./dom\", \"./dom-style\", \"./dom-prop\"],\n\t\tfunction(exports, has, lang, dom, style, prop){\n\t// module:\n\t//\t\tdojo/dom-attr\n\t// summary:\n\t//\t\tThis module defines the core dojo DOM attributes API.\n\n\t// =============================\n\t// Element attribute Functions\n\t// =============================\n\n\t// This module will be obsolete soon. Use dojo.prop instead.\n\n\t// dojo.attr() should conform to http://www.w3.org/TR/DOM-Level-2-Core/\n\n\t// attribute-related functions (to be obsolete soon)\n\n\t/*=====\n\tdojo.hasAttr = function(node, name){\n\t\t// summary:\n\t\t//\t\tReturns true if the requested attribute is specified on the\n\t\t//\t\tgiven element, and false otherwise.\n\t\t// node: DOMNode|String\n\t\t//\t\tid or reference to the element to check\n\t\t// name: String\n\t\t//\t\tthe name of the attribute\n\t\t// returns: Boolean\n\t\t//\t\ttrue if the requested attribute is specified on the\n\t\t//\t\tgiven element, and false otherwise\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.getAttr = function(node, name){\n\t\t// summary:\n\t\t//\t\tGets an attribute on an HTML element.\n\t\t// description:\n\t\t//\t\tHandles normalized getting of attributes on DOM Nodes.\n\t\t// node: DOMNode|String\n\t\t//\t\tid or reference to the element to get the attribute on\n\t\t// name: String\n\t\t//\t\tthe name of the attribute to get.\n\t\t// returns:\n\t\t//\t\tthe value of the requested attribute or null if that attribute does not have a specified or\n\t\t//\t\tdefault value;\n\t\t//\n\t\t// example:\n\t\t//\t|\t// get the current value of the \"foo\" attribute on a node\n\t\t//\t|\tdojo.getAttr(dojo.byId(\"nodeId\"), \"foo\");\n\t\t//\t|\t// or we can just pass the id:\n\t\t//\t|\tdojo.getAttr(\"nodeId\", \"foo\");\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.setAttr = function(node, name, value){\n\t\t// summary:\n\t\t//\t\tSets an attribute on an HTML element.\n\t\t// description:\n\t\t//\t\tHandles normalized setting of attributes on DOM Nodes.\n\t\t//\n\t\t//\t\tWhen passing functions as values, note that they will not be\n\t\t//\t\tdirectly assigned to slots on the node, but rather the default\n\t\t//\t\tbehavior will be removed and the new behavior will be added\n\t\t//\t\tusing `dojo.connect()`, meaning that event handler properties\n\t\t//\t\twill be normalized and that some caveats with regards to\n\t\t//\t\tnon-standard behaviors for onsubmit apply. Namely that you\n\t\t//\t\tshould cancel form submission using `dojo.stopEvent()` on the\n\t\t//\t\tpassed event object instead of returning a boolean value from\n\t\t//\t\tthe handler itself.\n\t\t// node: DOMNode|String\n\t\t//\t\tid or reference to the element to set the attribute on\n\t\t// name: String|Object\n\t\t//\t\tthe name of the attribute to set, or a hash of key-value pairs to set.\n\t\t// value: String?\n\t\t//\t\tthe value to set for the attribute, if the name is a string.\n\t\t// returns:\n\t\t//\t\tthe DOM node\n\t\t//\n\t\t// example:\n\t\t//\t|\t// use attr() to set the tab index\n\t\t//\t|\tdojo.setAttr(\"nodeId\", \"tabIndex\", 3);\n\t\t//\n\t\t// example:\n\t\t//\tSet multiple values at once, including event handlers:\n\t\t//\t|\tdojo.setAttr(\"formId\", {\n\t\t//\t|\t\t\"foo\": \"bar\",\n\t\t//\t|\t\t\"tabIndex\": -1,\n\t\t//\t|\t\t\"method\": \"POST\",\n\t\t//\t|\t\t\"onsubmit\": function(e){\n\t\t//\t|\t\t\t// stop submitting the form. Note that the IE behavior\n\t\t//\t|\t\t\t// of returning true or false will have no effect here\n\t\t//\t|\t\t\t// since our handler is connect()ed to the built-in\n\t\t//\t|\t\t\t// onsubmit behavior and so we need to use\n\t\t//\t|\t\t\t// dojo.stopEvent() to ensure that the submission\n\t\t//\t|\t\t\t// doesn't proceed.\n\t\t//\t|\t\t\tdojo.stopEvent(e);\n\t\t//\t|\n\t\t//\t|\t\t\t// submit the form with Ajax\n\t\t//\t|\t\t\tdojo.xhrPost({ form: \"formId\" });\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\tStyle is s special case: Only set with an object hash of styles\n\t\t//\t|\tdojo.setAttr(\"someNode\",{\n\t\t//\t|\t\tid:\"bar\",\n\t\t//\t|\t\tstyle:{\n\t\t//\t|\t\t\twidth:\"200px\", height:\"100px\", color:\"#000\"\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\tAgain, only set style as an object hash of styles:\n\t\t//\t|\tvar obj = { color:\"#fff\", backgroundColor:\"#000\" };\n\t\t//\t|\tdojo.setAttr(\"someNode\", \"style\", obj);\n\t\t//\t|\n\t\t//\t|\t// though shorter to use `dojo.style()` in this case:\n\t\t//\t|\tdojo.setStyle(\"someNode\", obj);\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.removeAttr = function(node, name){\n\t\t// summary:\n\t\t//\t\tRemoves an attribute from an HTML element.\n\t\t// node: DOMNode|String\n\t\t//\t\tid or reference to the element to remove the attribute from\n\t\t// name: String\n\t\t//\t\tthe name of the attribute to remove\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.getNodeProp = function(node, name){\n\t\t// summary:\n\t\t//\t\tReturns an effective value of a property or an attribute.\n\t\t// node: DOMNode|String\n\t\t//\t\tid or reference to the element to remove the attribute from\n\t\t// name: String\n\t\t//\t\tthe name of the attribute\n\t\t// returns:\n\t\t//      the value of the attribute\n\t};\n\t=====*/\n\n\tvar forcePropNames = {\n\t\t\tinnerHTML:\t1,\n\t\t\tclassName:\t1,\n\t\t\thtmlFor:\thas(\"ie\"),\n\t\t\tvalue:\t\t1\n\t\t},\n\t\tattrNames = {\n\t\t\t// original attribute names\n\t\t\tclassname: \"class\",\n\t\t\thtmlfor: \"for\",\n\t\t\t// for IE\n\t\t\ttabindex: \"tabIndex\",\n\t\t\treadonly: \"readOnly\"\n\t\t};\n\n\tfunction _hasAttr(node, name){\n\t\tvar attr = node.getAttributeNode && node.getAttributeNode(name);\n\t\treturn attr && attr.specified; // Boolean\n\t}\n\n\t// There is a difference in the presence of certain properties and their default values\n\t// between browsers. For example, on IE \"disabled\" is present on all elements,\n\t// but it is value is \"false\"; \"tabIndex\" of <div> returns 0 by default on IE, yet other browsers\n\t// can return -1.\n\n\texports.has = function hasAttr(/*DOMNode|String*/node, /*String*/name){\n\t\tvar lc = name.toLowerCase();\n\t\treturn forcePropNames[prop.names[lc] || name] || _hasAttr(dom.byId(node), attrNames[lc] || name);\t// Boolean\n\t};\n\n\texports.get = function getAttr(/*DOMNode|String*/node, /*String*/name){\n\t\tnode = dom.byId(node);\n\t\tvar lc = name.toLowerCase(),\n\t\t\tpropName = prop.names[lc] || name,\n\t\t\tforceProp = forcePropNames[propName];\n\t\t// should we access this attribute via a property or via getAttribute()?\n\t\tvalue = node[propName];\n\t\tif(forceProp && typeof value != \"undefined\"){\n\t\t\t// node's property\n\t\t\treturn value;\t// Anything\n\t\t}\n\t\tif(propName != \"href\" && (typeof value == \"boolean\" || lang.isFunction(value))){\n\t\t\t// node's property\n\t\t\treturn value;\t// Anything\n\t\t}\n\t\t// node's attribute\n\t\t// we need _hasAttr() here to guard against IE returning a default value\n\t\tvar attrName = attrNames[lc] || name;\n\t\treturn _hasAttr(node, attrName) ? node.getAttribute(attrName) : null; // Anything\n\t};\n\n\texports.set = function setAttr(/*DOMNode|String*/node, /*String|Object*/name, /*String?*/value){\n\t\tnode = dom.byId(node);\n\t\tif(arguments.length == 2){ // inline'd type check\n\t\t\t// the object form of setter: the 2nd argument is a dictionary\n\t\t\tfor(var x in name){\n\t\t\t\texports.set(node, x, name[x]);\n\t\t\t}\n\t\t\treturn node; // DomNode\n\t\t}\n\t\tvar lc = name.toLowerCase(),\n\t\t\tpropName = prop.names[lc] || name,\n\t\t\tforceProp = forcePropNames[propName];\n\t\tif(propName == \"style\" && typeof value != \"string\"){ // inline'd type check\n\t\t\t// special case: setting a style\n\t\t\tstyle.set(node, value);\n\t\t\treturn node; // DomNode\n\t\t}\n\t\tif(forceProp || typeof value == \"boolean\" || lang.isFunction(value)){\n\t\t\treturn prop.set(node, name, value)\n\t\t}\n\t\t// node's attribute\n\t\tnode.setAttribute(attrNames[lc] || name, value);\n\t\treturn node; // DomNode\n\t};\n\n\texports.remove = function removeAttr(/*DOMNode|String*/ node, /*String*/ name){\n\t\tdom.byId(node).removeAttribute(attrNames[name.toLowerCase()] || name);\n\t};\n\n\texports.getNodeProp = function getNodeProp(/*DomNode|String*/ node, /*String*/ name){\n\t\tnode = dom.byId(node);\n\t\tvar lc = name.toLowerCase(), propName = prop.names[lc] || name;\n\t\tif((propName in node) && propName != \"href\"){\n\t\t\t// node's property\n\t\t\treturn node[propName];\t// Anything\n\t\t}\n\t\t// node's attribute\n\t\tvar attrName = attrNames[lc] || name;\n\t\treturn _hasAttr(node, attrName) ? node.getAttribute(attrName) : null; // Anything\n\t};\n});\n\n},\n'dojo/dom-construct':function(){\ndefine(\"dojo/dom-construct\", [\"exports\", \"./_base/kernel\", \"./_base/sniff\", \"./_base/window\", \"./dom\", \"./dom-attr\", \"./on\"],\n\t\tfunction(exports, dojo, has, win, dom, attr, on){\n\t// module:\n\t//\t\tdojo/dom-construct\n\t// summary:\n\t//\t\tThis module defines the core dojo DOM construction API.\n\n\t/*=====\n\tdojo.toDom = function(frag, doc){\n\t\t// summary:\n\t\t//\t\tinstantiates an HTML fragment returning the corresponding DOM.\n\t\t// frag: String\n\t\t//\t\tthe HTML fragment\n\t\t// doc: DocumentNode?\n\t\t//\t\toptional document to use when creating DOM nodes, defaults to\n\t\t//\t\tdojo.doc if not specified.\n\t\t// returns: DocumentFragment\n\t\t//\n\t\t// example:\n\t\t//\t\tCreate a table row:\n\t\t//\t|\tvar tr = dojo.toDom(\"<tr><td>First!</td></tr>\");\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo._toDom = function(frag, doc){\n\t\t// summary:\n\t\t//\t\tExisting alias for `dojo.toDom`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.place = function(node, refNode, position){\n\t\t// summary:\n\t\t//\t\tAttempt to insert node into the DOM, choosing from various positioning options.\n\t\t//\t\tReturns the first argument resolved to a DOM node.\n\t\t//\n\t\t// node: DOMNode|String\n\t\t//\t\tid or node reference, or HTML fragment starting with \"<\" to place relative to refNode\n\t\t//\n\t\t// refNode: DOMNode|String\n\t\t//\t\tid or node reference to use as basis for placement\n\t\t//\n\t\t// position: String|Number?\n\t\t//\t\tstring noting the position of node relative to refNode or a\n\t\t//\t\tnumber indicating the location in the childNodes collection of refNode.\n\t\t//\t\tAccepted string values are:\n\t\t//\t|\t* before\n\t\t//\t|\t* after\n\t\t//\t|\t* replace\n\t\t//\t|\t* only\n\t\t//\t|\t* first\n\t\t//\t|\t* last\n\t\t//\t\t\"first\" and \"last\" indicate positions as children of refNode, \"replace\" replaces refNode,\n\t\t//\t\t\"only\" replaces all children.  position defaults to \"last\" if not specified\n\t\t//\n\t\t// returns: DOMNode\n\t\t//\t\tReturned values is the first argument resolved to a DOM node.\n\t\t//\n\t\t//\t\t.place() is also a method of `dojo.NodeList`, allowing `dojo.query` node lookups.\n\t\t//\n\t\t// example:\n\t\t//\t\tPlace a node by string id as the last child of another node by string id:\n\t\t//\t|\tdojo.place(\"someNode\", \"anotherNode\");\n\t\t//\n\t\t// example:\n\t\t//\t\tPlace a node by string id before another node by string id\n\t\t//\t|\tdojo.place(\"someNode\", \"anotherNode\", \"before\");\n\t\t//\n\t\t// example:\n\t\t//\t\tCreate a Node, and place it in the body element (last child):\n\t\t//\t|\tdojo.place(\"<div></div>\", dojo.body());\n\t\t//\n\t\t// example:\n\t\t//\t\tPut a new LI as the first child of a list by id:\n\t\t//\t|\tdojo.place(\"<li></li>\", \"someUl\", \"first\");\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.create = function(tag, attrs, refNode, pos){\n\t\t// summary:\n\t\t//\t\tCreate an element, allowing for optional attribute decoration\n\t\t//\t\tand placement.\n\t\t//\n\t\t// description:\n\t\t//\t\tA DOM Element creation function. A shorthand method for creating a node or\n\t\t//\t\ta fragment, and allowing for a convenient optional attribute setting step,\n\t\t//\t\tas well as an optional DOM placement reference.\n\t\t//|\n\t\t//\t\tAttributes are set by passing the optional object through `dojo.setAttr`.\n\t\t//\t\tSee `dojo.setAttr` for noted caveats and nuances, and API if applicable.\n\t\t//|\n\t\t//\t\tPlacement is done via `dojo.place`, assuming the new node to be the action\n\t\t//\t\tnode, passing along the optional reference node and position.\n\t\t//\n\t\t// tag: DOMNode|String\n\t\t//\t\tA string of the element to create (eg: \"div\", \"a\", \"p\", \"li\", \"script\", \"br\"),\n\t\t//\t\tor an existing DOM node to process.\n\t\t//\n\t\t// attrs: Object\n\t\t//\t\tAn object-hash of attributes to set on the newly created node.\n\t\t//\t\tCan be null, if you don't want to set any attributes/styles.\n\t\t//\t\tSee: `dojo.setAttr` for a description of available attributes.\n\t\t//\n\t\t// refNode: DOMNode?|String?\n\t\t//\t\tOptional reference node. Used by `dojo.place` to place the newly created\n\t\t//\t\tnode somewhere in the dom relative to refNode. Can be a DomNode reference\n\t\t//\t\tor String ID of a node.\n\t\t//\n\t\t// pos: String?\n\t\t//\t\tOptional positional reference. Defaults to \"last\" by way of `dojo.place`,\n\t\t//\t\tthough can be set to \"first\",\"after\",\"before\",\"last\", \"replace\" or \"only\"\n\t\t//\t\tto further control the placement of the new node relative to the refNode.\n\t\t//\t\t'refNode' is required if a 'pos' is specified.\n\t\t//\n\t\t// returns: DOMNode\n\t\t//\n\t\t// example:\n\t\t//\t\tCreate a DIV:\n\t\t//\t|\tvar n = dojo.create(\"div\");\n\t\t//\n\t\t// example:\n\t\t//\t\tCreate a DIV with content:\n\t\t//\t|\tvar n = dojo.create(\"div\", { innerHTML:\"<p>hi</p>\" });\n\t\t//\n\t\t// example:\n\t\t//\t\tPlace a new DIV in the BODY, with no attributes set\n\t\t//\t|\tvar n = dojo.create(\"div\", null, dojo.body());\n\t\t//\n\t\t// example:\n\t\t//\t\tCreate an UL, and populate it with LI's. Place the list as the first-child of a\n\t\t//\t\tnode with id=\"someId\":\n\t\t//\t|\tvar ul = dojo.create(\"ul\", null, \"someId\", \"first\");\n\t\t//\t|\tvar items = [\"one\", \"two\", \"three\", \"four\"];\n\t\t//\t|\tdojo.forEach(items, function(data){\n\t\t//\t|\t\tdojo.create(\"li\", { innerHTML: data }, ul);\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\t\tCreate an anchor, with an href. Place in BODY:\n\t\t//\t|\tdojo.create(\"a\", { href:\"foo.html\", title:\"Goto FOO!\" }, dojo.body());\n\t\t//\n\t\t// example:\n\t\t//\t\tCreate a `dojo.NodeList()` from a new element (for syntatic sugar):\n\t\t//\t|\tdojo.query(dojo.create('div'))\n\t\t//\t|\t\t.addClass(\"newDiv\")\n\t\t//\t|\t\t.onclick(function(e){ console.log('clicked', e.target) })\n\t\t//\t|\t\t.place(\"#someNode\"); // redundant, but cleaner.\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.empty = function(node){\n\t\t\t// summary:\n\t\t\t//\t\tsafely removes all children of the node.\n\t\t\t// node: DOMNode|String\n\t\t\t//\t\ta reference to a DOM node or an id.\n\t\t\t// example:\n\t\t\t//\t\tDestroy node's children byId:\n\t\t\t//\t|\tdojo.empty(\"someId\");\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tDestroy all nodes' children in a list by reference:\n\t\t\t//\t|\tdojo.query(\".someNode\").forEach(dojo.empty);\n\t}\n\t=====*/\n\n\t/*=====\n\tdojo.destroy = function(node){\n\t\t// summary:\n\t\t//\t\tRemoves a node from its parent, clobbering it and all of its\n\t\t//\t\tchildren.\n\t\t//\n\t\t// description:\n\t\t//\t\tRemoves a node from its parent, clobbering it and all of its\n\t\t//\t\tchildren. Function only works with DomNodes, and returns nothing.\n\t\t//\n\t\t// node: DOMNode|String\n\t\t//\t\tA String ID or DomNode reference of the element to be destroyed\n\t\t//\n\t\t// example:\n\t\t//\t\tDestroy a node byId:\n\t\t//\t|\tdojo.destroy(\"someId\");\n\t\t//\n\t\t// example:\n\t\t//\t\tDestroy all nodes in a list by reference:\n\t\t//\t|\tdojo.query(\".someNode\").forEach(dojo.destroy);\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo._destroyElement = function(node){\n\t\t// summary:\n\t\t//\t\tExisting alias for `dojo.destroy`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*/\n\n\t// support stuff for dojo.toDom\n\tvar tagWrap = {\n\t\t\toption: [\"select\"],\n\t\t\ttbody: [\"table\"],\n\t\t\tthead: [\"table\"],\n\t\t\ttfoot: [\"table\"],\n\t\t\ttr: [\"table\", \"tbody\"],\n\t\t\ttd: [\"table\", \"tbody\", \"tr\"],\n\t\t\tth: [\"table\", \"thead\", \"tr\"],\n\t\t\tlegend: [\"fieldset\"],\n\t\t\tcaption: [\"table\"],\n\t\t\tcolgroup: [\"table\"],\n\t\t\tcol: [\"table\", \"colgroup\"],\n\t\t\tli: [\"ul\"]\n\t\t},\n\t\treTag = /<\\s*([\\w\\:]+)/,\n\t\tmasterNode = {}, masterNum = 0,\n\t\tmasterName = \"__\" + dojo._scopeName + \"ToDomId\";\n\n\t// generate start/end tag strings to use\n\t// for the injection for each special tag wrap case.\n\tfor(var param in tagWrap){\n\t\tif(tagWrap.hasOwnProperty(param)){\n\t\t\tvar tw = tagWrap[param];\n\t\t\ttw.pre = param == \"option\" ? '<select multiple=\"multiple\">' : \"<\" + tw.join(\"><\") + \">\";\n\t\t\ttw.post = \"</\" + tw.reverse().join(\"></\") + \">\";\n\t\t\t// the last line is destructive: it reverses the array,\n\t\t\t// but we don't care at this point\n\t\t}\n\t}\n\n\tfunction _insertBefore(/*DomNode*/node, /*DomNode*/ref){\n\t\tvar parent = ref.parentNode;\n\t\tif(parent){\n\t\t\tparent.insertBefore(node, ref);\n\t\t}\n\t}\n\n\tfunction _insertAfter(/*DomNode*/node, /*DomNode*/ref){\n\t\t// summary:\n\t\t//\t\tTry to insert node after ref\n\t\tvar parent = ref.parentNode;\n\t\tif(parent){\n\t\t\tif(parent.lastChild == ref){\n\t\t\t\tparent.appendChild(node);\n\t\t\t}else{\n\t\t\t\tparent.insertBefore(node, ref.nextSibling);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar _destroyContainer = null,\n\t\t_destroyDoc;\n\t\ton(window, \"unload\", function(){\n\t\t_destroyContainer = null; //prevent IE leak\n\t});\n\t\n\texports.toDom = function toDom(frag, doc){\n\t\tdoc = doc || win.doc;\n\t\tvar masterId = doc[masterName];\n\t\tif(!masterId){\n\t\t\tdoc[masterName] = masterId = ++masterNum + \"\";\n\t\t\tmasterNode[masterId] = doc.createElement(\"div\");\n\t\t}\n\n\t\t// make sure the frag is a string.\n\t\tfrag += \"\";\n\n\t\t// find the starting tag, and get node wrapper\n\t\tvar match = frag.match(reTag),\n\t\t\ttag = match ? match[1].toLowerCase() : \"\",\n\t\t\tmaster = masterNode[masterId],\n\t\t\twrap, i, fc, df;\n\t\tif(match && tagWrap[tag]){\n\t\t\twrap = tagWrap[tag];\n\t\t\tmaster.innerHTML = wrap.pre + frag + wrap.post;\n\t\t\tfor(i = wrap.length; i; --i){\n\t\t\t\tmaster = master.firstChild;\n\t\t\t}\n\t\t}else{\n\t\t\tmaster.innerHTML = frag;\n\t\t}\n\n\t\t// one node shortcut => return the node itself\n\t\tif(master.childNodes.length == 1){\n\t\t\treturn master.removeChild(master.firstChild); // DOMNode\n\t\t}\n\n\t\t// return multiple nodes as a document fragment\n\t\tdf = doc.createDocumentFragment();\n\t\twhile(fc = master.firstChild){ // intentional assignment\n\t\t\tdf.appendChild(fc);\n\t\t}\n\t\treturn df; // DOMNode\n\t};\n\n\texports.place = function place(/*DOMNode|String*/node, /*DOMNode|String*/refNode, /*String|Number?*/position){\n\t\trefNode = dom.byId(refNode);\n\t\tif(typeof node == \"string\"){ // inline'd type check\n\t\t\tnode = /^\\s*</.test(node) ? exports.toDom(node, refNode.ownerDocument) : dom.byId(node);\n\t\t}\n\t\tif(typeof position == \"number\"){ // inline'd type check\n\t\t\tvar cn = refNode.childNodes;\n\t\t\tif(!cn.length || cn.length <= position){\n\t\t\t\trefNode.appendChild(node);\n\t\t\t}else{\n\t\t\t\t_insertBefore(node, cn[position < 0 ? 0 : position]);\n\t\t\t}\n\t\t}else{\n\t\t\tswitch(position){\n\t\t\t\tcase \"before\":\n\t\t\t\t\t_insertBefore(node, refNode);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"after\":\n\t\t\t\t\t_insertAfter(node, refNode);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"replace\":\n\t\t\t\t\trefNode.parentNode.replaceChild(node, refNode);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"only\":\n\t\t\t\t\texports.empty(refNode);\n\t\t\t\t\trefNode.appendChild(node);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"first\":\n\t\t\t\t\tif(refNode.firstChild){\n\t\t\t\t\t\t_insertBefore(node, refNode.firstChild);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// else fallthrough...\n\t\t\t\tdefault: // aka: last\n\t\t\t\t\trefNode.appendChild(node);\n\t\t\t}\n\t\t}\n\t\treturn node; // DomNode\n\t};\n\n\texports.create = function create(/*DOMNode|String*/tag, /*Object*/attrs, /*DOMNode?|String?*/refNode, /*String?*/pos){\n\t\tvar doc = win.doc;\n\t\tif(refNode){\n\t\t\trefNode = dom.byId(refNode);\n\t\t\tdoc = refNode.ownerDocument;\n\t\t}\n\t\tif(typeof tag == \"string\"){ // inline'd type check\n\t\t\ttag = doc.createElement(tag);\n\t\t}\n\t\tif(attrs){ attr.set(tag, attrs); }\n\t\tif(refNode){ exports.place(tag, refNode, pos); }\n\t\treturn tag; // DomNode\n\t};\n\n\texports.empty =\n\t\t\t\thas(\"ie\") ? function(node){\n\t\t\tnode = dom.byId(node);\n\t\t\tfor(var c; c = node.lastChild;){ // intentional assignment\n\t\t\t\texports.destroy(c);\n\t\t\t}\n\t\t} :\n\t\t\t\tfunction(node){\n\t\t\tdom.byId(node).innerHTML = \"\";\n\t\t};\n\n\texports.destroy = function destroy(/*DOMNode|String*/node){\n\t\tnode = dom.byId(node);\n\t\ttry{\n\t\t\tvar doc = node.ownerDocument;\n\t\t\t// cannot use _destroyContainer.ownerDocument since this can throw an exception on IE\n\t\t\tif(!_destroyContainer || _destroyDoc != doc){\n\t\t\t\t_destroyContainer = doc.createElement(\"div\");\n\t\t\t\t_destroyDoc = doc;\n\t\t\t}\n\t\t\t_destroyContainer.appendChild(node.parentNode ? node.parentNode.removeChild(node) : node);\n\t\t\t// NOTE: see http://trac.dojotoolkit.org/ticket/2931. This may be a bug and not a feature\n\t\t\t_destroyContainer.innerHTML = \"\";\n\t\t}catch(e){\n\t\t\t/* squelch */\n\t\t}\n\t};\n});\n\n},\n'dojo/keys':function(){\ndefine(\"dojo/keys\", [\"./_base/kernel\", \"./_base/sniff\"], function(dojo, has) {\n\t// module:\n\t//\t\tdojo/keys\n\t// summary:\n\t//\t\tkey constants\n// Constants\n\n// Public: client code should test\n// keyCode against these named constants, as the\n// actual codes can vary by browser.\nreturn dojo.keys = {\n\t// summary:\n\t//\t\tDefinitions for common key values\n\tBACKSPACE: 8,\n\tTAB: 9,\n\tCLEAR: 12,\n\tENTER: 13,\n\tSHIFT: 16,\n\tCTRL: 17,\n\tALT: 18,\n\tMETA: has(\"safari\") ? 91 : 224,\t\t// the apple key on macs\n\tPAUSE: 19,\n\tCAPS_LOCK: 20,\n\tESCAPE: 27,\n\tSPACE: 32,\n\tPAGE_UP: 33,\n\tPAGE_DOWN: 34,\n\tEND: 35,\n\tHOME: 36,\n\tLEFT_ARROW: 37,\n\tUP_ARROW: 38,\n\tRIGHT_ARROW: 39,\n\tDOWN_ARROW: 40,\n\tINSERT: 45,\n\tDELETE: 46,\n\tHELP: 47,\n\tLEFT_WINDOW: 91,\n\tRIGHT_WINDOW: 92,\n\tSELECT: 93,\n\tNUMPAD_0: 96,\n\tNUMPAD_1: 97,\n\tNUMPAD_2: 98,\n\tNUMPAD_3: 99,\n\tNUMPAD_4: 100,\n\tNUMPAD_5: 101,\n\tNUMPAD_6: 102,\n\tNUMPAD_7: 103,\n\tNUMPAD_8: 104,\n\tNUMPAD_9: 105,\n\tNUMPAD_MULTIPLY: 106,\n\tNUMPAD_PLUS: 107,\n\tNUMPAD_ENTER: 108,\n\tNUMPAD_MINUS: 109,\n\tNUMPAD_PERIOD: 110,\n\tNUMPAD_DIVIDE: 111,\n\tF1: 112,\n\tF2: 113,\n\tF3: 114,\n\tF4: 115,\n\tF5: 116,\n\tF6: 117,\n\tF7: 118,\n\tF8: 119,\n\tF9: 120,\n\tF10: 121,\n\tF11: 122,\n\tF12: 123,\n\tF13: 124,\n\tF14: 125,\n\tF15: 126,\n\tNUM_LOCK: 144,\n\tSCROLL_LOCK: 145,\n\tUP_DPAD: 175,\n\tDOWN_DPAD: 176,\n\tLEFT_DPAD: 177,\n\tRIGHT_DPAD: 178,\n\t// virtual key mapping\n\tcopyKey: has(\"mac\") && !has(\"air\") ? (has(\"safari\") ? 91 : 224 ) : 17\n};\n});\n\n},\n'dojo/domReady':function(){\ndefine(['./has'], function(has){\n\tvar global = this,\n\t\tdoc = document,\n\t\treadyStates = { 'loaded': 1, 'complete': 1 },\n\t\tfixReadyState = typeof doc.readyState != \"string\",\n\t\tready = !!readyStates[doc.readyState];\n\n\t// For FF <= 3.5\n\tif(fixReadyState){ doc.readyState = \"loading\"; }\n\n\tif(!ready){\n\t\tvar readyQ = [], tests = [],\n\t\t\tdetectReady = function(evt){\n\t\t\t\tevt = evt || global.event;\n\t\t\t\tif(ready || (evt.type == \"readystatechange\" && !readyStates[doc.readyState])){ return; }\n\t\t\t\tready = 1;\n\n\t\t\t\t// For FF <= 3.5\n\t\t\t\tif(fixReadyState){ doc.readyState = \"complete\"; }\n\n\t\t\t\twhile(readyQ.length){\n\t\t\t\t\t(readyQ.shift())();\n\t\t\t\t}\n\t\t\t},\n\t\t\ton = function(node, event){\n\t\t\t\tnode.addEventListener(event, detectReady, false);\n\t\t\t\treadyQ.push(function(){ node.removeEventListener(event, detectReady, false); });\n\t\t\t};\n\n\t\tif(!has(\"dom-addeventlistener\")){\n\t\t\ton = function(node, event){\n\t\t\t\tevent = \"on\" + event;\n\t\t\t\tnode.attachEvent(event, detectReady);\n\t\t\t\treadyQ.push(function(){ node.detachEvent(event, detectReady); });\n\t\t\t};\n\n\t\t\tvar div = doc.createElement(\"div\");\n\t\t\ttry{\n\t\t\t\tif(div.doScroll && global.frameElement === null){\n\t\t\t\t\t// the doScroll test is only useful if we're in the top-most frame\n\t\t\t\t\ttests.push(function(){\n\t\t\t\t\t\t// Derived with permission from Diego Perini's IEContentLoaded\n\t\t\t\t\t\t// http://javascript.nwbox.com/IEContentLoaded/\n\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\tdiv.doScroll(\"left\");\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}catch(e){}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}catch(e){}\n\t\t}\n\n\t\ton(doc, \"DOMContentLoaded\");\n\t\ton(global, \"load\");\n\n\t\tif(\"onreadystatechange\" in doc){\n\t\t\ton(doc, \"readystatechange\");\n\t\t}else if(!fixReadyState){\n\t\t\t// if the ready state property exists and there's\n\t\t\t// no readystatechange event, poll for the state\n\t\t\t// to change\n\t\t\ttests.push(function(){\n\t\t\t\treturn readyStates[doc.readyState];\n\t\t\t});\n\t\t}\n\n\t\tif(tests.length){\n\t\t\tvar poller = function(){\n\t\t\t\tif(ready){ return; }\n\t\t\t\tvar i = tests.length;\n\t\t\t\twhile(i--){\n\t\t\t\t\tif(tests[i]()){\n\t\t\t\t\t\tdetectReady(\"poller\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsetTimeout(poller, 30);\n\t\t\t};\n\t\t\tpoller();\n\t\t}\n\t}\n\n\tfunction domReady(callback){\n\t\tif(ready){\n\t\t\tcallback(1);\n\t\t}else{\n\t\t\treadyQ.push(callback);\n\t\t}\n\t}\n\tdomReady.load = function(id, req, load){\n\t\tdomReady(load);\n\t};\n\n\treturn domReady;\n});\n\n},\n'dojo/_base/lang':function(){\ndefine([\"./kernel\", \"../has\", \"./sniff\"], function(dojo, has){\n\t//\tmodule:\n\t//\t\tdojo/_base/lang\n\t//\tsummary:\n\t//\t\tThis module defines Javascript language extensions.\n\n\thas.add(\"bug-for-in-skips-shadowed\", function(){\n\t\t// if true, the for-in interator skips object properties that exist in Object's prototype (IE 6 - ?)\n\t\tfor(var i in {toString: 1}){\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t});\n\n\tvar _extraNames =\n\t\t\thas(\"bug-for-in-skips-shadowed\") ?\n\t\t\t\t\"hasOwnProperty.valueOf.isPrototypeOf.propertyIsEnumerable.toLocaleString.toString.constructor\".split(\".\") : [],\n\n\t\t_extraLen = _extraNames.length,\n\n\t\t_mixin = function(dest, source, copyFunc){\n\t\t\tvar name, s, i, empty = {};\n\t\t\tfor(name in source){\n\t\t\t\t// the (!(name in empty) || empty[name] !== s) condition avoids copying properties in \"source\"\n\t\t\t\t// inherited from Object.prototype.\t For example, if dest has a custom toString() method,\n\t\t\t\t// don't overwrite it with the toString() method that source inherited from Object.prototype\n\t\t\t\ts = source[name];\n\t\t\t\tif(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){\n\t\t\t\t\tdest[name] = copyFunc ? copyFunc(s) : s;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(has(\"bug-for-in-skips-shadowed\")){\n\t\t\t\tif(source){\n\t\t\t\t\tfor(i = 0; i < _extraLen; ++i){\n\t\t\t\t\t\tname = _extraNames[i];\n\t\t\t\t\t\ts = source[name];\n\t\t\t\t\t\tif(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){\n\t\t\t\t\t\t\tdest[name] = copyFunc ? copyFunc(s) : s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn dest; // Object\n\t\t},\n\n\t\tmixin = function(dest, sources){\n\t\t\tif(!dest){ dest = {}; }\n\t\t\tfor(var i = 1, l = arguments.length; i < l; i++){\n\t\t\t\tlang._mixin(dest, arguments[i]);\n\t\t\t}\n\t\t\treturn dest; // Object\n\t\t},\n\n\t\tgetProp = function(/*Array*/parts, /*Boolean*/create, /*Object*/context){\n\t\t\tvar p, i = 0, dojoGlobal = dojo.global;\n\t\t\tif(!context){\n\t\t\t\tif(!parts.length){\n\t\t\t\t\treturn dojoGlobal;\n\t\t\t\t}else{\n\t\t\t\t\tp = parts[i++];\n\t\t\t\t\ttry{\n\t\t\t\t\t\tcontext = dojo.scopeMap[p] && dojo.scopeMap[p][1];\n\t\t\t\t\t}catch(e){}\n\t\t\t\t\tcontext = context || (p in dojoGlobal ? dojoGlobal[p] : (create ? dojoGlobal[p] = {} : undefined));\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(context && (p = parts[i++])){\n\t\t\t\tcontext = (p in context ? context[p] : (create ? context[p] = {} : undefined));\n\t\t\t}\n\t\t\treturn context; // mixed\n\t\t},\n\n\t\tsetObject = function(name, value, context){\n\t\t\tvar parts = name.split(\".\"), p = parts.pop(), obj = getProp(parts, true, context);\n\t\t\treturn obj && p ? (obj[p] = value) : undefined; // Object\n\t\t},\n\n\t\tgetObject = function(name, create, context){\n\t\t\treturn getProp(name.split(\".\"), create, context); // Object\n\t\t},\n\n\t\texists = function(name, obj){\n\t\t\treturn lang.getObject(name, false, obj) !== undefined; // Boolean\n\t\t},\n\n\t\topts = Object.prototype.toString,\n\n\t\t// Crockford (ish) functions\n\n\t\tisString = function(it){\n\t\t\treturn (typeof it == \"string\" || it instanceof String); // Boolean\n\t\t},\n\n\t\tisArray = function(it){\n\t\t\treturn it && (it instanceof Array || typeof it == \"array\"); // Boolean\n\t\t},\n\n\t\tisFunction = function(it){\n\t\t\treturn opts.call(it) === \"[object Function]\";\n\t\t},\n\n\t\tisObject = function(it){\n\t\t\treturn it !== undefined &&\n\t\t\t\t(it === null || typeof it == \"object\" || lang.isArray(it) || lang.isFunction(it)); // Boolean\n\t\t},\n\n\t\tisArrayLike = function(it){\n\t\t\treturn it && it !== undefined && // Boolean\n\t\t\t\t// keep out built-in constructors (Number, String, ...) which have length\n\t\t\t\t// properties\n\t\t\t\t!lang.isString(it) && !lang.isFunction(it) &&\n\t\t\t\t!(it.tagName && it.tagName.toLowerCase() == 'form') &&\n\t\t\t\t(lang.isArray(it) || isFinite(it.length));\n\t\t},\n\n\t\tisAlien = function(it){\n\t\t\treturn it && !lang.isFunction(it) && /\\{\\s*\\[native code\\]\\s*\\}/.test(String(it)); // Boolean\n\t\t},\n\n\t\textend = function(constructor, props){\n\t\t\tfor(var i=1, l=arguments.length; i<l; i++){\n\t\t\t\tlang._mixin(constructor.prototype, arguments[i]);\n\t\t\t}\n\t\t\treturn constructor; // Object\n\t\t},\n\n\t\t_hitchArgs = function(scope, method){\n\t\t\tvar pre = _toArray(arguments, 2);\n\t\t\tvar named = lang.isString(method);\n\t\t\treturn function(){\n\t\t\t\t// arrayify arguments\n\t\t\t\tvar args = _toArray(arguments);\n\t\t\t\t// locate our method\n\t\t\t\tvar f = named ? (scope||dojo.global)[method] : method;\n\t\t\t\t// invoke with collected args\n\t\t\t\treturn f && f.apply(scope || this, pre.concat(args)); // mixed\n\t\t\t}; // Function\n\t\t},\n\n\t\thitch = function(scope, method){\n\t\t\tif(arguments.length > 2){\n\t\t\t\treturn lang._hitchArgs.apply(dojo, arguments); // Function\n\t\t\t}\n\t\t\tif(!method){\n\t\t\t\tmethod = scope;\n\t\t\t\tscope = null;\n\t\t\t}\n\t\t\tif(lang.isString(method)){\n\t\t\t\tscope = scope || dojo.global;\n\t\t\t\tif(!scope[method]){ throw(['dojo.hitch: scope[\"', method, '\"] is null (scope=\"', scope, '\")'].join('')); }\n\t\t\t\treturn function(){ return scope[method].apply(scope, arguments || []); }; // Function\n\t\t\t}\n\t\t\treturn !scope ? method : function(){ return method.apply(scope, arguments || []); }; // Function\n\t\t},\n\n\t\tdelegate = (function(){\n\t\t\t// boodman/crockford delegation w/ cornford optimization\n\t\t\tfunction TMP(){}\n\t\t\treturn function(obj, props){\n\t\t\t\tTMP.prototype = obj;\n\t\t\t\tvar tmp = new TMP();\n\t\t\t\tTMP.prototype = null;\n\t\t\t\tif(props){\n\t\t\t\t\tlang._mixin(tmp, props);\n\t\t\t\t}\n\t\t\t\treturn tmp; // Object\n\t\t\t};\n\t\t})(),\n\n\t\tefficient = function(obj, offset, startWith){\n\t\t\treturn (startWith||[]).concat(Array.prototype.slice.call(obj, offset||0));\n\t\t},\n\n\t\t_toArray =\n\t\t\thas(\"ie\") ?\n\t\t\t\t(function(){\n\t\t\t\t\tfunction slow(obj, offset, startWith){\n\t\t\t\t\t\tvar arr = startWith||[];\n\t\t\t\t\t\tfor(var x = offset || 0; x < obj.length; x++){\n\t\t\t\t\t\t\tarr.push(obj[x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn arr;\n\t\t\t\t\t}\n\t\t\t\t\treturn function(obj){\n\t\t\t\t\t\treturn ((obj.item) ? slow : efficient).apply(this, arguments);\n\t\t\t\t\t};\n\t\t\t\t})() : efficient,\n\n\t\tpartial = function(/*Function|String*/method /*, ...*/){\n\t\t\tvar arr = [ null ];\n\t\t\treturn lang.hitch.apply(dojo, arr.concat(lang._toArray(arguments))); // Function\n\t\t},\n\n\t\tclone = function(/*anything*/ src){\n\t\t\tif(!src || typeof src != \"object\" || lang.isFunction(src)){\n\t\t\t\t// null, undefined, any non-object, or function\n\t\t\t\treturn src;\t// anything\n\t\t\t}\n\t\t\tif(src.nodeType && \"cloneNode\" in src){\n\t\t\t\t// DOM Node\n\t\t\t\treturn src.cloneNode(true); // Node\n\t\t\t}\n\t\t\tif(src instanceof Date){\n\t\t\t\t// Date\n\t\t\t\treturn new Date(src.getTime());\t// Date\n\t\t\t}\n\t\t\tif(src instanceof RegExp){\n\t\t\t\t// RegExp\n\t\t\t\treturn new RegExp(src);   // RegExp\n\t\t\t}\n\t\t\tvar r, i, l;\n\t\t\tif(lang.isArray(src)){\n\t\t\t\t// array\n\t\t\t\tr = [];\n\t\t\t\tfor(i = 0, l = src.length; i < l; ++i){\n\t\t\t\t\tif(i in src){\n\t\t\t\t\t\tr.push(clone(src[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t// we don't clone functions for performance reasons\n\t//\t\t}else if(d.isFunction(src)){\n\t//\t\t\t// function\n\t//\t\t\tr = function(){ return src.apply(this, arguments); };\n\t\t\t}else{\n\t\t\t\t// generic objects\n\t\t\t\tr = src.constructor ? new src.constructor() : {};\n\t\t\t}\n\t\t\treturn lang._mixin(r, src, clone);\n\t\t},\n\n\n\t\ttrim = String.prototype.trim ?\n\t\t\tfunction(str){ return str.trim(); } :\n\t\t\tfunction(str){ return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, ''); },\n\n\n\t\t_pattern = /\\{([^\\}]+)\\}/g,\n\n\t\treplace = function(tmpl, map, pattern){\n\t\t\treturn tmpl.replace(pattern || _pattern, lang.isFunction(map) ?\n\t\t\t\tmap : function(_, k){ return getObject(k, false, map); });\n\t\t},\n\n\t\tlang = {\n\t\t\t_extraNames:_extraNames,\n\t\t\t_mixin:_mixin,\n\t\t\tmixin:mixin,\n\t\t\tsetObject:setObject,\n\t\t\tgetObject:getObject,\n\t\t\texists:exists,\n\t\t\tisString:isString,\n\t\t\tisArray:isArray,\n\t\t\tisFunction:isFunction,\n\t\t\tisObject:isObject,\n\t\t\tisArrayLike:isArrayLike,\n\t\t\tisAlien:isAlien,\n\t\t\textend:extend,\n\t\t\t_hitchArgs:_hitchArgs,\n\t\t\thitch:hitch,\n\t\t\tdelegate:delegate,\n\t\t\t_toArray:_toArray,\n\t\t\tpartial:partial,\n\t\t\tclone:clone,\n\t\t\ttrim:trim,\n\t\t\treplace:replace\n\t\t};\n\n\t1 && mixin(dojo, lang);\n\treturn lang;\n\n\t/*=====\n\tdojo._extraNames\n\t// summary:\n\t//\t\tArray of strings. Lists property names that must be explicitly processed during for-in interation\n\t//\t\tin environments that have has(\"bug-for-in-skips-shadowed\") true.\n\t=====*/\n\n\t/*=====\n\tdojo._mixin = function(dest, source, copyFunc){\n\t\t//\tsummary:\n\t\t//\t\tCopies/adds all properties of source to dest; returns dest.\n\t\t//\tdest: Object:\n\t\t//\t\tThe object to which to copy/add all properties contained in source.\n\t\t//\tsource: Object:\n\t\t//\t\tThe object from which to draw all properties to copy into dest.\n\t\t//\tcopyFunc: Function?:\n\t\t//\t\tThe process used to copy/add a property in source; defaults to the Javascript assignment operator.\n\t\t//\treturns:\n\t\t//\t\tdest, as modified\n\t\t//\tdescription:\n\t\t//\t\tAll properties, including functions (sometimes termed \"methods\"), excluding any non-standard extensions\n\t\t//\t\tfound in Object.prototype, are copied/added to dest. Copying/adding each particular property is\n\t\t//\t\tdelegated to copyFunc (if any); copyFunc defaults to the Javascript assignment operator if not provided.\n\t\t//\t\tNotice that by default, _mixin executes a so-called \"shallow copy\" and aggregate types are copied/added by reference.\n\t}\n\t=====*/\n\n\t/*=====\n\tdojo.mixin = function(dest, sources){\n\t//\tsummary:\n\t//\t\tCopies/adds all properties of one or more sources to dest; returns dest.\n\t//\tdest: Object\n\t//\t\tThe object to which to copy/add all properties contained in source. If dest is falsy, then\n\t//\t\ta new object is manufactured before copying/adding properties begins.\n\t//\tsources: Object...\n\t//\t\tOne of more objects from which to draw all properties to copy into dest. sources are processed\n\t//\t\tleft-to-right and if more than one of these objects contain the same property name, the right-most\n\t//\t\tvalue \"wins\".\n\t//\treturns: Object\n\t//\t\tdest, as modified\n\t//\tdescription:\n\t//\t\tAll properties, including functions (sometimes termed \"methods\"), excluding any non-standard extensions\n\t//\t\tfound in Object.prototype, are copied/added from sources to dest. sources are processed left to right.\n\t//\t\tThe Javascript assignment operator is used to copy/add each property; therefore, by default, mixin\n\t//\t\texecutes a so-called \"shallow copy\" and aggregate types are copied/added by reference.\n\t//\texample:\n\t//\t\tmake a shallow copy of an object\n\t//\t| var copy = lang.mixin({}, source);\n\t//\texample:\n\t//\t\tmany class constructors often take an object which specifies\n\t//\t\tvalues to be configured on the object. In this case, it is\n\t//\t\toften simplest to call `lang.mixin` on the `this` object:\n\t//\t| dojo.declare(\"acme.Base\", null, {\n\t//\t|\t\tconstructor: function(properties){\n\t//\t|\t\t\t// property configuration:\n\t//\t|\t\t\tlang.mixin(this, properties);\n\t//\t|\n\t//\t|\t\t\tconsole.log(this.quip);\n\t//\t|\t\t\t//\t...\n\t//\t|\t\t},\n\t//\t|\t\tquip: \"I wasn't born yesterday, you know - I've seen movies.\",\n\t//\t|\t\t// ...\n\t//\t| });\n\t//\t|\n\t//\t| // create an instance of the class and configure it\n\t//\t| var b = new acme.Base({quip: \"That's what it does!\" });\n\t//\texample:\n\t//\t\tcopy in properties from multiple objects\n\t//\t| var flattened = lang.mixin(\n\t//\t|\t\t{\n\t//\t|\t\t\tname: \"Frylock\",\n\t//\t|\t\t\tbraces: true\n\t//\t|\t\t},\n\t//\t|\t\t{\n\t//\t|\t\t\tname: \"Carl Brutanananadilewski\"\n\t//\t|\t\t}\n\t//\t| );\n\t//\t|\n\t//\t| // will print \"Carl Brutanananadilewski\"\n\t//\t| console.log(flattened.name);\n\t//\t| // will print \"true\"\n\t//\t| console.log(flattened.braces);\n\t}\n\t=====*/\n\n\t/*=====\n\tdojo.setObject = function(name, value, context){\n\t// summary:\n\t//\t\tSet a property from a dot-separated string, such as \"A.B.C\"\n\t//\tdescription:\n\t//\t\tUseful for longer api chains where you have to test each object in\n\t//\t\tthe chain, or when you have an object reference in string format.\n\t//\t\tObjects are created as needed along `path`. Returns the passed\n\t//\t\tvalue if setting is successful or `undefined` if not.\n\t//\tname: String\n\t//\t\tPath to a property, in the form \"A.B.C\".\n\t//\tvalue: anything\n\t//\t\tvalue or object to place at location given by name\n\t//\tcontext: Object?\n\t//\t\tOptional. Object to use as root of path. Defaults to\n\t//\t\t`dojo.global`.\n\t//\texample:\n\t//\t\tset the value of `foo.bar.baz`, regardless of whether\n\t//\t\tintermediate objects already exist:\n\t//\t| lang.setObject(\"foo.bar.baz\", value);\n\t//\texample:\n\t//\t\twithout `lang.setObject`, we often see code like this:\n\t//\t| // ensure that intermediate objects are available\n\t//\t| if(!obj[\"parent\"]){ obj.parent = {}; }\n\t//\t| if(!obj.parent[\"child\"]){ obj.parent.child = {}; }\n\t//\t| // now we can safely set the property\n\t//\t| obj.parent.child.prop = \"some value\";\n\t//\t\twhereas with `lang.setObject`, we can shorten that to:\n\t//\t| lang.setObject(\"parent.child.prop\", \"some value\", obj);\n\t}\n\t=====*/\n\n\t/*=====\n\tdojo.getObject = function(name, create, context){\n\t// summary:\n\t//\t\tGet a property from a dot-separated string, such as \"A.B.C\"\n\t//\tdescription:\n\t//\t\tUseful for longer api chains where you have to test each object in\n\t//\t\tthe chain, or when you have an object reference in string format.\n\t//\tname: String\n\t//\t\tPath to an property, in the form \"A.B.C\".\n\t//\tcreate: Boolean?\n\t//\t\tOptional. Defaults to `false`. If `true`, Objects will be\n\t//\t\tcreated at any point along the 'path' that is undefined.\n\t//\tcontext: Object?\n\t//\t\tOptional. Object to use as root of path. Defaults to\n\t//\t\t'dojo.global'. Null may be passed.\n\t}\n\t=====*/\n\n\t/*=====\n\tdojo.exists = function(name, obj){\n\t//\tsummary:\n\t//\t\tdetermine if an object supports a given method\n\t//\tdescription:\n\t//\t\tuseful for longer api chains where you have to test each object in\n\t//\t\tthe chain. Useful for object and method detection.\n\t//\tname: String\n\t//\t\tPath to an object, in the form \"A.B.C\".\n\t//\tobj: Object?\n\t//\t\tObject to use as root of path. Defaults to\n\t//\t\t'dojo.global'. Null may be passed.\n\t//\texample:\n\t//\t| // define an object\n\t//\t| var foo = {\n\t//\t|\t\tbar: { }\n\t//\t| };\n\t//\t|\n\t//\t| // search the global scope\n\t//\t| lang.exists(\"foo.bar\"); // true\n\t//\t| lang.exists(\"foo.bar.baz\"); // false\n\t//\t|\n\t//\t| // search from a particular scope\n\t//\t| lang.exists(\"bar\", foo); // true\n\t//\t| lang.exists(\"bar.baz\", foo); // false\n\t}\n\t=====*/\n\n\t/*=====\n\tdojo.isString = function(it){\n\t//\tsummary:\n\t//\t\tReturn true if it is a String\n\t//\tit: anything\n\t//\t\tItem to test.\n\t}\n\t=====*/\n\n\t/*=====\n\tdojo.isArray = function(it){\n\t//\tsummary:\n\t//\t\tReturn true if it is an Array.\n\t//\t\tDoes not work on Arrays created in other windows.\n\t//\tit: anything\n\t//\t\tItem to test.\n\t}\n\t=====*/\n\n\t/*=====\n\tdojo.isFunction = function(it){\n\t// summary:\n\t//\t\tReturn true if it is a Function\n\t//\tit: anything\n\t//\t\tItem to test.\n\t}\n\t=====*/\n\n\t/*=====\n\tdojo.isObject = function(it){\n\t// summary:\n\t//\t\tReturns true if it is a JavaScript object (or an Array, a Function\n\t//\t\tor null)\n\t//\tit: anything\n\t//\t\tItem to test.\n\t}\n\t=====*/\n\n\t/*=====\n\tdojo.isArrayLike = function(it){\n\t//\tsummary:\n\t//\t\tsimilar to dojo.isArray() but more permissive\n\t//\tit: anything\n\t//\t\tItem to test.\n\t//\treturns:\n\t//\t\tIf it walks like a duck and quacks like a duck, return `true`\n\t//\tdescription:\n\t//\t\tDoesn't strongly test for \"arrayness\".  Instead, settles for \"isn't\n\t//\t\ta string or number and has a length property\". Arguments objects\n\t//\t\tand DOM collections will return true when passed to\n\t//\t\tdojo.isArrayLike(), but will return false when passed to\n\t//\t\tdojo.isArray().\n\t}\n\t=====*/\n\n\t/*=====\n\tdojo.isAlien = function(it){\n\t// summary:\n\t//\t\tReturns true if it is a built-in function or some other kind of\n\t//\t\toddball that *should* report as a function but doesn't\n\t}\n\t=====*/\n\n\t/*=====\n\tdojo.extend = function(constructor, props){\n\t// summary:\n\t//\t\tAdds all properties and methods of props to constructor's\n\t//\t\tprototype, making them available to all instances created with\n\t//\t\tconstructor.\n\t//\tconstructor: Object\n\t//\t\tTarget constructor to extend.\n\t//\tprops: Object...\n\t//\t\tOne or more objects to mix into constructor.prototype\n\t}\n\t=====*/\n\n\t/*=====\n\tdojo.hitch = function(scope, method){\n\t//\tsummary:\n\t//\t\tReturns a function that will only ever execute in the a given scope.\n\t//\t\tThis allows for easy use of object member functions\n\t//\t\tin callbacks and other places in which the \"this\" keyword may\n\t//\t\totherwise not reference the expected scope.\n\t//\t\tAny number of default positional arguments may be passed as parameters\n\t//\t\tbeyond \"method\".\n\t//\t\tEach of these values will be used to \"placehold\" (similar to curry)\n\t//\t\tfor the hitched function.\n\t//\tscope: Object\n\t//\t\tThe scope to use when method executes. If method is a string,\n\t//\t\tscope is also the object containing method.\n\t//\tmethod: Function|String...\n\t//\t\tA function to be hitched to scope, or the name of the method in\n\t//\t\tscope to be hitched.\n\t//\texample:\n\t//\t|\tdojo.hitch(foo, \"bar\")();\n\t//\t\truns foo.bar() in the scope of foo\n\t//\texample:\n\t//\t|\tdojo.hitch(foo, myFunction);\n\t//\t\treturns a function that runs myFunction in the scope of foo\n\t//\texample:\n\t//\t\tExpansion on the default positional arguments passed along from\n\t//\t\thitch. Passed args are mixed first, additional args after.\n\t//\t|\tvar foo = { bar: function(a, b, c){ console.log(a, b, c); } };\n\t//\t|\tvar fn = dojo.hitch(foo, \"bar\", 1, 2);\n\t//\t|\tfn(3); // logs \"1, 2, 3\"\n\t//\texample:\n\t//\t|\tvar foo = { bar: 2 };\n\t//\t|\tdojo.hitch(foo, function(){ this.bar = 10; })();\n\t//\t\texecute an anonymous function in scope of foo\n\t}\n\t=====*/\n\n\t/*=====\n\tdojo.delegate = function(obj, props){\n\t\t//\tsummary:\n\t\t//\t\tReturns a new object which \"looks\" to obj for properties which it\n\t\t//\t\tdoes not have a value for. Optionally takes a bag of properties to\n\t\t//\t\tseed the returned object with initially.\n\t\t//\tdescription:\n\t\t//\t\tThis is a small implementaton of the Boodman/Crockford delegation\n\t\t//\t\tpattern in JavaScript. An intermediate object constructor mediates\n\t\t//\t\tthe prototype chain for the returned object, using it to delegate\n\t\t//\t\tdown to obj for property lookup when object-local lookup fails.\n\t\t//\t\tThis can be thought of similarly to ES4's \"wrap\", save that it does\n\t\t//\t\tnot act on types but rather on pure objects.\n\t\t//\tobj: Object\n\t\t//\t\tThe object to delegate to for properties not found directly on the\n\t\t//\t\treturn object or in props.\n\t\t//\tprops: Object...\n\t\t//\t\tan object containing properties to assign to the returned object\n\t\t//\treturns:\n\t\t//\t\tan Object of anonymous type\n\t\t//\texample:\n\t\t//\t|\tvar foo = { bar: \"baz\" };\n\t\t//\t|\tvar thinger = dojo.delegate(foo, { thud: \"xyzzy\"});\n\t\t//\t|\tthinger.bar == \"baz\"; // delegated to foo\n\t\t//\t|\tfoo.thud == undefined; // by definition\n\t\t//\t|\tthinger.thud == \"xyzzy\"; // mixed in from props\n\t\t//\t|\tfoo.bar = \"thonk\";\n\t\t//\t|\tthinger.bar == \"thonk\"; // still delegated to foo's bar\n\t}\n\t=====*/\n\n\t/*=====\n\tdojo.partial = function(method){\n\t//\tsummary:\n\t//\t\tsimilar to hitch() except that the scope object is left to be\n\t//\t\twhatever the execution context eventually becomes.\n\t//\tmethod: Function|String\n\t//\tdescription:\n\t//\t\tCalling dojo.partial is the functional equivalent of calling:\n\t//\t\t|\tdojo.hitch(null, funcName, ...);\n\t}\n\t=====*/\n\n\t/*=====\n\tdojo.trim = function(str){\n\t\t//\tsummary:\n\t\t//\t\tTrims whitespace from both sides of the string\n\t\t//\tstr: String\n\t\t//\t\tString to be trimmed\n\t\t//\treturns: String\n\t\t//\t\tReturns the trimmed string\n\t\t//\tdescription:\n\t\t//\t\tThis version of trim() was selected for inclusion into the base due\n\t\t//\t\tto its compact size and relatively good performance\n\t\t//\t\t(see [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript)\n\t\t//\t\tUses String.prototype.trim instead, if available.\n\t\t//\t\tThe fastest but longest version of this function is located at\n\t\t//\t\tdojo.string.trim()\n\t}\n\t=====*/\n\n\t/*=====\n\tdojo.clone = function(src){\n\t// summary:\n\t//\t\tClones objects (including DOM nodes) and all children.\n\t//\t\tWarning: do not clone cyclic structures.\n\t//\tsrc:\n\t//\t\tThe object to clone\n\t}\n\t=====*/\n\n\t/*=====\n\tdojo._toArray = function(obj, offset, startWith){\n\t\t//\tsummary:\n\t\t//\t\tConverts an array-like object (i.e. arguments, DOMCollection) to an\n\t\t//\t\tarray. Returns a new Array with the elements of obj.\n\t\t//\tobj: Object\n\t\t//\t\tthe object to \"arrayify\". We expect the object to have, at a\n\t\t//\t\tminimum, a length property which corresponds to integer-indexed\n\t\t//\t\tproperties.\n\t\t//\toffset: Number?\n\t\t//\t\tthe location in obj to start iterating from. Defaults to 0.\n\t\t//\t\tOptional.\n\t\t//\tstartWith: Array?\n\t\t//\t\tAn array to pack with the properties of obj. If provided,\n\t\t//\t\tproperties in obj are appended at the end of startWith and\n\t\t//\t\tstartWith is the returned array.\n\t}\n\t=====*/\n\n\t/*=====\n\tdojo.replace = function(tmpl, map, pattern){\n\t\t//\tsummary:\n\t\t//\t\tPerforms parameterized substitutions on a string. Throws an\n\t\t//\t\texception if any parameter is unmatched.\n\t\t//\ttmpl: String\n\t\t//\t\tString to be used as a template.\n\t\t//\tmap: Object|Function\n\t\t//\t\tIf an object, it is used as a dictionary to look up substitutions.\n\t\t//\t\tIf a function, it is called for every substitution with following\n\t\t//\t\tparameters: a whole match, a name, an offset, and the whole template\n\t\t//\t\tstring (see https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replace\n\t\t//\t\tfor more details).\n\t\t//\tpattern: RegEx?\n\t\t//\t\tOptional regular expression objects that overrides the default pattern.\n\t\t//\t\tMust be global and match one item. The default is: /\\{([^\\}]+)\\}/g,\n\t\t//\t\twhich matches patterns like that: \"{xxx}\", where \"xxx\" is any sequence\n\t\t//\t\tof characters, which doesn't include \"}\".\n\t\t//\treturns: String\n\t\t//\t\tReturns the substituted string.\n\t\t//\texample:\n\t\t//\t|\t// uses a dictionary for substitutions:\n\t\t//\t|\tdojo.replace(\"Hello, {name.first} {name.last} AKA {nick}!\",\n\t\t//\t|\t\t{\n\t\t//\t|\t\t\tnick: \"Bob\",\n\t\t//\t|\t\t\tname: {\n\t\t//\t|\t\t\t\tfirst:\t\"Robert\",\n\t\t//\t|\t\t\t\tmiddle: \"X\",\n\t\t//\t|\t\t\t\tlast:\t\t\"Cringely\"\n\t\t//\t|\t\t\t}\n\t\t//\t|\t\t});\n\t\t//\t|\t// returns: Hello, Robert Cringely AKA Bob!\n\t\t//\texample:\n\t\t//\t|\t// uses an array for substitutions:\n\t\t//\t|\tdojo.replace(\"Hello, {0} {2}!\",\n\t\t//\t|\t\t[\"Robert\", \"X\", \"Cringely\"]);\n\t\t//\t|\t// returns: Hello, Robert Cringely!\n\t\t//\texample:\n\t\t//\t|\t// uses a function for substitutions:\n\t\t//\t|\tfunction sum(a){\n\t\t//\t|\t\tvar t = 0;\n\t\t//\t|\t\tdojo.forEach(a, function(x){ t += x; });\n\t\t//\t|\t\treturn t;\n\t\t//\t|\t}\n\t\t//\t|\tdojo.replace(\n\t\t//\t|\t\t\"{count} payments averaging {avg} USD per payment.\",\n\t\t//\t|\t\tdojo.hitch(\n\t\t//\t|\t\t\t{ payments: [11, 16, 12] },\n\t\t//\t|\t\t\tfunction(_, key){\n\t\t//\t|\t\t\t\tswitch(key){\n\t\t//\t|\t\t\t\t\tcase \"count\": return this.payments.length;\n\t\t//\t|\t\t\t\t\tcase \"min\":\t\treturn Math.min.apply(Math, this.payments);\n\t\t//\t|\t\t\t\t\tcase \"max\":\t\treturn Math.max.apply(Math, this.payments);\n\t\t//\t|\t\t\t\t\tcase \"sum\":\t\treturn sum(this.payments);\n\t\t//\t|\t\t\t\t\tcase \"avg\":\t\treturn sum(this.payments) / this.payments.length;\n\t\t//\t|\t\t\t\t}\n\t\t//\t|\t\t\t}\n\t\t//\t|\t\t)\n\t\t//\t|\t);\n\t\t//\t|\t// prints: 3 payments averaging 13 USD per payment.\n\t\t//\texample:\n\t\t//\t|\t// uses an alternative PHP-like pattern for substitutions:\n\t\t//\t|\tdojo.replace(\"Hello, ${0} ${2}!\",\n\t\t//\t|\t\t[\"Robert\", \"X\", \"Cringely\"], /\\$\\{([^\\}]+)\\}/g);\n\t\t//\t|\t// returns: Hello, Robert Cringely!\n\t\treturn \"\";\t// String\n\t}\n\t=====*/\n});\n\n\n},\n'dojo/Evented':function(){\ndefine([\"./aspect\", \"./on\"], function(aspect, on){\n\t// summary:\n\t//\t\tThe export of this module is a class that can be used as a mixin or base class, \n\t// \t\tto add on() and emit() methods to a class\n\t// \t\tfor listening for events and emiting events:\n\t// \t\t|define([\"dojo/Evented\"], function(Evented){\n\t// \t\t|\tvar EventedWidget = dojo.declare([Evented, dijit._Widget], {...});\n\t//\t\t|\twidget = new EventedWidget();\n\t//\t\t|\twidget.on(\"open\", function(event){\n\t//\t\t|\t... do something with event\n\t//\t\t|\t });\n\t//\t\t|\n\t//\t\t|\twidget.emit(\"open\", {name:\"some event\", ...});\n\n \t\"use strict\";\n \tvar after = aspect.after;\n\tfunction Evented(){\n\t}\n\tEvented.prototype = {\n\t\ton: function(type, listener){\n\t\t\treturn on.parse(this, type, listener, function(target, type){\n\t\t\t\treturn after(target, 'on' + type, listener, true);\n\t\t\t});\n\t\t},\n\t\temit: function(type, event){\n\t\t\tvar args = [this];\n\t\t\targs.push.apply(args, arguments);\n\t\t\treturn on.emit.apply(on, args);\n\t\t}\n\t};\n\treturn Evented;\n});\n\n},\n'dojo/mouse':function(){\ndefine([\"./_base/kernel\", \"./on\", \"./has\", \"./dom\", \"./_base/window\"], function(dojo, on, has, dom, win){\n\n\t/*=====\n\tdojo.mouse = {\n\t// summary:\n\t//\t\tThis module provide mouse event handling utility functions and exports\n\t//\t\tmouseenter and mouseleave event emulation.\n\t// enter: Synthetic Event\n\t//\t\tThis is an extension event for the mouseenter that IE provides, emulating the\n\t//\t\tbehavior on other browsers.\n\t// leave: Synthetic Event\n\t//\t\tThis is an extension event for the mouseleave that IE provides, emulating the\n\t//\t\tbehavior on other browsers.\n\t// isLeft: Function\n\t//\t\tTest an event object (from a mousedown event) to see if the left button was pressed.\n\t// isMiddle: Function\n\t//\t\tTest an event object (from a mousedown event) to see if the middle button was pressed.\n\t// isRight: Function\n\t//\t\tTest an event object (from a mousedown event) to see if the right button was pressed.\n\t// example:\n\t//\t\tTo use these events, you register a mouseenter like this:\n\t//\t\t|\tdefine([\"dojo/on\", dojo/mouse\"], function(on, mouse){\n\t//\t\t|\t\ton(targetNode, mouse.enter, function(event){\n\t//\t\t|\t\t\tdojo.addClass(targetNode, \"highlighted\");\n\t//\t\t|\t\t});\n\t//\t\t|\t\ton(targetNode, mouse.leave, function(event){\n\t//\t\t|\t\t\tdojo.removeClass(targetNode, \"highlighted\");\n\t//\t\t|\t\t});\n\t};\n\t======*/\n\n    has.add(\"dom-quirks\", win.doc && win.doc.compatMode == \"BackCompat\");\n \thas.add(\"events-mouseenter\", win.doc && \"onmouseenter\" in win.doc.createElement(\"div\"));\n\n\tvar mouseButtons;\n\tif(has(\"dom-quirks\") || !has(\"dom-addeventlistener\")){\n\t\tmouseButtons = {\n\t\t\tLEFT:   1,\n\t\t\tMIDDLE: 4,\n\t\t\tRIGHT:  2,\n\t\t\t// helper functions\n\t\t\tisButton: function(e, button){ return e.button & button; },\n\t\t\tisLeft:   function(e){ return e.button & 1; },\n\t\t\tisMiddle: function(e){ return e.button & 4; },\n\t\t\tisRight:  function(e){ return e.button & 2; }\n\t\t};\n\t}else{\n\t\tmouseButtons = {\n\t\t\tLEFT:   0,\n\t\t\tMIDDLE: 1,\n\t\t\tRIGHT:  2,\n\t\t\t// helper functions\n\t\t\tisButton: function(e, button){ return e.button == button; },\n\t\t\tisLeft:   function(e){ return e.button == 0; },\n\t\t\tisMiddle: function(e){ return e.button == 1; },\n\t\t\tisRight:  function(e){ return e.button == 2; }\n\t\t};\n\t}\n\tdojo.mouseButtons = mouseButtons;\n\n/*=====\n\tdojo.mouseButtons = {\n\t\t// LEFT: Number\n\t\t//\t\tNumeric value of the left mouse button for the platform.\n\t\tLEFT:   0,\n\t\t// MIDDLE: Number\n\t\t//\t\tNumeric value of the middle mouse button for the platform.\n\t\tMIDDLE: 1,\n\t\t// RIGHT: Number\n\t\t//\t\tNumeric value of the right mouse button for the platform.\n\t\tRIGHT:  2,\n\n\t\tisButton: function(e, button){\n\t\t\t// summary:\n\t\t\t//\t\tChecks an event object for a pressed button\n\t\t\t// e: Event\n\t\t\t//\t\tEvent object to examine\n\t\t\t// button: Number\n\t\t\t//\t\tThe button value (example: dojo.mouseButton.LEFT)\n\t\t\treturn e.button == button; // Boolean\n\t\t},\n\t\tisLeft: function(e){\n\t\t\t// summary:\n\t\t\t//\t\tChecks an event object for the pressed left button\n\t\t\t// e: Event\n\t\t\t//\t\tEvent object to examine\n\t\t\treturn e.button == 0; // Boolean\n\t\t},\n\t\tisMiddle: function(e){\n\t\t\t// summary:\n\t\t\t//\t\tChecks an event object for the pressed middle button\n\t\t\t// e: Event\n\t\t\t//\t\tEvent object to examine\n\t\t\treturn e.button == 1; // Boolean\n\t\t},\n\t\tisRight: function(e){\n\t\t\t// summary:\n\t\t\t//\t\tChecks an event object for the pressed right button\n\t\t\t// e: Event\n\t\t\t//\t\tEvent object to examine\n\t\t\treturn e.button == 2; // Boolean\n\t\t}\n\t};\n=====*/\n\n\tfunction eventHandler(type, mustBubble){\n\t\t// emulation of mouseenter/leave with mouseover/out using descendant checking\n\t\tvar handler = function(node, listener){\n\t\t\treturn on(node, type, function(evt){\n\t\t\t\tif(!dom.isDescendant(evt.relatedTarget, mustBubble ? evt.target : node)){\n\t\t\t\t\treturn listener.call(this, evt);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\tif(!mustBubble){\n\t\t\thandler.bubble = eventHandler(type, true);\n\t\t}\n\t\treturn handler;\n\t}\n\treturn {\n\t\tenter: eventHandler(\"mouseover\"),\n\t\tleave: eventHandler(\"mouseout\"),\n\t\tisLeft: mouseButtons.isLeft,\n\t\tisMiddle: mouseButtons.isMiddle,\n\t\tisRight: mouseButtons.isRight\n\t};\n});\n\n},\n'dojo/topic':function(){\ndefine([\"./Evented\"], function(Evented){\n\t// summary:\n\t//\t\tThe export of this module is a pubsub hub\n\t//\t\tYou can also use listen function itself as a pub/sub hub:\n\t//\t\t| \ttopic.subscribe(\"some/topic\", function(event){\n\t//\t\t|\t... do something with event\n\t//\t\t|\t});\n\t//\t\t|\ttopic.publish(\"some/topic\", {name:\"some event\", ...});\n\n\tvar hub = new Evented;\n\treturn {\n\t\tpublish: function(topic, event){\n\t\t\t// summary:\n\t\t\t//\t\tPublishes a message to a topic on the pub/sub hub. All arguments after\n\t\t\t// \t\tthe first will be passed to the subscribers, so any number of arguments\n\t\t\t// \t\tcan be provided (not just event).\n\t\t\t// topic: String\n\t\t\t//\t\tThe name of the topic to publish to\n\t\t\t// event: Object\n\t\t\t//\t\tAn event to distribute to the topic listeners\n\t\t\treturn hub.emit.apply(hub, arguments);\n\t\t},\n\t\tsubscribe: function(topic, listener){\n\t\t\t// summary:\n\t\t\t//\t\tSubcribes to a topic on the pub/sub hub\n\t\t\t// topic: String\n\t\t\t//\t\tThe topic to subscribe to\n\t\t\t//\tlistener: Function\n\t\t\t//\t\tA function to call when a message is published to the given topic\n\t\t\treturn hub.on.apply(hub, arguments);\n\t\t}\n\t}\n});\n\n},\n'dojo/_base/xhr':function(){\ndefine([\n\t\"./kernel\", \"./sniff\", \"require\", \"../io-query\", \"../dom\", \"../dom-form\", \"./Deferred\", \"./json\", \"./lang\", \"./array\", \"../on\"\n], function(dojo, has, require, ioq, dom, domForm, deferred, json, lang, array, on){\n\t//\tmodule:\n\t//\t\tdojo/_base.xhr\n\t// summary:\n\t//\t\tThis modules defines the dojo.xhr* API.\n\n\thas.add(\"native-xhr\", function() {\n\t\t// if true, the environment has a native XHR implementation\n\t\treturn typeof XMLHttpRequest !== 'undefined';\n\t});\n\n\tif(1){\n\t\tdojo._xhrObj = require.getXhr;\n\t}else if (has(\"native-xhr\")){\n\t\tdojo._xhrObj = function(){\n\t\t\t// summary:\n\t\t\t//\t\tdoes the work of portably generating a new XMLHTTPRequest object.\n\t\t\ttry{\n\t\t\t\treturn new XMLHttpRequest();\n\t\t\t}catch(e){\n\t\t\t\tthrow new Error(\"XMLHTTP not available: \"+e);\n\t\t\t}\n\t\t};\n\t}else{\n\t\t// PROGIDs are in order of decreasing likelihood; this will change in time.\n\t\tfor(var XMLHTTP_PROGIDS = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'], progid, i = 0; i < 3;){\n\t\t\ttry{\n\t\t\t\tprogid = XMLHTTP_PROGIDS[i++];\n\t\t\t\tif (new ActiveXObject(progid)) {\n\t\t\t\t\t// this progid works; therefore, use it from now on\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}catch(e){\n\t\t\t\t// squelch; we're just trying to find a good ActiveX PROGID\n\t\t\t\t// if they all fail, then progid ends up as the last attempt and that will signal the error\n\t\t\t\t// the first time the client actually tries to exec an xhr\n\t\t\t}\n\t\t}\n\t\tdojo._xhrObj= function() {\n\t\t\treturn new ActiveXObject(progid);\n\t\t};\n\t}\n\n\tvar cfg = dojo.config;\n\n\t// mix in io-query and dom-form\n\tdojo.objectToQuery = ioq.objectToQuery;\n\tdojo.queryToObject = ioq.queryToObject;\n\tdojo.fieldToObject = domForm.fieldToObject;\n\tdojo.formToObject = domForm.toObject;\n\tdojo.formToQuery = domForm.toQuery;\n\tdojo.formToJson = domForm.toJson;\n\n\t// need to block async callbacks from snatching this thread as the result\n\t// of an async callback might call another sync XHR, this hangs khtml forever\n\t// must checked by watchInFlight()\n\n\tdojo._blockAsync = false;\n\n\t// MOW: remove dojo._contentHandlers alias in 2.0\n\tvar handlers = dojo._contentHandlers = dojo.contentHandlers = {\n\t\t// summary:\n\t\t//\t\tA map of availble XHR transport handle types. Name matches the\n\t\t//\t\t`handleAs` attribute passed to XHR calls.\n\t\t//\n\t\t// description:\n\t\t//\t\tA map of availble XHR transport handle types. Name matches the\n\t\t//\t\t`handleAs` attribute passed to XHR calls. Each contentHandler is\n\t\t//\t\tcalled, passing the xhr object for manipulation. The return value\n\t\t//\t\tfrom the contentHandler will be passed to the `load` or `handle`\n\t\t//\t\tfunctions defined in the original xhr call.\n\t\t//\n\t\t// example:\n\t\t//\t\tCreating a custom content-handler:\n\t\t//\t|\tdojo.contentHandlers.makeCaps = function(xhr){\n\t\t//\t|\t\treturn xhr.responseText.toUpperCase();\n\t\t//\t|\t}\n\t\t//\t|\t// and later:\n\t\t//\t|\tdojo.xhrGet({\n\t\t//\t|\t\turl:\"foo.txt\",\n\t\t//\t|\t\thandleAs:\"makeCaps\",\n\t\t//\t|\t\tload: function(data){ /* data is a toUpper version of foo.txt */ }\n\t\t//\t|\t});\n\n\t\t\"text\": function(xhr){\n\t\t\t// summary: A contentHandler which simply returns the plaintext response data\n\t\t\treturn xhr.responseText;\n\t\t},\n\t\t\"json\": function(xhr){\n\t\t\t// summary: A contentHandler which returns a JavaScript object created from the response data\n\t\t\treturn json.fromJson(xhr.responseText || null);\n\t\t},\n\t\t\"json-comment-filtered\": function(xhr){\n\t\t\t// summary: A contentHandler which expects comment-filtered JSON.\n\t\t\t// description:\n\t\t\t//\t\tA contentHandler which expects comment-filtered JSON.\n\t\t\t//\t\tthe json-comment-filtered option was implemented to prevent\n\t\t\t//\t\t\"JavaScript Hijacking\", but it is less secure than standard JSON. Use\n\t\t\t//\t\tstandard JSON instead. JSON prefixing can be used to subvert hijacking.\n\t\t\t//\n\t\t\t//\t\tWill throw a notice suggesting to use application/json mimetype, as\n\t\t\t//\t\tjson-commenting can introduce security issues. To decrease the chances of hijacking,\n\t\t\t//\t\tuse the standard `json` contentHandler, and prefix your \"JSON\" with: {}&&\n\t\t\t//\n\t\t\t//\t\tuse djConfig.useCommentedJson = true to turn off the notice\n\t\t\tif(!dojo.config.useCommentedJson){\n\t\t\t\tconsole.warn(\"Consider using the standard mimetype:application/json.\"\n\t\t\t\t\t+ \" json-commenting can introduce security issues. To\"\n\t\t\t\t\t+ \" decrease the chances of hijacking, use the standard the 'json' handler and\"\n\t\t\t\t\t+ \" prefix your json with: {}&&\\n\"\n\t\t\t\t\t+ \"Use djConfig.useCommentedJson=true to turn off this message.\");\n\t\t\t}\n\n\t\t\tvar value = xhr.responseText;\n\t\t\tvar cStartIdx = value.indexOf(\"\\/*\");\n\t\t\tvar cEndIdx = value.lastIndexOf(\"*\\/\");\n\t\t\tif(cStartIdx == -1 || cEndIdx == -1){\n\t\t\t\tthrow new Error(\"JSON was not comment filtered\");\n\t\t\t}\n\t\t\treturn json.fromJson(value.substring(cStartIdx+2, cEndIdx));\n\t\t},\n\t\t\"javascript\": function(xhr){\n\t\t\t// summary: A contentHandler which evaluates the response data, expecting it to be valid JavaScript\n\n\t\t\t// FIXME: try Moz and IE specific eval variants?\n\t\t\treturn dojo.eval(xhr.responseText);\n\t\t},\n\t\t\"xml\": function(xhr){\n\t\t\t// summary: A contentHandler returning an XML Document parsed from the response data\n\t\t\tvar result = xhr.responseXML;\n\n\t\t\tif(has(\"ie\")){\n\t\t\t\tif((!result || !result.documentElement)){\n\t\t\t\t\t//WARNING: this branch used by the xml handling in dojo.io.iframe,\n\t\t\t\t\t//so be sure to test dojo.io.iframe if making changes below.\n\t\t\t\t\tvar ms = function(n){ return \"MSXML\" + n + \".DOMDocument\"; };\n\t\t\t\t\tvar dp = [\"Microsoft.XMLDOM\", ms(6), ms(4), ms(3), ms(2)];\n\t\t\t\t\tarray.some(dp, function(p){\n\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\tvar dom = new ActiveXObject(p);\n\t\t\t\t\t\t\tdom.async = false;\n\t\t\t\t\t\t\tdom.loadXML(xhr.responseText);\n\t\t\t\t\t\t\tresult = dom;\n\t\t\t\t\t\t}catch(e){ return false; }\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t }\n\t\t\treturn result; // DOMDocument\n\t\t},\n\t\t\"json-comment-optional\": function(xhr){\n\t\t\t// summary: A contentHandler which checks the presence of comment-filtered JSON and\n\t\t\t//\t\talternates between the `json` and `json-comment-filtered` contentHandlers.\n\t\t\tif(xhr.responseText && /^[^{\\[]*\\/\\*/.test(xhr.responseText)){\n\t\t\t\treturn handlers[\"json-comment-filtered\"](xhr);\n\t\t\t}else{\n\t\t\t\treturn handlers[\"json\"](xhr);\n\t\t\t}\n\t\t}\n\t};\n\n\t/*=====\n\tdojo.__IoArgs = function(){\n\t\t//\turl: String\n\t\t//\t\tURL to server endpoint.\n\t\t//\tcontent: Object?\n\t\t//\t\tContains properties with string values. These\n\t\t//\t\tproperties will be serialized as name1=value2 and\n\t\t//\t\tpassed in the request.\n\t\t//\ttimeout: Integer?\n\t\t//\t\tMilliseconds to wait for the response. If this time\n\t\t//\t\tpasses, the then error callbacks are called.\n\t\t//\tform: DOMNode?\n\t\t//\t\tDOM node for a form. Used to extract the form values\n\t\t//\t\tand send to the server.\n\t\t//\tpreventCache: Boolean?\n\t\t//\t\tDefault is false. If true, then a\n\t\t//\t\t\"dojo.preventCache\" parameter is sent in the request\n\t\t//\t\twith a value that changes with each request\n\t\t//\t\t(timestamp). Useful only with GET-type requests.\n\t\t//\thandleAs: String?\n\t\t//\t\tAcceptable values depend on the type of IO\n\t\t//\t\ttransport (see specific IO calls for more information).\n\t\t//\trawBody: String?\n\t\t//\t\tSets the raw body for an HTTP request. If this is used, then the content\n\t\t//\t\tproperty is ignored. This is mostly useful for HTTP methods that have\n\t\t//\t\ta body to their requests, like PUT or POST. This property can be used instead\n\t\t//\t\tof postData and putData for dojo.rawXhrPost and dojo.rawXhrPut respectively.\n\t\t//\tioPublish: Boolean?\n\t\t//\t\tSet this explicitly to false to prevent publishing of topics related to\n\t\t//\t\tIO operations. Otherwise, if djConfig.ioPublish is set to true, topics\n\t\t//\t\twill be published via dojo.publish for different phases of an IO operation.\n\t\t//\t\tSee dojo.__IoPublish for a list of topics that are published.\n\t\t//\tload: Function?\n\t\t//\t\tThis function will be\n\t\t//\t\tcalled on a successful HTTP response code.\n\t\t//\terror: Function?\n\t\t//\t\tThis function will\n\t\t//\t\tbe called when the request fails due to a network or server error, the url\n\t\t//\t\tis invalid, etc. It will also be called if the load or handle callback throws an\n\t\t//\t\texception, unless djConfig.debugAtAllCosts is true.\t This allows deployed applications\n\t\t//\t\tto continue to run even when a logic error happens in the callback, while making\n\t\t//\t\tit easier to troubleshoot while in debug mode.\n\t\t//\thandle: Function?\n\t\t//\t\tThis function will\n\t\t//\t\tbe called at the end of every request, whether or not an error occurs.\n\t\tthis.url = url;\n\t\tthis.content = content;\n\t\tthis.timeout = timeout;\n\t\tthis.form = form;\n\t\tthis.preventCache = preventCache;\n\t\tthis.handleAs = handleAs;\n\t\tthis.ioPublish = ioPublish;\n\t\tthis.load = function(response, ioArgs){\n\t\t\t// ioArgs: dojo.__IoCallbackArgs\n\t\t\t//\t\tProvides additional information about the request.\n\t\t\t// response: Object\n\t\t\t//\t\tThe response in the format as defined with handleAs.\n\t\t}\n\t\tthis.error = function(response, ioArgs){\n\t\t\t// ioArgs: dojo.__IoCallbackArgs\n\t\t\t//\t\tProvides additional information about the request.\n\t\t\t// response: Object\n\t\t\t//\t\tThe response in the format as defined with handleAs.\n\t\t}\n\t\tthis.handle = function(loadOrError, response, ioArgs){\n\t\t\t// loadOrError: String\n\t\t\t//\t\tProvides a string that tells you whether this function\n\t\t\t//\t\twas called because of success (load) or failure (error).\n\t\t\t// response: Object\n\t\t\t//\t\tThe response in the format as defined with handleAs.\n\t\t\t// ioArgs: dojo.__IoCallbackArgs\n\t\t\t//\t\tProvides additional information about the request.\n\t\t}\n\t}\n\t=====*/\n\n\t/*=====\n\tdojo.__IoCallbackArgs = function(args, xhr, url, query, handleAs, id, canDelete, json){\n\t\t//\targs: Object\n\t\t//\t\tthe original object argument to the IO call.\n\t\t//\txhr: XMLHttpRequest\n\t\t//\t\tFor XMLHttpRequest calls only, the\n\t\t//\t\tXMLHttpRequest object that was used for the\n\t\t//\t\trequest.\n\t\t//\turl: String\n\t\t//\t\tThe final URL used for the call. Many times it\n\t\t//\t\twill be different than the original args.url\n\t\t//\t\tvalue.\n\t\t//\tquery: String\n\t\t//\t\tFor non-GET requests, the\n\t\t//\t\tname1=value1&name2=value2 parameters sent up in\n\t\t//\t\tthe request.\n\t\t//\thandleAs: String\n\t\t//\t\tThe final indicator on how the response will be\n\t\t//\t\thandled.\n\t\t//\tid: String\n\t\t//\t\tFor dojo.io.script calls only, the internal\n\t\t//\t\tscript ID used for the request.\n\t\t//\tcanDelete: Boolean\n\t\t//\t\tFor dojo.io.script calls only, indicates\n\t\t//\t\twhether the script tag that represents the\n\t\t//\t\trequest can be deleted after callbacks have\n\t\t//\t\tbeen called. Used internally to know when\n\t\t//\t\tcleanup can happen on JSONP-type requests.\n\t\t//\tjson: Object\n\t\t//\t\tFor dojo.io.script calls only: holds the JSON\n\t\t//\t\tresponse for JSONP-type requests. Used\n\t\t//\t\tinternally to hold on to the JSON responses.\n\t\t//\t\tYou should not need to access it directly --\n\t\t//\t\tthe same object should be passed to the success\n\t\t//\t\tcallbacks directly.\n\t\tthis.args = args;\n\t\tthis.xhr = xhr;\n\t\tthis.url = url;\n\t\tthis.query = query;\n\t\tthis.handleAs = handleAs;\n\t\tthis.id = id;\n\t\tthis.canDelete = canDelete;\n\t\tthis.json = json;\n\t}\n\t=====*/\n\n\n\t/*=====\n\tdojo.__IoPublish = function(){\n\t\t//\tsummary:\n\t\t//\t\tThis is a list of IO topics that can be published\n\t\t//\t\tif djConfig.ioPublish is set to true. IO topics can be\n\t\t//\t\tpublished for any Input/Output, network operation. So,\n\t\t//\t\tdojo.xhr, dojo.io.script and dojo.io.iframe can all\n\t\t//\t\ttrigger these topics to be published.\n\t\t//\tstart: String\n\t\t//\t\t\"/dojo/io/start\" is sent when there are no outstanding IO\n\t\t//\t\trequests, and a new IO request is started. No arguments\n\t\t//\t\tare passed with this topic.\n\t\t//\tsend: String\n\t\t//\t\t\"/dojo/io/send\" is sent whenever a new IO request is started.\n\t\t//\t\tIt passes the dojo.Deferred for the request with the topic.\n\t\t//\tload: String\n\t\t//\t\t\"/dojo/io/load\" is sent whenever an IO request has loaded\n\t\t//\t\tsuccessfully. It passes the response and the dojo.Deferred\n\t\t//\t\tfor the request with the topic.\n\t\t//\terror: String\n\t\t//\t\t\"/dojo/io/error\" is sent whenever an IO request has errored.\n\t\t//\t\tIt passes the error and the dojo.Deferred\n\t\t//\t\tfor the request with the topic.\n\t\t//\tdone: String\n\t\t//\t\t\"/dojo/io/done\" is sent whenever an IO request has completed,\n\t\t//\t\teither by loading or by erroring. It passes the error and\n\t\t//\t\tthe dojo.Deferred for the request with the topic.\n\t\t//\tstop: String\n\t\t//\t\t\"/dojo/io/stop\" is sent when all outstanding IO requests have\n\t\t//\t\tfinished. No arguments are passed with this topic.\n\t\tthis.start = \"/dojo/io/start\";\n\t\tthis.send = \"/dojo/io/send\";\n\t\tthis.load = \"/dojo/io/load\";\n\t\tthis.error = \"/dojo/io/error\";\n\t\tthis.done = \"/dojo/io/done\";\n\t\tthis.stop = \"/dojo/io/stop\";\n\t}\n\t=====*/\n\n\n\tdojo._ioSetArgs = function(/*dojo.__IoArgs*/args,\n\t\t\t/*Function*/canceller,\n\t\t\t/*Function*/okHandler,\n\t\t\t/*Function*/errHandler){\n\t\t//\tsummary:\n\t\t//\t\tsets up the Deferred and ioArgs property on the Deferred so it\n\t\t//\t\tcan be used in an io call.\n\t\t//\targs:\n\t\t//\t\tThe args object passed into the public io call. Recognized properties on\n\t\t//\t\tthe args object are:\n\t\t//\tcanceller:\n\t\t//\t\tThe canceller function used for the Deferred object. The function\n\t\t//\t\twill receive one argument, the Deferred object that is related to the\n\t\t//\t\tcanceller.\n\t\t//\tokHandler:\n\t\t//\t\tThe first OK callback to be registered with Deferred. It has the opportunity\n\t\t//\t\tto transform the OK response. It will receive one argument -- the Deferred\n\t\t//\t\tobject returned from this function.\n\t\t//\terrHandler:\n\t\t//\t\tThe first error callback to be registered with Deferred. It has the opportunity\n\t\t//\t\tto do cleanup on an error. It will receive two arguments: error (the\n\t\t//\t\tError object) and dfd, the Deferred object returned from this function.\n\n\t\tvar ioArgs = {args: args, url: args.url};\n\n\t\t//Get values from form if requestd.\n\t\tvar formObject = null;\n\t\tif(args.form){\n\t\t\tvar form = dom.byId(args.form);\n\t\t\t//IE requires going through getAttributeNode instead of just getAttribute in some form cases,\n\t\t\t//so use it for all. See #2844\n\t\t\tvar actnNode = form.getAttributeNode(\"action\");\n\t\t\tioArgs.url = ioArgs.url || (actnNode ? actnNode.value : null);\n\t\t\tformObject = domForm.toObject(form);\n\t\t}\n\n\t\t// set up the query params\n\t\tvar miArgs = [{}];\n\n\t\tif(formObject){\n\t\t\t// potentially over-ride url-provided params w/ form values\n\t\t\tmiArgs.push(formObject);\n\t\t}\n\t\tif(args.content){\n\t\t\t// stuff in content over-rides what's set by form\n\t\t\tmiArgs.push(args.content);\n\t\t}\n\t\tif(args.preventCache){\n\t\t\tmiArgs.push({\"dojo.preventCache\": new Date().valueOf()});\n\t\t}\n\t\tioArgs.query = ioq.objectToQuery(lang.mixin.apply(null, miArgs));\n\n\t\t// .. and the real work of getting the deferred in order, etc.\n\t\tioArgs.handleAs = args.handleAs || \"text\";\n\t\tvar d = new deferred(canceller);\n\t\td.addCallbacks(okHandler, function(error){\n\t\t\treturn errHandler(error, d);\n\t\t});\n\n\t\t//Support specifying load, error and handle callback functions from the args.\n\t\t//For those callbacks, the \"this\" object will be the args object.\n\t\t//The callbacks will get the deferred result value as the\n\t\t//first argument and the ioArgs object as the second argument.\n\t\tvar ld = args.load;\n\t\tif(ld && lang.isFunction(ld)){\n\t\t\td.addCallback(function(value){\n\t\t\t\treturn ld.call(args, value, ioArgs);\n\t\t\t});\n\t\t}\n\t\tvar err = args.error;\n\t\tif(err && lang.isFunction(err)){\n\t\t\td.addErrback(function(value){\n\t\t\t\treturn err.call(args, value, ioArgs);\n\t\t\t});\n\t\t}\n\t\tvar handle = args.handle;\n\t\tif(handle && lang.isFunction(handle)){\n\t\t\td.addBoth(function(value){\n\t\t\t\treturn handle.call(args, value, ioArgs);\n\t\t\t});\n\t\t}\n\n\t\t//Plug in topic publishing, if dojo.publish is loaded.\n\t\tif(cfg.ioPublish && dojo.publish && ioArgs.args.ioPublish !== false){\n\t\t\td.addCallbacks(\n\t\t\t\tfunction(res){\n\t\t\t\t\tdojo.publish(\"/dojo/io/load\", [d, res]);\n\t\t\t\t\treturn res;\n\t\t\t\t},\n\t\t\t\tfunction(res){\n\t\t\t\t\tdojo.publish(\"/dojo/io/error\", [d, res]);\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t);\n\t\t\td.addBoth(function(res){\n\t\t\t\tdojo.publish(\"/dojo/io/done\", [d, res]);\n\t\t\t\treturn res;\n\t\t\t});\n\t\t}\n\n\t\td.ioArgs = ioArgs;\n\n\t\t// FIXME: need to wire up the xhr object's abort method to something\n\t\t// analagous in the Deferred\n\t\treturn d;\n\t};\n\n\tvar _deferredCancel = function(/*Deferred*/dfd){\n\t\t// summary: canceller function for dojo._ioSetArgs call.\n\n\t\tdfd.canceled = true;\n\t\tvar xhr = dfd.ioArgs.xhr;\n\t\tvar _at = typeof xhr.abort;\n\t\tif(_at == \"function\" || _at == \"object\" || _at == \"unknown\"){\n\t\t\txhr.abort();\n\t\t}\n\t\tvar err = dfd.ioArgs.error;\n\t\tif(!err){\n\t\t\terr = new Error(\"xhr cancelled\");\n\t\t\terr.dojoType=\"cancel\";\n\t\t}\n\t\treturn err;\n\t};\n\tvar _deferredOk = function(/*Deferred*/dfd){\n\t\t// summary: okHandler function for dojo._ioSetArgs call.\n\n\t\tvar ret = handlers[dfd.ioArgs.handleAs](dfd.ioArgs.xhr);\n\t\treturn ret === undefined ? null : ret;\n\t};\n\tvar _deferError = function(/*Error*/error, /*Deferred*/dfd){\n\t\t// summary: errHandler function for dojo._ioSetArgs call.\n\n\t\tif(!dfd.ioArgs.args.failOk){\n\t\t\tconsole.error(error);\n\t\t}\n\t\treturn error;\n\t};\n\n\t// avoid setting a timer per request. It degrades performance on IE\n\t// something fierece if we don't use unified loops.\n\tvar _inFlightIntvl = null;\n\tvar _inFlight = [];\n\n\n\t//Use a separate count for knowing if we are starting/stopping io calls.\n\t//Cannot use _inFlight.length since it can change at a different time than\n\t//when we want to do this kind of test. We only want to decrement the count\n\t//after a callback/errback has finished, since the callback/errback should be\n\t//considered as part of finishing a request.\n\tvar _pubCount = 0;\n\tvar _checkPubCount = function(dfd){\n\t\tif(_pubCount <= 0){\n\t\t\t_pubCount = 0;\n\t\t\tif(cfg.ioPublish && dojo.publish && (!dfd || dfd && dfd.ioArgs.args.ioPublish !== false)){\n\t\t\t\tdojo.publish(\"/dojo/io/stop\");\n\t\t\t}\n\t\t}\n\t};\n\n\tvar _watchInFlight = function(){\n\t\t//summary:\n\t\t//\t\tinternal method that checks each inflight XMLHttpRequest to see\n\t\t//\t\tif it has completed or if the timeout situation applies.\n\n\t\tvar now = (new Date()).getTime();\n\t\t// make sure sync calls stay thread safe, if this callback is called\n\t\t// during a sync call and this results in another sync call before the\n\t\t// first sync call ends the browser hangs\n\t\tif(!dojo._blockAsync){\n\t\t\t// we need manual loop because we often modify _inFlight (and therefore 'i') while iterating\n\t\t\t// note: the second clause is an assigment on purpose, lint may complain\n\t\t\tfor(var i = 0, tif; i < _inFlight.length && (tif = _inFlight[i]); i++){\n\t\t\t\tvar dfd = tif.dfd;\n\t\t\t\tvar func = function(){\n\t\t\t\t\tif(!dfd || dfd.canceled || !tif.validCheck(dfd)){\n\t\t\t\t\t\t_inFlight.splice(i--, 1);\n\t\t\t\t\t\t_pubCount -= 1;\n\t\t\t\t\t}else if(tif.ioCheck(dfd)){\n\t\t\t\t\t\t_inFlight.splice(i--, 1);\n\t\t\t\t\t\ttif.resHandle(dfd);\n\t\t\t\t\t\t_pubCount -= 1;\n\t\t\t\t\t}else if(dfd.startTime){\n\t\t\t\t\t\t//did we timeout?\n\t\t\t\t\t\tif(dfd.startTime + (dfd.ioArgs.args.timeout || 0) < now){\n\t\t\t\t\t\t\t_inFlight.splice(i--, 1);\n\t\t\t\t\t\t\tvar err = new Error(\"timeout exceeded\");\n\t\t\t\t\t\t\terr.dojoType = \"timeout\";\n\t\t\t\t\t\t\tdfd.errback(err);\n\t\t\t\t\t\t\t//Cancel the request so the io module can do appropriate cleanup.\n\t\t\t\t\t\t\tdfd.cancel();\n\t\t\t\t\t\t\t_pubCount -= 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tif(dojo.config.debugAtAllCosts){\n\t\t\t\t\tfunc.call(this);\n\t\t\t\t}else{\n//\t\t\t\t\ttry{\n\t\t\t\t\t\tfunc.call(this);\n\t/*\t\t\t\t}catch(e){\n\t\t\t\t\t\tdfd.errback(e);\n\t\t\t\t\t}*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_checkPubCount(dfd);\n\n\t\tif(!_inFlight.length){\n\t\t\tclearInterval(_inFlightIntvl);\n\t\t\t_inFlightIntvl = null;\n\t\t}\n\t};\n\n\tdojo._ioCancelAll = function(){\n\t\t//summary: Cancels all pending IO requests, regardless of IO type\n\t\t//(xhr, script, iframe).\n\t\ttry{\n\t\t\tarray.forEach(_inFlight, function(i){\n\t\t\t\ttry{\n\t\t\t\t\ti.dfd.cancel();\n\t\t\t\t}catch(e){/*squelch*/}\n\t\t\t});\n\t\t}catch(e){/*squelch*/}\n\t};\n\n\t//Automatically call cancel all io calls on unload\n\t//in IE for trac issue #2357.\n\tif(has(\"ie\")){\n\t\ton(window, \"unload\", dojo._ioCancelAll);\n\t}\n\n\tdojo._ioNotifyStart = function(/*Deferred*/dfd){\n\t\t// summary:\n\t\t//\t\tIf dojo.publish is available, publish topics\n\t\t//\t\tabout the start of a request queue and/or the\n\t\t//\t\tthe beginning of request.\n\t\t// description:\n\t\t//\t\tUsed by IO transports. An IO transport should\n\t\t//\t\tcall this method before making the network connection.\n\t\tif(cfg.ioPublish && dojo.publish && dfd.ioArgs.args.ioPublish !== false){\n\t\t\tif(!_pubCount){\n\t\t\t\tdojo.publish(\"/dojo/io/start\");\n\t\t\t}\n\t\t\t_pubCount += 1;\n\t\t\tdojo.publish(\"/dojo/io/send\", [dfd]);\n\t\t}\n\t};\n\n\tdojo._ioWatch = function(dfd, validCheck, ioCheck, resHandle){\n\t\t// summary:\n\t\t//\t\tWatches the io request represented by dfd to see if it completes.\n\t\t// dfd: Deferred\n\t\t//\t\tThe Deferred object to watch.\n\t\t// validCheck: Function\n\t\t//\t\tFunction used to check if the IO request is still valid. Gets the dfd\n\t\t//\t\tobject as its only argument.\n\t\t// ioCheck: Function\n\t\t//\t\tFunction used to check if basic IO call worked. Gets the dfd\n\t\t//\t\tobject as its only argument.\n\t\t// resHandle: Function\n\t\t//\t\tFunction used to process response. Gets the dfd\n\t\t//\t\tobject as its only argument.\n\t\tvar args = dfd.ioArgs.args;\n\t\tif(args.timeout){\n\t\t\tdfd.startTime = (new Date()).getTime();\n\t\t}\n\n\t\t_inFlight.push({dfd: dfd, validCheck: validCheck, ioCheck: ioCheck, resHandle: resHandle});\n\t\tif(!_inFlightIntvl){\n\t\t\t_inFlightIntvl = setInterval(_watchInFlight, 50);\n\t\t}\n\t\t// handle sync requests\n\t\t//A weakness: async calls in flight\n\t\t//could have their handlers called as part of the\n\t\t//_watchInFlight call, before the sync's callbacks\n\t\t// are called.\n\t\tif(args.sync){\n\t\t\t_watchInFlight();\n\t\t}\n\t};\n\n\tvar _defaultContentType = \"application/x-www-form-urlencoded\";\n\n\tvar _validCheck = function(/*Deferred*/dfd){\n\t\treturn dfd.ioArgs.xhr.readyState; //boolean\n\t};\n\tvar _ioCheck = function(/*Deferred*/dfd){\n\t\treturn 4 == dfd.ioArgs.xhr.readyState; //boolean\n\t};\n\tvar _resHandle = function(/*Deferred*/dfd){\n\t\tvar xhr = dfd.ioArgs.xhr;\n\t\tif(dojo._isDocumentOk(xhr)){\n\t\t\tdfd.callback(dfd);\n\t\t}else{\n\t\t\tvar err = new Error(\"Unable to load \" + dfd.ioArgs.url + \" status:\" + xhr.status);\n\t\t\terr.status = xhr.status;\n\t\t\terr.responseText = xhr.responseText;\n\t\t\terr.xhr = xhr;\n\t\t\tdfd.errback(err);\n\t\t}\n\t};\n\n\tdojo._ioAddQueryToUrl = function(/*dojo.__IoCallbackArgs*/ioArgs){\n\t\t//summary: Adds query params discovered by the io deferred construction to the URL.\n\t\t//Only use this for operations which are fundamentally GET-type operations.\n\t\tif(ioArgs.query.length){\n\t\t\tioArgs.url += (ioArgs.url.indexOf(\"?\") == -1 ? \"?\" : \"&\") + ioArgs.query;\n\t\t\tioArgs.query = null;\n\t\t}\n\t};\n\n\t/*=====\n\tdojo.declare(\"dojo.__XhrArgs\", dojo.__IoArgs, {\n\t\tconstructor: function(){\n\t\t\t//\tsummary:\n\t\t\t//\t\tIn addition to the properties listed for the dojo._IoArgs type,\n\t\t\t//\t\tthe following properties are allowed for dojo.xhr* methods.\n\t\t\t//\thandleAs: String?\n\t\t\t//\t\tAcceptable values are: text (default), json, json-comment-optional,\n\t\t\t//\t\tjson-comment-filtered, javascript, xml. See `dojo.contentHandlers`\n\t\t\t//\tsync: Boolean?\n\t\t\t//\t\tfalse is default. Indicates whether the request should\n\t\t\t//\t\tbe a synchronous (blocking) request.\n\t\t\t//\theaders: Object?\n\t\t\t//\t\tAdditional HTTP headers to send in the request.\n\t\t\t//\tfailOk: Boolean?\n\t\t\t//\t\tfalse is default. Indicates whether a request should be\n\t\t\t//\t\tallowed to fail (and therefore no console error message in\n\t\t\t//\t\tthe event of a failure)\n\t\t\t//\tcontentType: String|Boolean\n\t\t\t//\t\t\"application/x-www-form-urlencoded\" is default. Set to false to\n\t\t\t//\t\tprevent a Content-Type header from being sent, or to a string\n\t\t\t//\t\tto send a different Content-Type.\n\t\t\tthis.handleAs = handleAs;\n\t\t\tthis.sync = sync;\n\t\t\tthis.headers = headers;\n\t\t\tthis.failOk = failOk;\n\t\t}\n\t});\n\t=====*/\n\n\tdojo.xhr = function(/*String*/ method, /*dojo.__XhrArgs*/ args, /*Boolean?*/ hasBody){\n\t\t//\tsummary:\n\t\t//\t\tSends an HTTP request with the given method.\n\t\t//\tdescription:\n\t\t//\t\tSends an HTTP request with the given method.\n\t\t//\t\tSee also dojo.xhrGet(), xhrPost(), xhrPut() and dojo.xhrDelete() for shortcuts\n\t\t//\t\tfor those HTTP methods. There are also methods for \"raw\" PUT and POST methods\n\t\t//\t\tvia dojo.rawXhrPut() and dojo.rawXhrPost() respectively.\n\t\t//\tmethod:\n\t\t//\t\tHTTP method to be used, such as GET, POST, PUT, DELETE. Should be uppercase.\n\t\t//\thasBody:\n\t\t//\t\tIf the request has an HTTP body, then pass true for hasBody.\n\n\t\t//Make the Deferred object for this xhr request.\n\t\tvar dfd = dojo._ioSetArgs(args, _deferredCancel, _deferredOk, _deferError);\n\t\tvar ioArgs = dfd.ioArgs;\n\n\t\t//Pass the args to _xhrObj, to allow alternate XHR calls based specific calls, like\n\t\t//the one used for iframe proxies.\n\t\tvar xhr = ioArgs.xhr = dojo._xhrObj(ioArgs.args);\n\t\t//If XHR factory fails, cancel the deferred.\n\t\tif(!xhr){\n\t\t\tdfd.cancel();\n\t\t\treturn dfd;\n\t\t}\n\n\t\t//Allow for specifying the HTTP body completely.\n\t\tif(\"postData\" in args){\n\t\t\tioArgs.query = args.postData;\n\t\t}else if(\"putData\" in args){\n\t\t\tioArgs.query = args.putData;\n\t\t}else if(\"rawBody\" in args){\n\t\t\tioArgs.query = args.rawBody;\n\t\t}else if((arguments.length > 2 && !hasBody) || \"POST|PUT\".indexOf(method.toUpperCase()) == -1){\n\t\t\t//Check for hasBody being passed. If no hasBody,\n\t\t\t//then only append query string if not a POST or PUT request.\n\t\t\tdojo._ioAddQueryToUrl(ioArgs);\n\t\t}\n\n\t\t// IE 6 is a steaming pile. It won't let you call apply() on the native function (xhr.open).\n\t\t// workaround for IE6's apply() \"issues\"\n\t\txhr.open(method, ioArgs.url, args.sync !== true, args.user || undefined, args.password || undefined);\n\t\tif(args.headers){\n\t\t\tfor(var hdr in args.headers){\n\t\t\t\tif(hdr.toLowerCase() === \"content-type\" && !args.contentType){\n\t\t\t\t\targs.contentType = args.headers[hdr];\n\t\t\t\t}else if(args.headers[hdr]){\n\t\t\t\t\t//Only add header if it has a value. This allows for instnace, skipping\n\t\t\t\t\t//insertion of X-Requested-With by specifying empty value.\n\t\t\t\t\txhr.setRequestHeader(hdr, args.headers[hdr]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// FIXME: is this appropriate for all content types?\n\t\tif(args.contentType !== false){\n\t\t\txhr.setRequestHeader(\"Content-Type\", args.contentType || _defaultContentType);\n\t\t}\n\t\tif(!args.headers || !(\"X-Requested-With\" in args.headers)){\n\t\t\txhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n\t\t}\n\t\t// FIXME: set other headers here!\n\t\tdojo._ioNotifyStart(dfd);\n\t\tif(dojo.config.debugAtAllCosts){\n\t\t\txhr.send(ioArgs.query);\n\t\t}else{\n\t\t\ttry{\n\t\t\t\txhr.send(ioArgs.query);\n\t\t\t}catch(e){\n\t\t\t\tioArgs.error = e;\n\t\t\t\tdfd.cancel();\n\t\t\t}\n\t\t}\n\t\tdojo._ioWatch(dfd, _validCheck, _ioCheck, _resHandle);\n\t\txhr = null;\n\t\treturn dfd; // dojo.Deferred\n\t};\n\n\tdojo.xhrGet = function(/*dojo.__XhrArgs*/ args){\n\t\t//\tsummary:\n\t\t//\t\tSends an HTTP GET request to the server.\n\t\treturn dojo.xhr(\"GET\", args); // dojo.Deferred\n\t};\n\n\tdojo.rawXhrPost = dojo.xhrPost = function(/*dojo.__XhrArgs*/ args){\n\t\t//\tsummary:\n\t\t//\t\tSends an HTTP POST request to the server. In addtion to the properties\n\t\t//\t\tlisted for the dojo.__XhrArgs type, the following property is allowed:\n\t\t//\tpostData:\n\t\t//\t\tString. Send raw data in the body of the POST request.\n\t\treturn dojo.xhr(\"POST\", args, true); // dojo.Deferred\n\t};\n\n\tdojo.rawXhrPut = dojo.xhrPut = function(/*dojo.__XhrArgs*/ args){\n\t\t//\tsummary:\n\t\t//\t\tSends an HTTP PUT request to the server. In addtion to the properties\n\t\t//\t\tlisted for the dojo.__XhrArgs type, the following property is allowed:\n\t\t//\tputData:\n\t\t//\t\tString. Send raw data in the body of the PUT request.\n\t\treturn dojo.xhr(\"PUT\", args, true); // dojo.Deferred\n\t};\n\n\tdojo.xhrDelete = function(/*dojo.__XhrArgs*/ args){\n\t\t//\tsummary:\n\t\t//\t\tSends an HTTP DELETE request to the server.\n\t\treturn dojo.xhr(\"DELETE\", args); //dojo.Deferred\n\t};\n\n\t/*\n\tdojo.wrapForm = function(formNode){\n\t\t//summary:\n\t\t//\t\tA replacement for FormBind, but not implemented yet.\n\n\t\t// FIXME: need to think harder about what extensions to this we might\n\t\t// want. What should we allow folks to do w/ this? What events to\n\t\t// set/send?\n\t\tthrow new Error(\"dojo.wrapForm not yet implemented\");\n\t}\n\t*/\n\n\tdojo._isDocumentOk = function(http){\n\t\tvar stat = http.status || 0;\n\t\tstat =\n\t\t\t(stat >= 200 && stat < 300) || // allow any 2XX response code\n\t\t\tstat == 304 ||                 // or, get it out of the cache\n\t\t\tstat == 1223 ||                // or, Internet Explorer mangled the status code\n\t\t\t!stat;                         // or, we're Titanium/browser chrome/chrome extension requesting a local file\n\t\treturn stat; // Boolean\n\t};\n\n\tdojo._getText = function(url){\n\t\tvar result;\n\t\tdojo.xhrGet({url:url, sync:true, load:function(text){\n\t\t\tresult = text;\n\t\t}});\n\t\treturn result;\n\t};\n\n\t// Add aliases for static functions to dojo.xhr since dojo.xhr is what's returned from this module\n\tlang.mixin(dojo.xhr, {\n\t\t_xhrObj: dojo._xhrObj,\n\t\tfieldToObject: domForm.fieldToObject,\n\t\tformToObject: domForm.toObject,\n\t\tobjectToQuery: ioq.objectToQuery,\n\t\tformToQuery: domForm.toQuery,\n\t\tformToJson: domForm.toJson,\n\t\tqueryToObject: ioq.queryToObject,\n\t\tcontentHandlers: handlers,\n\t\t_ioSetArgs: dojo._ioSetArgs,\n\t\t_ioCancelAll: dojo._ioCancelAll,\n\t\t_ioNotifyStart: dojo._ioNotifyStart,\n\t\t_ioWatch: dojo._ioWatch,\n\t\t_ioAddQueryToUrl: dojo._ioAddQueryToUrl,\n\t\t_isDocumentOk: dojo._isDocumentOk,\n\t\t_getText: dojo._getText,\n\t\tget: dojo.xhrGet,\n\t\tpost: dojo.xhrPost,\n\t\tput: dojo.xhrPut,\n\t\tdel: dojo.xhrDelete\t// because \"delete\" is a reserved word\n\t});\n\n\treturn dojo.xhr;\n});\n\n},\n'dojo/_base/unload':function(){\ndefine([\"./kernel\", \"./connect\"], function(dojo, connect) {\n\t// module:\n\t//\t\tdojo/unload\n\t// summary:\n\t//\t\tThis module contains the document and window unload detection API.\n\n\tvar win = window;\n\n\t/*=====\n\t\tdojo.windowUnloaded = function(){\n\t\t\t// summary:\n\t\t\t//\t\tsignal fired by impending window destruction. You may use\n\t\t\t//\t\tdojo.addOnWindowUnload() to register a listener for this\n\t\t\t//\t\tevent. NOTE: if you wish to dojo.connect() to this method\n\t\t\t//\t\tto perform page/application cleanup, be aware that this\n\t\t\t//\t\tevent WILL NOT fire if no handler has been registered with\n\t\t\t//\t\tdojo.addOnWindowUnload. This behavior started in Dojo 1.3.\n\t\t\t//\t\tPrevious versions always triggered dojo.windowUnloaded. See\n\t\t\t//\t\tdojo.addOnWindowUnload for more info.\n\t\t};\n\t=====*/\n\n\tdojo.addOnWindowUnload = function(/*Object?|Function?*/obj, /*String|Function?*/functionName){\n\t\t// summary:\n\t\t//\t\tregisters a function to be triggered when window.onunload\n\t\t//\t\tfires.\n\t\t//\tdescription:\n\t\t//\t\tThe first time that addOnWindowUnload is called Dojo\n\t\t//\t\twill register a page listener to trigger your unload\n\t\t//\t\thandler with. Note that registering these handlers may\n\t\t//\t\tdestory \"fastback\" page caching in browsers that support\n\t\t//\t\tit. Be careful trying to modify the DOM or access\n\t\t//\t\tJavaScript properties during this phase of page unloading:\n\t\t//\t\tthey may not always be available. Consider\n\t\t//\t\tdojo.addOnUnload() if you need to modify the DOM or do\n\t\t//\t\theavy JavaScript work since it fires at the eqivalent of\n\t\t//\t\tthe page's \"onbeforeunload\" event.\n\t\t// example:\n\t\t//\t| dojo.addOnWindowUnload(functionPointer)\n\t\t//\t| dojo.addOnWindowUnload(object, \"functionName\");\n\t\t//\t| dojo.addOnWindowUnload(object, function(){ /* ... */});\n\n\t\tif (!dojo.windowUnloaded) {\n\t\t\tconnect.connect(win, \"unload\", (dojo.windowUnloaded= function(){}));\n\t\t}\n\t\tconnect.connect(win, \"unload\", obj, functionName);\n\t};\n\n\tdojo.addOnUnload = function(/*Object?|Function?*/obj, /*String|Function?*/functionName){\n\t\t// summary:\n\t\t//\t\tregisters a function to be triggered when the page unloads.\n\t\t//\tdescription:\n\t\t//\t\tThe first time that addOnUnload is called Dojo will\n\t\t//\t\tregister a page listener to trigger your unload handler\n\t\t//\t\twith.\n\t\t//\n\t\t//\t\tIn a browser enviroment, the functions will be triggered\n\t\t//\t\tduring the window.onbeforeunload event. Be careful of doing\n\t\t//\t\ttoo much work in an unload handler. onbeforeunload can be\n\t\t//\t\ttriggered if a link to download a file is clicked, or if\n\t\t//\t\tthe link is a javascript: link. In these cases, the\n\t\t//\t\tonbeforeunload event fires, but the document is not\n\t\t//\t\tactually destroyed. So be careful about doing destructive\n\t\t//\t\toperations in a dojo.addOnUnload callback.\n\t\t//\n\t\t//\t\tFurther note that calling dojo.addOnUnload will prevent\n\t\t//\t\tbrowsers from using a \"fast back\" cache to make page\n\t\t//\t\tloading via back button instantaneous.\n\t\t// example:\n\t\t//\t| dojo.addOnUnload(functionPointer)\n\t\t//\t| dojo.addOnUnload(object, \"functionName\")\n\t\t//\t| dojo.addOnUnload(object, function(){ /* ... */});\n\n\t\tconnect.connect(win, \"beforeunload\", obj, functionName);\n\t};\n\n\treturn {\n\t\taddOnWindowUnload: dojo.addOnWindowUnload,\n\t\taddOnUnload: dojo.addOnUnload\n\t};\n});\n\n},\n'dojo/_base/NodeList':function(){\ndefine([\"./kernel\", \"../query\", \"./array\", \"./html\", \"../NodeList-dom\"], function(dojo, query, array){\n  //  module:\n  //    dojo/_base/NodeList\n  //  summary:\n  //    This module defines dojo.NodeList.\n \nvar NodeList = query.NodeList;\n\n\t/*=====\n\tdojo.extend(dojo.NodeList, {\n\t\tconnect: function(methodName, objOrFunc, funcName){\n\t\t\t// summary:\n\t\t\t//\t\tattach event handlers to every item of the NodeList. Uses dojo.connect()\n\t\t\t//\t\tso event properties are normalized\n\t\t\t// methodName: String\n\t\t\t//\t\tthe name of the method to attach to. For DOM events, this should be\n\t\t\t//\t\tthe lower-case name of the event\n\t\t\t// objOrFunc: Object|Function|String\n\t\t\t//\t\tif 2 arguments are passed (methodName, objOrFunc), objOrFunc should\n\t\t\t//\t\treference a function or be the name of the function in the global\n\t\t\t//\t\tnamespace to attach. If 3 arguments are provided\n\t\t\t//\t\t(methodName, objOrFunc, funcName), objOrFunc must be the scope to\n\t\t\t//\t\tlocate the bound function in\n\t\t\t// funcName: String?\n\t\t\t//\t\toptional. A string naming the function in objOrFunc to bind to the\n\t\t\t//\t\tevent. May also be a function reference.\n\t\t\t// example:\n\t\t\t//\t\tadd an onclick handler to every button on the page\n\t\t\t//\t\t|\tdojo.query(\"div:nth-child(odd)\").connect(\"onclick\", function(e){\n\t\t\t//\t\t|\t\tconsole.log(\"clicked!\");\n\t\t\t//\t\t|\t});\n\t\t\t// example:\n\t\t\t//\t\tattach foo.bar() to every odd div's onmouseover\n\t\t\t//\t\t|\tdojo.query(\"div:nth-child(odd)\").connect(\"onmouseover\", foo, \"bar\");\n\t\t},\n\t\tcoords: function(){\n\t\t\t// summary:\n\t\t\t//\t\tDeprecated: Use position() for border-box x/y/w/h\n\t\t\t//\t\tor marginBox() for margin-box w/h/l/t.\n\t\t\t//\t\tReturns the box objects of all elements in a node list as\n\t\t\t//\t\tan Array (*not* a NodeList). Acts like `dojo.coords`, though assumes\n\t\t\t//\t\tthe node passed is each node in this list.\n\n\t\t\treturn dojo.map(this, dojo.coords); // Array\n\t\t}\n\t });\n\n\t var NodeList = dojo.NodeList;\n\t=====*/\n\tvar nlp = NodeList.prototype;\n\n\t// don't bind early to dojo.connect since we no longer explicitly depend on it\n\tnlp.connect = NodeList._adaptAsForEach(function(){\n\t\treturn dojo.connect.apply(this, arguments);\n\t});\n\tnlp.coords = NodeList._adaptAsMap(dojo.coords);\n\n\tNodeList.events = [\n\t\t// summary:\n\t\t//\t\tlist of all DOM events used in NodeList\n\t\t\"blur\", \"focus\", \"change\", \"click\", \"error\", \"keydown\", \"keypress\",\n\t\t\"keyup\", \"load\", \"mousedown\", \"mouseenter\", \"mouseleave\", \"mousemove\",\n\t\t\"mouseout\", \"mouseover\", \"mouseup\", \"submit\"\n\t];\n\n\t// FIXME: pseudo-doc the above automatically generated on-event functions\n\n\t// syntactic sugar for DOM events\n\tarray.forEach(NodeList.events, function(evt){\n\t\t\tvar _oe = \"on\" + evt;\n\t\t\tnlp[_oe] = function(a, b){\n\t\t\t\treturn this.connect(_oe, a, b);\n\t\t\t};\n\t\t\t\t// FIXME: should these events trigger publishes?\n\t\t\t\t/*\n\t\t\t\treturn (a ? this.connect(_oe, a, b) :\n\t\t\t\t\t\t\tthis.forEach(function(n){\n\t\t\t\t\t\t\t\t// FIXME:\n\t\t\t\t\t\t\t\t//\t\tlisteners get buried by\n\t\t\t\t\t\t\t\t//\t\taddEventListener and can't be dug back\n\t\t\t\t\t\t\t\t//\t\tout to be triggered externally.\n\t\t\t\t\t\t\t\t// see:\n\t\t\t\t\t\t\t\t//\t\thttp://developer.mozilla.org/en/docs/DOM:element\n\n\t\t\t\t\t\t\t\tconsole.log(n, evt, _oe);\n\n\t\t\t\t\t\t\t\t// FIXME: need synthetic event support!\n\t\t\t\t\t\t\t\tvar _e = { target: n, faux: true, type: evt };\n\t\t\t\t\t\t\t\t// dojo._event_listener._synthesizeEvent({}, { target: n, faux: true, type: evt });\n\t\t\t\t\t\t\t\ttry{ n[evt](_e); }catch(e){ console.log(e); }\n\t\t\t\t\t\t\t\ttry{ n[_oe](_e); }catch(e){ console.log(e); }\n\t\t\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t\t*/\n\t\t}\n\t);\n\n\tdojo.NodeList = NodeList;\n\treturn dojo.NodeList;\n});\n\n},\n'dojo/_base/Color':function(){\ndefine([\"./kernel\", \"./lang\", \"./array\", \"./config\"], function(dojo, lang, ArrayUtil, config){\n\n\tvar Color = dojo.Color = function(/*Array|String|Object*/ color){\n\t\t// summary:\n\t\t//\t\tTakes a named string, hex string, array of rgb or rgba values,\n\t\t//\t\tan object with r, g, b, and a properties, or another `dojo.Color` object\n\t\t//\t\tand creates a new Color instance to work from.\n\t\t//\n\t\t// example:\n\t\t//\t\tWork with a Color instance:\n\t\t//\t | var c = new dojo.Color();\n\t\t//\t | c.setColor([0,0,0]); // black\n\t\t//\t | var hex = c.toHex(); // #000000\n\t\t//\n\t\t// example:\n\t\t//\t\tWork with a node's color:\n\t\t//\t | var color = dojo.style(\"someNode\", \"backgroundColor\");\n\t\t//\t | var n = new dojo.Color(color);\n\t\t//\t | // adjust the color some\n\t\t//\t | n.r *= .5;\n\t\t//\t | console.log(n.toString()); // rgb(128, 255, 255);\n\t\tif(color){ this.setColor(color); }\n\t};\n\n\t/*=====\n\tlang.mixin(dojo.Color,{\n\t\tnamed:{\n\t\t\t// summary: Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.\n\t\t}\n\t});\n\t=====*/\n\n\t// FIXME:\n\t// there's got to be a more space-efficient way to encode or discover\n\t// these!! Use hex?\n\tColor.named = {\n\t\t\"black\":  [0,0,0],\n\t\t\"silver\": [192,192,192],\n\t\t\"gray\":\t  [128,128,128],\n\t\t\"white\":  [255,255,255],\n\t\t\"maroon\": [128,0,0],\n\t\t\"red\":\t  [255,0,0],\n\t\t\"purple\": [128,0,128],\n\t\t\"fuchsia\":[255,0,255],\n\t\t\"green\":  [0,128,0],\n\t\t\"lime\":\t  [0,255,0],\n\t\t\"olive\":  [128,128,0],\n\t\t\"yellow\": [255,255,0],\n\t\t\"navy\":\t  [0,0,128],\n\t\t\"blue\":\t  [0,0,255],\n\t\t\"teal\":\t  [0,128,128],\n\t\t\"aqua\":\t  [0,255,255],\n\t\t\"transparent\": config.transparentColor || [0,0,0,0]\n\t};\n\n\tlang.extend(Color, {\n\t\tr: 255, g: 255, b: 255, a: 1,\n\t\t_set: function(r, g, b, a){\n\t\t\tvar t = this; t.r = r; t.g = g; t.b = b; t.a = a;\n\t\t},\n\t\tsetColor: function(/*Array|String|Object*/ color){\n\t\t\t// summary:\n\t\t\t//\t\tTakes a named string, hex string, array of rgb or rgba values,\n\t\t\t//\t\tan object with r, g, b, and a properties, or another `dojo.Color` object\n\t\t\t//\t\tand sets this color instance to that value.\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t|\tvar c = new dojo.Color(); // no color\n\t\t\t//\t|\tc.setColor(\"#ededed\"); // greyish\n\t\t\tif(lang.isString(color)){\n\t\t\t\tColor.fromString(color, this);\n\t\t\t}else if(lang.isArray(color)){\n\t\t\t\tColor.fromArray(color, this);\n\t\t\t}else{\n\t\t\t\tthis._set(color.r, color.g, color.b, color.a);\n\t\t\t\tif(!(color instanceof Color)){ this.sanitize(); }\n\t\t\t}\n\t\t\treturn this;\t// dojo.Color\n\t\t},\n\t\tsanitize: function(){\n\t\t\t// summary:\n\t\t\t//\t\tEnsures the object has correct attributes\n\t\t\t// description:\n\t\t\t//\t\tthe default implementation does nothing, include dojo.colors to\n\t\t\t//\t\taugment it with real checks\n\t\t\treturn this;\t// dojo.Color\n\t\t},\n\t\ttoRgb: function(){\n\t\t\t// summary:\n\t\t\t//\t\tReturns 3 component array of rgb values\n\t\t\t// example:\n\t\t\t//\t|\tvar c = new dojo.Color(\"#000000\");\n\t\t\t//\t|\tconsole.log(c.toRgb()); // [0,0,0]\n\t\t\tvar t = this;\n\t\t\treturn [t.r, t.g, t.b]; // Array\n\t\t},\n\t\ttoRgba: function(){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a 4 component array of rgba values from the color\n\t\t\t//\t\trepresented by this object.\n\t\t\tvar t = this;\n\t\t\treturn [t.r, t.g, t.b, t.a];\t// Array\n\t\t},\n\t\ttoHex: function(){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a CSS color string in hexadecimal representation\n\t\t\t// example:\n\t\t\t//\t|\tconsole.log(new dojo.Color([0,0,0]).toHex()); // #000000\n\t\t\tvar arr = ArrayUtil.map([\"r\", \"g\", \"b\"], function(x){\n\t\t\t\tvar s = this[x].toString(16);\n\t\t\t\treturn s.length < 2 ? \"0\" + s : s;\n\t\t\t}, this);\n\t\t\treturn \"#\" + arr.join(\"\");\t// String\n\t\t},\n\t\ttoCss: function(/*Boolean?*/ includeAlpha){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a css color string in rgb(a) representation\n\t\t\t// example:\n\t\t\t//\t|\tvar c = new dojo.Color(\"#FFF\").toCss();\n\t\t\t//\t|\tconsole.log(c); // rgb('255','255','255')\n\t\t\tvar t = this, rgb = t.r + \", \" + t.g + \", \" + t.b;\n\t\t\treturn (includeAlpha ? \"rgba(\" + rgb + \", \" + t.a : \"rgb(\" + rgb) + \")\";\t// String\n\t\t},\n\t\ttoString: function(){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a visual representation of the color\n\t\t\treturn this.toCss(true); // String\n\t\t}\n\t});\n\n\tColor.blendColors = dojo.blendColors = function(\n\t\t/*dojo.Color*/ start,\n\t\t/*dojo.Color*/ end,\n\t\t/*Number*/ weight,\n\t\t/*dojo.Color?*/ obj\n\t){\n\t\t// summary:\n\t\t//\t\tBlend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,\n\t\t//\t\tcan reuse a previously allocated dojo.Color object for the result\n\t\tvar t = obj || new Color();\n\t\tArrayUtil.forEach([\"r\", \"g\", \"b\", \"a\"], function(x){\n\t\t\tt[x] = start[x] + (end[x] - start[x]) * weight;\n\t\t\tif(x != \"a\"){ t[x] = Math.round(t[x]); }\n\t\t});\n\t\treturn t.sanitize();\t// dojo.Color\n\t};\n\n\tColor.fromRgb = dojo.colorFromRgb = function(/*String*/ color, /*dojo.Color?*/ obj){\n\t\t// summary:\n\t\t//\t\tReturns a `dojo.Color` instance from a string of the form\n\t\t//\t\t\"rgb(...)\" or \"rgba(...)\". Optionally accepts a `dojo.Color`\n\t\t//\t\tobject to update with the parsed value and return instead of\n\t\t//\t\tcreating a new object.\n\t\t// returns:\n\t\t//\t\tA dojo.Color object. If obj is passed, it will be the return value.\n\t\tvar m = color.toLowerCase().match(/^rgba?\\(([\\s\\.,0-9]+)\\)/);\n\t\treturn m && Color.fromArray(m[1].split(/\\s*,\\s*/), obj);\t// dojo.Color\n\t};\n\n\tColor.fromHex = dojo.colorFromHex = function(/*String*/ color, /*dojo.Color?*/ obj){\n\t\t// summary:\n\t\t//\t\tConverts a hex string with a '#' prefix to a color object.\n\t\t//\t\tSupports 12-bit #rgb shorthand. Optionally accepts a\n\t\t//\t\t`dojo.Color` object to update with the parsed value.\n\t\t//\n\t\t// returns:\n\t\t//\t\tA dojo.Color object. If obj is passed, it will be the return value.\n\t\t//\n\t\t// example:\n\t\t//\t | var thing = dojo.colorFromHex(\"#ededed\"); // grey, longhand\n\t\t//\n\t\t// example:\n\t\t//\t| var thing = dojo.colorFromHex(\"#000\"); // black, shorthand\n\t\tvar t = obj || new Color(),\n\t\t\tbits = (color.length == 4) ? 4 : 8,\n\t\t\tmask = (1 << bits) - 1;\n\t\tcolor = Number(\"0x\" + color.substr(1));\n\t\tif(isNaN(color)){\n\t\t\treturn null; // dojo.Color\n\t\t}\n\t\tArrayUtil.forEach([\"b\", \"g\", \"r\"], function(x){\n\t\t\tvar c = color & mask;\n\t\t\tcolor >>= bits;\n\t\t\tt[x] = bits == 4 ? 17 * c : c;\n\t\t});\n\t\tt.a = 1;\n\t\treturn t;\t// dojo.Color\n\t};\n\n\tColor.fromArray = dojo.colorFromArray = function(/*Array*/ a, /*dojo.Color?*/ obj){\n\t\t// summary:\n\t\t//\t\tBuilds a `dojo.Color` from a 3 or 4 element array, mapping each\n\t\t//\t\telement in sequence to the rgb(a) values of the color.\n\t\t// example:\n\t\t//\t\t| var myColor = dojo.colorFromArray([237,237,237,0.5]); // grey, 50% alpha\n\t\t// returns:\n\t\t//\t\tA dojo.Color object. If obj is passed, it will be the return value.\n\t\tvar t = obj || new Color();\n\t\tt._set(Number(a[0]), Number(a[1]), Number(a[2]), Number(a[3]));\n\t\tif(isNaN(t.a)){ t.a = 1; }\n\t\treturn t.sanitize();\t// dojo.Color\n\t};\n\n\tColor.fromString = dojo.colorFromString = function(/*String*/ str, /*dojo.Color?*/ obj){\n\t\t// summary:\n\t\t//\t\tParses `str` for a color value. Accepts hex, rgb, and rgba\n\t\t//\t\tstyle color values.\n\t\t// description:\n\t\t//\t\tAcceptable input values for str may include arrays of any form\n\t\t//\t\taccepted by dojo.colorFromArray, hex strings such as \"#aaaaaa\", or\n\t\t//\t\trgb or rgba strings such as \"rgb(133, 200, 16)\" or \"rgba(10, 10,\n\t\t//\t\t10, 50)\"\n\t\t// returns:\n\t\t//\t\tA dojo.Color object. If obj is passed, it will be the return value.\n\t\tvar a = Color.named[str];\n\t\treturn a && Color.fromArray(a, obj) || Color.fromRgb(str, obj) || Color.fromHex(str, obj);\t// dojo.Color\n\t};\n\n\treturn Color;\n});\n\n},\n'dojo/selector/_loader':function(){\ndefine([\"../has\", \"require\"],\n\t\tfunction(has, require){\n// summary:\n//\t\tThis module handles loading the appropriate selector engine for the given browser\n\"use strict\";\nvar testDiv = document.createElement(\"div\");\nhas.add(\"dom-qsa2.1\", !!testDiv.querySelectorAll);\nhas.add(\"dom-qsa3\", function(){\n\t\t\t// test to see if we have a reasonable native selector engine available\n\t\t\ttry{\n\t\t\t\ttestDiv.innerHTML = \"<p class='TEST'></p>\"; // test kind of from sizzle\n\t\t\t\t// Safari can't handle uppercase or unicode characters when\n\t\t\t\t// in quirks mode, IE8 can't handle pseudos like :empty\n\t\t\t\treturn testDiv.querySelectorAll(\".TEST:empty\").length == 1;\n\t\t\t}catch(e){}\n\t\t});\nvar fullEngine;\nvar acme = \"./acme\", lite = \"./lite\";\nreturn {\n\tload: function(id, parentRequire, loaded, config){\n\t\tvar req = require;\n\t\t// here we implement the default logic for choosing a selector engine\n\t\tid = id == \"default\" ? has(\"config-selectorEngine\") || \"css3\" : id;\n\t\tid = id == \"css2\" || id == \"lite\" ? lite :\n\t\t\t\tid == \"css2.1\" ? has(\"dom-qsa2.1\") ? lite : acme :\n\t\t\t\tid == \"css3\" ? has(\"dom-qsa3\") ? lite : acme :\n\t\t\t\tid == \"acme\" ? acme : (req = parentRequire) && id;\n\t\tif(id.charAt(id.length-1) == '?'){\n\t\t\tid = id.substring(0,id.length - 1);\n\t\t\tvar optionalLoad = true;\n\t\t}\n\t\t// the query engine is optional, only load it if a native one is not available or existing one has not been loaded\n\t\tif(optionalLoad && (has(\"dom-compliant-qsa\") || fullEngine)){\n\t\t\treturn loaded(fullEngine);\n\t\t}\n\t\t// load the referenced selector engine\n\t\treq([id], function(engine){\n\t\t\tif(id != \"./lite\"){\n\t\t\t\tfullEngine = engine;\n\t\t\t}\n\t\t\tloaded(engine);\n\t\t});\n\t}\n};\n});\n\n},\n'dojo/on':function(){\ndefine([\"./has!dom-addeventlistener?:./aspect\", \"./_base/kernel\", \"./has\"], function(aspect, dojo, has){\n\t// summary:\n\t//\t\tThe export of this module is a function that provides core event listening functionality. With this function\n\t//\t\tyou can provide a target, event type, and listener to be notified of\n\t//\t\tfuture matching events that are fired.\n\t// target: Element|Object\n\t//\t\tThis is the target object or DOM element that to receive events from\n\t// type: String|Function\n\t// \t\tThis is the name of the event to listen for or an extension event type.\n\t// listener: Function\n\t// \t\tThis is the function that should be called when the event fires.\n\t// returns: Object\n\t// \t\tAn object with a remove() method that can be used to stop listening for this\n\t// \t\tevent.\n\t// description:\n\t// \t\tTo listen for \"click\" events on a button node, we can do:\n\t// \t\t|\tdefine([\"dojo/on\"], function(listen){\n\t// \t\t|\t\ton(button, \"click\", clickHandler);\n\t//\t\t|\t\t...\n\t//  \tEvented JavaScript objects can also have their own events.\n\t// \t\t|\tvar obj = new Evented;\n\t//\t\t|\ton(obj, \"foo\", fooHandler);\n\t//\t\tAnd then we could publish a \"foo\" event:\n\t//\t\t|\ton.emit(obj, \"foo\", {key: \"value\"});\n\t//\t\tWe can use extension events as well. For example, you could listen for a tap gesture:\n\t// \t\t|\tdefine([\"dojo/on\", \"dojo/gesture/tap\", function(listen, tap){\n\t// \t\t|\t\ton(button, tap, tapHandler);\n\t//\t\t|\t\t...\n\t//\t\twhich would trigger fooHandler. Note that for a simple object this is equivalent to calling:\n\t//\t\t|\tobj.onfoo({key:\"value\"});\n\t//\t\tIf you use on.emit on a DOM node, it will use native event dispatching when possible.\n\n \t\"use strict\";\n\tif(1){ // check to make sure we are in a browser, this module should work anywhere\n\t\tvar major = window.ScriptEngineMajorVersion;\n\t\thas.add(\"jscript\", major && (major() + ScriptEngineMinorVersion() / 10));\n\t\thas.add(\"event-orientationchange\", has(\"touch\") && !has(\"android\")); // TODO: how do we detect this?\n\t}\n\tvar on = function(target, type, listener, dontFix){\n\t\tif(target.on){ \n\t\t\t// delegate to the target's on() method, so it can handle it's own listening if it wants\n\t\t\treturn target.on(type, listener);\n\t\t}\n\t\t// delegate to main listener code\n\t\treturn on.parse(target, type, listener, addListener, dontFix, this);\n\t};\n\ton.pausable =  function(target, type, listener, dontFix){\n\t\t// summary:\n\t\t//\t\tThis function acts the same as on(), but with pausable functionality. The\n\t\t// \t\treturned signal object has pause() and resume() functions. Calling the\n\t\t//\t\tpause() method will cause the listener to not be called for future events. Calling the\n\t\t//\t\tresume() method will cause the listener to again be called for future events.\n\t\tvar paused;\n\t\tvar signal = on(target, type, function(){\n\t\t\tif(!paused){\n\t\t\t\treturn listener.apply(this, arguments);\n\t\t\t}\n\t\t}, dontFix);\n\t\tsignal.pause = function(){\n\t\t\tpaused = true;\n\t\t};\n\t\tsignal.resume = function(){\n\t\t\tpaused = false;\n\t\t};\n\t\treturn signal;\n\t};\n\ton.once = function(target, type, listener, dontFix){\n\t\t// summary:\n\t\t//\t\tThis function acts the same as on(), but will only call the listener once. The \n\t\t// \t\tlistener will be called for the first\n\t\t//\t\tevent that takes place and then listener will automatically be removed.\n\t\tvar signal = on(target, type, function(){\n\t\t\t// remove this listener\n\t\t\tsignal.remove();\n\t\t\t// proceed to call the listener\n\t\t\treturn listener.apply(this, arguments);\n\t\t});\n\t\treturn signal;\n\t};\n\ton.parse = function(target, type, listener, addListener, dontFix, matchesTarget){\n\t\tif(type.call){\n\t\t\t// event handler function\n\t\t\t// on(node, dojo.touch.press, touchListener);\n\t\t\treturn type.call(matchesTarget, target, listener);\n\t\t}\n\n\t\tif(type.indexOf(\",\") > -1){\n\t\t\t// we allow comma delimited event names, so you can register for multiple events at once\n\t\t\tvar events = type.split(/\\s*,\\s*/);\n\t\t\tvar handles = [];\n\t\t\tvar i = 0;\n\t\t\tvar eventName;\n\t\t\twhile(eventName = events[i++]){\n\t\t\t\thandles.push(addListener(target, eventName, listener, dontFix, matchesTarget));\n\t\t\t}\n\t\t\thandles.remove = function(){\n\t\t\t\tfor(var i = 0; i < handles.length; i++){\n\t\t\t\t\thandles[i].remove();\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn handles;\n\t\t}\n\t\treturn addListener(target, type, listener, dontFix, matchesTarget)\n\t};\n\tvar touchEvents = /^touch/;\n\tfunction addListener(target, type, listener, dontFix, matchesTarget){\t\t\n\t\t// event delegation:\n\t\tvar selector = type.match(/(.*):(.*)/);\n\t\t// if we have a selector:event, the last one is interpreted as an event, and we use event delegation\n\t\tif(selector){\n\t\t\ttype = selector[2];\n\t\t\tselector = selector[1];\n\t\t\t// create the extension event for selectors and directly call it\n\t\t\treturn on.selector(selector, type).call(matchesTarget, target, listener);\n\t\t}\n\t\t// test to see if it a touch event right now, so we don't have to do it every time it fires\n\t\tif(has(\"touch\")){\n\t\t\tif(touchEvents.test(type)){\n\t\t\t\t// touch event, fix it\n\t\t\t\tlistener = fixTouchListener(listener);\n\t\t\t}\n\t\t\tif(!has(\"event-orientationchange\") && (type == \"orientationchange\")){\n\t\t\t\t//\"orientationchange\" not supported <= Android 2.1, \n\t\t\t\t//but works through \"resize\" on window\n\t\t\t\ttype = \"resize\"; \n\t\t\t\ttarget = window;\n\t\t\t\tlistener = fixTouchListener(listener);\n\t\t\t} \n\t\t}\n\t\t// normal path, the target is |this|\n\t\tif(target.addEventListener){\n\t\t\t// the target has addEventListener, which should be used if available (might or might not be a node, non-nodes can implement this method as well)\n\t\t\t// check for capture conversions\n\t\t\tvar capture = type in captures;\n\t\t\ttarget.addEventListener(capture ? captures[type] : type, listener, capture);\n\t\t\t// create and return the signal\n\t\t\treturn {\n\t\t\t\tremove: function(){\n\t\t\t\t\ttarget.removeEventListener(type, listener, capture);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\ttype = \"on\" + type;\n\t\tif(fixAttach && target.attachEvent){\n\t\t\treturn fixAttach(target, type, listener);\n\t\t}\n\t \tthrow new Error(\"Target must be an event emitter\");\n\t}\n\n\ton.selector = function(selector, eventType, children){\n\t\t// summary:\n\t\t//\t\tCreates a new extension event with event delegation. This is based on\n\t\t// \t\tthe provided event type (can be extension event) that\n\t\t// \t\tonly calls the listener when the CSS selector matches the target of the event.\n\t\t//\tselector:\n\t\t//\t\tThe CSS selector to use for filter events and determine the |this| of the event listener.\n\t\t//\teventType:\n\t\t//\t\tThe event to listen for\n\t\t// children:\n\t\t//\t\tIndicates if children elements of the selector should be allowed. This defaults to \n\t\t// \t\ttrue (except in the case of normally non-bubbling events like mouse.enter, in which case it defaults to false).\n\t\t//\texample:\n\t\t//\t\tdefine([\"dojo/on\", \"dojo/mouse\"], function(listen, mouse){\n\t\t//\t\t\ton(node, on.selector(\".my-class\", mouse.enter), handlerForMyHover);\n\t\treturn function(target, listener){\n\t\t\tvar matchesTarget = this;\n\t\t\tvar bubble = eventType.bubble;\n\t\t\tif(bubble){\n\t\t\t\t// the event type doesn't naturally bubble, but has a bubbling form, use that\n\t\t\t\teventType = bubble;\n\t\t\t}else if(children !== false){\n\t\t\t\t// for normal bubbling events we default to allowing children of the selector\n\t\t\t\tchildren = true;\n\t\t\t}\n\t\t\treturn on(target, eventType, function(event){\n\t\t\t\tvar eventTarget = event.target;\n\t\t\t\t// see if we have a valid matchesTarget or default to dojo.query\n\t\t\t\tmatchesTarget = matchesTarget && matchesTarget.matches ? matchesTarget : dojo.query;\n\t\t\t\t// there is a selector, so make sure it matches\n\t\t\t\twhile(!matchesTarget.matches(eventTarget, selector, target)){\n\t\t\t\t\tif(eventTarget == target || !children || !(eventTarget = eventTarget.parentNode)){ // intentional assignment\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn listener.call(eventTarget, event);\n\t\t\t});\n\t\t};\n\t};\n\n\tfunction syntheticPreventDefault(){\n\t\tthis.cancelable = false;\n\t}\n\tfunction syntheticStopPropagation(){\n\t\tthis.bubbles = false;\n\t}\n\tvar slice = [].slice,\n\t\tsyntheticDispatch = on.emit = function(target, type, event){\n\t\t// summary:\n\t\t//\t\tFires an event on the target object.\n\t\t//\ttarget:\n\t\t//\t\tThe target object to fire the event on. This can be a DOM element or a plain \n\t\t// \t\tJS object. If the target is a DOM element, native event emiting mechanisms\n\t\t//\t\tare used when possible.\n\t\t//\ttype:\n\t\t//\t\tThe event type name. You can emulate standard native events like \"click\" and \n\t\t// \t\t\"mouseover\" or create custom events like \"open\" or \"finish\".\n\t\t//\tevent:\n\t\t//\t\tAn object that provides the properties for the event. See https://developer.mozilla.org/en/DOM/event.initEvent \n\t\t// \t\tfor some of the properties. These properties are copied to the event object.\n\t\t//\t\tOf particular importance are the cancelable and bubbles properties. The\n\t\t//\t\tcancelable property indicates whether or not the event has a default action\n\t\t// \t\tthat can be cancelled. The event is cancelled by calling preventDefault() on\n\t\t// \t\tthe event object. The bubbles property indicates whether or not the\n\t\t//\t\tevent will bubble up the DOM tree. If bubbles is true, the event will be called\n\t\t//\t\ton the target and then each parent successively until the top of the tree\n\t\t//\t\tis reached or stopPropagation() is called. Both bubbles and cancelable \n\t\t// \t\tdefault to false.\n\t\t//\treturns:\n\t\t//\t\tIf the event is cancelable and the event is not cancelled,\n\t\t// \t\temit will return true. If the event is cancelable and the event is cancelled,\n\t\t// \t\temit will return false.\n\t\t//\tdetails:\n\t\t//\t\tNote that this is designed to emit events for listeners registered through\n\t\t//\t\tdojo/on. It should actually work with any event listener except those\n\t\t// \t\tadded through IE's attachEvent (IE8 and below's non-W3C event emiting\n\t\t// \t\tdoesn't support custom event types). It should work with all events registered\n\t\t// \t\tthrough dojo/on. Also note that the emit method does do any default\n\t\t// \t\taction, it only returns a value to indicate if the default action should take\n\t\t// \t\tplace. For example, emiting a keypress event would not cause a character\n\t\t// \t\tto appear in a textbox.\n\t\t//\texample:\n\t\t//\t\tTo fire our own click event\n\t\t//\t|\ton.emit(dojo.byId(\"button\"), \"click\", {\n\t\t//\t|\t\tcancelable: true,\n\t\t//\t|\t\tbubbles: true,\n\t\t//\t|\t\tscreenX: 33,\n\t\t//\t|\t\tscreenY: 44\n\t\t//\t|\t});\n\t\t//\t\tWe can also fire our own custom events:\n\t\t//\t|\ton.emit(dojo.byId(\"slider\"), \"slide\", {\n\t\t//\t|\t\tcancelable: true,\n\t\t//\t|\t\tbubbles: true,\n\t\t//\t|\t\tdirection: \"left-to-right\"\n\t\t//\t|\t});\n\t\tvar args = slice.call(arguments, 2);\n\t\tvar method = \"on\" + type;\n\t\tif(\"parentNode\" in target){\n\t\t\t// node (or node-like), create event controller methods\n\t\t\tvar newEvent = args[0] = {};\n\t\t\tfor(var i in event){\n\t\t\t\tnewEvent[i] = event[i];\n\t\t\t}\n\t\t\tnewEvent.preventDefault = syntheticPreventDefault;\n\t\t\tnewEvent.stopPropagation = syntheticStopPropagation;\n\t\t\tnewEvent.target = target;\n\t\t\tnewEvent.type = type;\n\t\t\tevent = newEvent;\n\t\t}\n\t\tdo{\n\t\t\t// call any node which has a handler (note that ideally we would try/catch to simulate normal event propagation but that causes too much pain for debugging)\n\t\t\ttarget[method] && target[method].apply(target, args);\n\t\t\t// and then continue up the parent node chain if it is still bubbling (if started as bubbles and stopPropagation hasn't been called)\n\t\t}while(event && event.bubbles && (target = target.parentNode));\n\t\treturn event && event.cancelable && event; // if it is still true (was cancelable and was cancelled), return the event to indicate default action should happen\n\t};\n\tvar captures = {}; \n\tif(has(\"dom-addeventlistener\")){\n\t\t// normalize focusin and focusout\n\t\tcaptures = {\n\t\t\tfocusin: \"focus\",\n\t\t\tfocusout: \"blur\"\n\t\t};\n\t\tif(has(\"opera\")){\n\t\t\tcaptures.keydown = \"keypress\"; // this one needs to be transformed because Opera doesn't support repeating keys on keydown (and keypress works because it incorrectly fires on all keydown events)\n\t\t}\n\n\t\t// emiter that works with native event handling\n\t\ton.emit = function(target, type, event){\n\t\t\tif(target.dispatchEvent && document.createEvent){\n\t\t\t\t// use the native event emiting mechanism if it is available on the target object\n\t\t\t\t// create a generic event\t\t\t\t\n\t\t\t\t// we could create branch into the different types of event constructors, but \n\t\t\t\t// that would be a lot of extra code, with little benefit that I can see, seems \n\t\t\t\t// best to use the generic constructor and copy properties over, making it \n\t\t\t\t// easy to have events look like the ones created with specific initializers\n\t\t\t\tvar nativeEvent = document.createEvent(\"HTMLEvents\");\n\t\t\t\tnativeEvent.initEvent(type, !!event.bubbles, !!event.cancelable);\n\t\t\t\t// and copy all our properties over\n\t\t\t\tfor(var i in event){\n\t\t\t\t\tvar value = event[i];\n\t\t\t\t\tif(!(i in nativeEvent)){\n\t\t\t\t\t\tnativeEvent[i] = event[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn target.dispatchEvent(nativeEvent) && nativeEvent;\n\t\t\t}\n\t\t\treturn syntheticDispatch.apply(on, arguments); // emit for a non-node\n\t\t};\n\t}else{\n\t\t// no addEventListener, basically old IE event normalization\n\t\ton._fixEvent = function(evt, sender){\n\t\t\t// summary:\n\t\t\t//\t\tnormalizes properties on the event object including event\n\t\t\t//\t\tbubbling methods, keystroke normalization, and x/y positions\n\t\t\t// evt:\n\t\t\t//\t\tnative event object\n\t\t\t// sender:\n\t\t\t//\t\tnode to treat as \"currentTarget\"\n\t\t\tif(!evt){\n\t\t\t\tvar w = sender && (sender.ownerDocument || sender.document || sender).parentWindow || window;\n\t\t\t\tevt = w.event;\n\t\t\t}\n\t\t\tif(!evt){return(evt);}\n\t\t\tif(!evt.target){ // check to see if it has been fixed yet\n\t\t\t\tevt.target = evt.srcElement;\n\t\t\t\tevt.currentTarget = (sender || evt.srcElement);\n\t\t\t\tif(evt.type == \"mouseover\"){\n\t\t\t\t\tevt.relatedTarget = evt.fromElement;\n\t\t\t\t}\n\t\t\t\tif(evt.type == \"mouseout\"){\n\t\t\t\t\tevt.relatedTarget = evt.toElement;\n\t\t\t\t}\n\t\t\t\tif(!evt.stopPropagation){\n\t\t\t\t\tevt.stopPropagation = stopPropagation;\n\t\t\t\t\tevt.preventDefault = preventDefault;\n\t\t\t\t}\n\t\t\t\tswitch(evt.type){\n\t\t\t\t\tcase \"keypress\":\n\t\t\t\t\t\tvar c = (\"charCode\" in evt ? evt.charCode : evt.keyCode);\n\t\t\t\t\t\tif (c==10){\n\t\t\t\t\t\t\t// CTRL-ENTER is CTRL-ASCII(10) on IE, but CTRL-ENTER on Mozilla\n\t\t\t\t\t\t\tc=0;\n\t\t\t\t\t\t\tevt.keyCode = 13;\n\t\t\t\t\t\t}else if(c==13||c==27){\n\t\t\t\t\t\t\tc=0; // Mozilla considers ENTER and ESC non-printable\n\t\t\t\t\t\t}else if(c==3){\n\t\t\t\t\t\t\tc=99; // Mozilla maps CTRL-BREAK to CTRL-c\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Mozilla sets keyCode to 0 when there is a charCode\n\t\t\t\t\t\t// but that stops the event on IE.\n\t\t\t\t\t\tevt.charCode = c;\n\t\t\t\t\t\t_setKeyChar(evt);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn evt;\n\t\t};\n\t\tvar IESignal = function(handle){\n\t\t\tthis.handle = handle;\n\t\t};\n\t\tIESignal.prototype.remove = function(){\n\t\t\tdelete _dojoIEListeners_[this.handle];\n\t\t};\n\t\tvar fixListener = function(listener){\n\t\t\t// this is a minimal function for closing on the previous listener with as few as variables as possible\n\t\t\treturn function(evt){\n\t\t\t\tevt = on._fixEvent(evt, this);\n\t\t\t\treturn listener.call(this, evt);\n\t\t\t}\n\t\t}\n\t\tvar fixAttach = function(target, type, listener){\n\t\t\tlistener = fixListener(listener);\n\t\t\tif(((target.ownerDocument ? target.ownerDocument.parentWindow : target.parentWindow || target.window || window) != top || \n\t\t\t\t\t\thas(\"jscript\") < 5.8) && \n\t\t\t\t\t!has(\"config-_allow_leaks\")){\n\t\t\t\t// IE will leak memory on certain handlers in frames (IE8 and earlier) and in unattached DOM nodes for JScript 5.7 and below.\n\t\t\t\t// Here we use global redirection to solve the memory leaks\n\t\t\t\tif(typeof _dojoIEListeners_ == \"undefined\"){\n\t\t\t\t\t_dojoIEListeners_ = [];\n\t\t\t\t}\n\t\t\t\tvar emiter = target[type];\n\t\t\t\tif(!emiter || !emiter.listeners){\n\t\t\t\t\tvar oldListener = emiter;\n\t\t\t\t\ttarget[type] = emiter = Function('event', 'var callee = arguments.callee; for(var i = 0; i<callee.listeners.length; i++){var listener = _dojoIEListeners_[callee.listeners[i]]; if(listener){listener.call(this,event);}}');\n\t\t\t\t\temiter.listeners = [];\n\t\t\t\t\temiter.global = this;\n\t\t\t\t\tif(oldListener){\n\t\t\t\t\t\temiter.listeners.push(_dojoIEListeners_.push(oldListener) - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar handle;\n\t\t\t\temiter.listeners.push(handle = (emiter.global._dojoIEListeners_.push(listener) - 1));\n\t\t\t\treturn new IESignal(handle);\n\t\t\t}\n\t\t\treturn aspect.after(target, type, listener, true);\n\t\t};\n\n\t\tvar _setKeyChar = function(evt){\n\t\t\tevt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';\n\t\t\tevt.charOrCode = evt.keyChar || evt.keyCode;\n\t\t};\n\t\t// Called in Event scope\n\t\tvar stopPropagation = function(){\n\t\t\tthis.cancelBubble = true;\n\t\t};\n\t\tvar preventDefault = on._preventDefault = function(){\n\t\t\t// Setting keyCode to 0 is the only way to prevent certain keypresses (namely\n\t\t\t// ctrl-combinations that correspond to menu accelerator keys).\n\t\t\t// Otoh, it prevents upstream listeners from getting this information\n\t\t\t// Try to split the difference here by clobbering keyCode only for ctrl\n\t\t\t// combinations. If you still need to access the key upstream, bubbledKeyCode is\n\t\t\t// provided as a workaround.\n\t\t\tthis.bubbledKeyCode = this.keyCode;\n\t\t\tif(this.ctrlKey){\n\t\t\t\ttry{\n\t\t\t\t\t// squelch errors when keyCode is read-only\n\t\t\t\t\t// (e.g. if keyCode is ctrl or shift)\n\t\t\t\t\tthis.keyCode = 0;\n\t\t\t\t}catch(e){\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.returnValue = false;\n\t\t};\n\t}\n\tif(has(\"touch\")){ \n\t\tvar Event = function (){};\n\t\tvar windowOrientation = window.orientation; \n\t\tvar fixTouchListener = function(listener){ \n\t\t\treturn function(originalEvent){ \n\t\t\t\t//Event normalization(for ontouchxxx and resize): \n\t\t\t\t//1.incorrect e.pageX|pageY in iOS \n\t\t\t\t//2.there are no \"e.rotation\", \"e.scale\" and \"onorientationchange\" in Andriod\n\t\t\t\t//3.More TBD e.g. force | screenX | screenX | clientX | clientY | radiusX | radiusY\n\n\t\t\t\t// see if it has already been corrected\n\t\t\t\tvar event = originalEvent.corrected;\n\t\t\t\tif(!event){\n\t\t\t\t\tvar type = originalEvent.type;\n\t\t\t\t\ttry{\n\t\t\t\t\t\tdelete originalEvent.type; // on some JS engines (android), deleting properties make them mutable\n\t\t\t\t\t}catch(e){} \n\t\t\t\t\tif(originalEvent.type){\n\t\t\t\t\t\t// deleting properties doesn't work (older iOS), have to use delegation\n\t\t\t\t\t\tEvent.prototype = originalEvent;\n\t\t\t\t\t\tvar event = new Event;\n\t\t\t\t\t\t// have to delegate methods to make them work\n\t\t\t\t\t\tevent.preventDefault = function(){\n\t\t\t\t\t\t\toriginalEvent.preventDefault();\n\t\t\t\t\t\t};\n\t\t\t\t\t\tevent.stopPropagation = function(){\n\t\t\t\t\t\t\toriginalEvent.stopPropagation();\n\t\t\t\t\t\t};\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// deletion worked, use property as is\n\t\t\t\t\t\tevent = originalEvent;\n\t\t\t\t\t\tevent.type = type;\n\t\t\t\t\t}\n\t\t\t\t\toriginalEvent.corrected = event;\n\t\t\t\t\tif(type == 'resize'){\n\t\t\t\t\t\tif(windowOrientation == window.orientation){ \n\t\t\t\t\t\t\treturn null;//double tap causes an unexpected 'resize' in Andriod \n\t\t\t\t\t\t} \n\t\t\t\t\t\twindowOrientation = window.orientation;\n\t\t\t\t\t\tevent.type = \"orientationchange\"; \n\t\t\t\t\t\treturn listener.call(this, event);\n\t\t\t\t\t}\n\t\t\t\t\t// We use the original event and augment, rather than doing an expensive mixin operation\n\t\t\t\t\tif(!(\"rotation\" in event)){ // test to see if it has rotation\n\t\t\t\t\t\tevent.rotation = 0; \n\t\t\t\t\t\tevent.scale = 1;\n\t\t\t\t\t}\n\t\t\t\t\t//use event.changedTouches[0].pageX|pageY|screenX|screenY|clientX|clientY|target\n\t\t\t\t\tvar firstChangeTouch = event.changedTouches[0];\n\t\t\t\t\tfor(var i in firstChangeTouch){ // use for-in, we don't need to have dependency on dojo/_base/lang here\n\t\t\t\t\t\tdelete event[i]; // delete it first to make it mutable\n\t\t\t\t\t\tevent[i] = firstChangeTouch[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn listener.call(this, event); \n\t\t\t}; \n\t\t}; \n\t}\n\treturn on;\n});\n\n},\n'dojo/_base/sniff':function(){\ndefine([\"./kernel\", \"../has\"], function(dojo, has){\n\t// module:\n\t//\t\tdojo/sniff\n\t// summary:\n\t//\t\tThis module populates the dojo browser version sniffing properties.\n\n\tif(!1){\n\t\treturn has;\n\t}\n\n\tdojo.isBrowser = true,\n\tdojo._name = \"browser\";\n\n\tvar hasAdd = has.add,\n\t\tn = navigator,\n\t\tdua = n.userAgent,\n\t\tdav = n.appVersion,\n\t\ttv = parseFloat(dav),\n\t\tisOpera,\n\t\tisAIR,\n\t\tisKhtml,\n\t\tisWebKit,\n\t\tisChrome,\n\t\tisMac,\n\t\tisSafari,\n\t\tisMozilla ,\n\t\tisMoz,\n\t\tisIE,\n\t\tisFF,\n\t\tisQuirks,\n\t\tisIos,\n\t\tisAndroid,\n\t\tisWii;\n\n\t/*=====\n\tdojo.isBrowser = {\n\t\t//\texample:\n\t\t//\t| if(dojo.isBrowser){ ... }\n\t};\n\n\tdojo.isFF = {\n\t\t//\texample:\n\t\t//\t| if(dojo.isFF > 1){ ... }\n\t};\n\n\tdojo.isIE = {\n\t\t// example:\n\t\t//\t| if(dojo.isIE > 6){\n\t\t//\t|\t\t// we are IE7\n\t\t//\t| }\n\t};\n\n\tdojo.isSafari = {\n\t\t//\texample:\n\t\t//\t| if(dojo.isSafari){ ... }\n\t\t//\texample:\n\t\t//\t\tDetect iPhone:\n\t\t//\t| if(dojo.isSafari && navigator.userAgent.indexOf(\"iPhone\") != -1){\n\t\t//\t|\t\t// we are iPhone. Note, iPod touch reports \"iPod\" above and fails this test.\n\t\t//\t| }\n\t};\n\n\tdojo.mixin(dojo, {\n\t\t// isBrowser: Boolean\n\t\t//\t\tTrue if the client is a web-browser\n\t\tisBrowser: true,\n\t\t//\tisFF: Number | undefined\n\t\t//\t\tVersion as a Number if client is FireFox. undefined otherwise. Corresponds to\n\t\t//\t\tmajor detected FireFox version (1.5, 2, 3, etc.)\n\t\tisFF: 2,\n\t\t//\tisIE: Number | undefined\n\t\t//\t\tVersion as a Number if client is MSIE(PC). undefined otherwise. Corresponds to\n\t\t//\t\tmajor detected IE version (6, 7, 8, etc.)\n\t\tisIE: 6,\n\t\t//\tisKhtml: Number | undefined\n\t\t//\t\tVersion as a Number if client is a KHTML browser. undefined otherwise. Corresponds to major\n\t\t//\t\tdetected version.\n\t\tisKhtml: 0,\n\t\t//\tisWebKit: Number | undefined\n\t\t//\t\tVersion as a Number if client is a WebKit-derived browser (Konqueror,\n\t\t//\t\tSafari, Chrome, etc.). undefined otherwise.\n\t\tisWebKit: 0,\n\t\t//\tisMozilla: Number | undefined\n\t\t//\t\tVersion as a Number if client is a Mozilla-based browser (Firefox,\n\t\t//\t\tSeaMonkey). undefined otherwise. Corresponds to major detected version.\n\t\tisMozilla: 0,\n\t\t//\tisOpera: Number | undefined\n\t\t//\t\tVersion as a Number if client is Opera. undefined otherwise. Corresponds to\n\t\t//\t\tmajor detected version.\n\t\tisOpera: 0,\n\t\t//\tisSafari: Number | undefined\n\t\t//\t\tVersion as a Number if client is Safari or iPhone. undefined otherwise.\n\t\tisSafari: 0,\n\t\t//\tisChrome: Number | undefined\n\t\t//\t\tVersion as a Number if client is Chrome browser. undefined otherwise.\n\t\tisChrome: 0,\n\t\t//\tisMac: Boolean\n\t\t//\t\tTrue if the client runs on Mac\n\t\tisMac: 0,\n\t\t// isIos: Boolean\n\t\t//\t\tTrue if client is iPhone, iPod, or iPad\n\t\tisIos: 0,\n\t\t// isAndroid: Number | undefined\n\t\t//\t\tVersion as a Number if client is android browser. undefined otherwise.\n\t\tisAndroid: 0,\n\t\t// isWii: Boolean\n\t\t//\t\tTrue if client is Wii\n\t\tisWii: 0\n\t});\n\t=====*/\n\n\t// fill in the rendering support information in dojo.render.*\n\tif(dua.indexOf(\"AdobeAIR\") >= 0){ isAIR = 1; }\n\tisKhtml = (dav.indexOf(\"Konqueror\") >= 0) ? tv : 0;\n\tisWebKit = parseFloat(dua.split(\"WebKit/\")[1]) || undefined;\n\tisChrome = parseFloat(dua.split(\"Chrome/\")[1]) || undefined;\n\tisMac = dav.indexOf(\"Macintosh\") >= 0;\n\tisIos = /iPhone|iPod|iPad/.test(dua);\n\tisAndroid = parseFloat(dua.split(\"Android \")[1]) || undefined;\n\tisWii = typeof opera != \"undefined\" && opera.wiiremote;\n\n\t// safari detection derived from:\n\t//\t\thttp://developer.apple.com/internet/safari/faq.html#anchor2\n\t//\t\thttp://developer.apple.com/internet/safari/uamatrix.html\n\tvar index = Math.max(dav.indexOf(\"WebKit\"), dav.indexOf(\"Safari\"), 0);\n\tif(index && !isChrome){\n\t\t// try to grab the explicit Safari version first. If we don't get\n\t\t// one, look for less than 419.3 as the indication that we're on something\n\t\t// \"Safari 2-ish\".\n\t\tisSafari = parseFloat(dav.split(\"Version/\")[1]);\n\t\tif(!isSafari || parseFloat(dav.substr(index + 7)) <= 419.3){\n\t\t\tisSafari = 2;\n\t\t}\n\t}\n\n\tif (!has(\"dojo-webkit\")) {\n\t\tif(dua.indexOf(\"Opera\") >= 0){\n\t\t\tisOpera = tv;\n\t\t\t// see http://dev.opera.com/articles/view/opera-ua-string-changes and http://www.useragentstring.com/pages/Opera/\n\t\t\t// 9.8 has both styles; <9.8, 9.9 only old style\n\t\t\tif(isOpera >= 9.8){\n\t\t\t\tisOpera = parseFloat(dua.split(\"Version/\")[1]) || tv;\n\t\t\t}\n\t\t}\n\n\t\tif(dua.indexOf(\"Gecko\") >= 0 && !isKhtml && !isWebKit){\n\t\t\tisMozilla = isMoz = tv;\n\t\t}\n\t\tif(isMoz){\n\t\t\t//We really need to get away from this. Consider a sane isGecko approach for the future.\n\t\t\tisFF = parseFloat(dua.split(\"Firefox/\")[1] || dua.split(\"Minefield/\")[1]) || undefined;\n\t\t}\n\t\tif(document.all && !isOpera){\n\t\t\tisIE = parseFloat(dav.split(\"MSIE \")[1]) || undefined;\n\t\t\t//In cases where the page has an HTTP header or META tag with\n\t\t\t//X-UA-Compatible, then it is in emulation mode.\n\t\t\t//Make sure isIE reflects the desired version.\n\t\t\t//document.documentMode of 5 means quirks mode.\n\t\t\t//Only switch the value if documentMode's major version\n\t\t\t//is different from isIE's major version.\n\t\t\tvar mode = document.documentMode;\n\t\t\tif(mode && mode != 5 && Math.floor(isIE) != mode){\n\t\t\t\tisIE = mode;\n\t\t\t}\n\t\t}\n\t}\n\n\tisQuirks = document.compatMode == \"BackCompat\";\n\n\thasAdd(\"opera\", dojo.isOpera = isOpera);\n\thasAdd(\"air\", dojo.isAIR = isAIR);\n\thasAdd(\"khtml\", dojo.isKhtml = isKhtml);\n\thasAdd(\"webkit\", dojo.isWebKit = isWebKit);\n\thasAdd(\"chrome\", dojo.isChrome = isChrome);\n\thasAdd(\"mac\", dojo.isMac = isMac );\n\thasAdd(\"safari\", dojo.isSafari = isSafari);\n\thasAdd(\"mozilla\", dojo.isMozilla = dojo.isMoz = isMozilla );\n\thasAdd(\"ie\", dojo.isIE = isIE );\n\thasAdd(\"ff\", dojo.isFF = isFF);\n\thasAdd(\"quirks\", dojo.isQuirks = isQuirks);\n\thasAdd(\"ios\", dojo.isIos = isIos);\n\thasAdd(\"android\", dojo.isAndroid = isAndroid);\n\n\tdojo.locale = dojo.locale || (isIE ? n.userLanguage : n.language).toLowerCase();\n\n\treturn has;\n});\n\n},\n'dojo/_base/array':function(){\ndefine(\"dojo/_base/array\", [\"./kernel\", \"../has\", \"./lang\"], function(dojo, has, lang){\n\t// module:\n\t//\t\tdojo/_base/array\n\t// summary:\n\t//\t\tThis module defines the Javascript v1.6 array extensions.\n\n\t/*=====\n\tdojo.indexOf = function(arr, value, fromIndex, findLast){\n\t\t// summary:\n\t\t//\t\tlocates the first index of the provided value in the\n\t\t//\t\tpassed array. If the value is not found, -1 is returned.\n\t\t// description:\n\t\t//\t\tThis method corresponds to the JavaScript 1.6 Array.indexOf method, with one difference: when\n\t\t//\t\trun over sparse arrays, the Dojo function invokes the callback for every index whereas JavaScript\n\t\t//\t\t1.6's indexOf skips the holes in the sparse array.\n\t\t//\t\tFor details on this method, see:\n\t\t//\t\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf\n\t\t// arr: Array\n\t\t// value: Object\n\t\t// fromIndex: Integer?\n\t\t// findLast: Boolean?\n\t\t// returns: Number\n\t};\n\tdojo.lastIndexOf = function(arr, value, fromIndex){\n\t\t// summary:\n\t\t//\t\tlocates the last index of the provided value in the passed\n\t\t//\t\tarray. If the value is not found, -1 is returned.\n\t\t// description:\n\t\t//\t\tThis method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with one difference: when\n\t\t//\t\trun over sparse arrays, the Dojo function invokes the callback for every index whereas JavaScript\n\t\t//\t\t1.6's lastIndexOf skips the holes in the sparse array.\n\t\t//\t\tFor details on this method, see:\n\t\t//\t\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf\n\t\t//\tarr: Array,\n\t\t//\tvalue: Object,\n\t\t//\tfromIndex: Integer?\n\t\t//\treturns: Number\n\t};\n\tdojo.forEach = function(arr, callback, thisObject){\n\t\t//\tsummary:\n\t\t//\t\tfor every item in arr, callback is invoked. Return values are ignored.\n\t\t//\t\tIf you want to break out of the loop, consider using dojo.every() or dojo.some().\n\t\t//\t\tforEach does not allow breaking out of the loop over the items in arr.\n\t\t//\tarr:\n\t\t//\t\tthe array to iterate over. If a string, operates on individual characters.\n\t\t//\tcallback:\n\t\t//\t\ta function is invoked with three arguments: item, index, and array\n\t\t//\tthisObject:\n\t\t//\t\tmay be used to scope the call to callback\n\t\t//\tdescription:\n\t\t//\t\tThis function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when\n\t\t//\t\trun over sparse arrays, this implementation passes the \"holes\" in the sparse array to\n\t\t//\t\tthe callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.\n\t\t//\t\tFor more details, see:\n\t\t//\t\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach\n\t\t//\texample:\n\t\t//\t| // log out all members of the array:\n\t\t//\t| dojo.forEach(\n\t\t//\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\n\t\t//\t|\t\tfunction(item){\n\t\t//\t|\t\t\tconsole.log(item);\n\t\t//\t|\t\t}\n\t\t//\t| );\n\t\t//\texample:\n\t\t//\t| // log out the members and their indexes\n\t\t//\t| dojo.forEach(\n\t\t//\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\n\t\t//\t|\t\tfunction(item, idx, arr){\n\t\t//\t|\t\t\tconsole.log(item, \"at index:\", idx);\n\t\t//\t|\t\t}\n\t\t//\t| );\n\t\t//\texample:\n\t\t//\t| // use a scoped object member as the callback\n\t\t//\t|\n\t\t//\t| var obj = {\n\t\t//\t|\t\tprefix: \"logged via obj.callback:\",\n\t\t//\t|\t\tcallback: function(item){\n\t\t//\t|\t\t\tconsole.log(this.prefix, item);\n\t\t//\t|\t\t}\n\t\t//\t| };\n\t\t//\t|\n\t\t//\t| // specifying the scope function executes the callback in that scope\n\t\t//\t| dojo.forEach(\n\t\t//\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\n\t\t//\t|\t\tobj.callback,\n\t\t//\t|\t\tobj\n\t\t//\t| );\n\t\t//\t|\n\t\t//\t| // alternately, we can accomplish the same thing with dojo.hitch()\n\t\t//\t| dojo.forEach(\n\t\t//\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\n\t\t//\t|\t\tdojo.hitch(obj, \"callback\")\n\t\t//\t| );\n\t\t//\tarr: Array|String\n\t\t//\tcallback: Function|String\n\t\t//\tthisObject: Object?\n\t};\n\tdojo.every = function(arr, callback, thisObject){\n\t\t// summary:\n\t\t//\t\tDetermines whether or not every item in arr satisfies the\n\t\t//\t\tcondition implemented by callback.\n\t\t// arr: Array|String\n\t\t//\t\tthe array to iterate on. If a string, operates on individual characters.\n\t\t// callback: Function|String\n\t\t//\t\ta function is invoked with three arguments: item, index,\n\t\t//\t\tand array and returns true if the condition is met.\n\t\t// thisObject: Object?\n\t\t//\t\tmay be used to scope the call to callback\n\t\t// returns: Boolean\n\t\t// description:\n\t\t//\t\tThis function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when\n\t\t//\t\trun over sparse arrays, this implementation passes the \"holes\" in the sparse array to\n\t\t//\t\tthe callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.\n\t\t//\t\tFor more details, see:\n\t\t//\t\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every\n\t\t// example:\n\t\t//\t| // returns false\n\t\t//\t| dojo.every([1, 2, 3, 4], function(item){ return item>1; });\n\t\t// example:\n\t\t//\t| // returns true\n\t\t//\t| dojo.every([1, 2, 3, 4], function(item){ return item>0; });\n\t};\n\tdojo.some = function(arr, callback, thisObject){\n\t\t// summary:\n\t\t//\t\tDetermines whether or not any item in arr satisfies the\n\t\t//\t\tcondition implemented by callback.\n\t\t// arr: Array|String\n\t\t//\t\tthe array to iterate over. If a string, operates on individual characters.\n\t\t// callback: Function|String\n\t\t//\t\ta function is invoked with three arguments: item, index,\n\t\t//\t\tand array and returns true if the condition is met.\n\t\t// thisObject: Object?\n\t\t//\t\tmay be used to scope the call to callback\n\t\t// returns: Boolean\n\t\t// description:\n\t\t//\t\tThis function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when\n\t\t//\t\trun over sparse arrays, this implementation passes the \"holes\" in the sparse array to\n\t\t//\t\tthe callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.\n\t\t//\t\tFor more details, see:\n\t\t//\t\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some\n\t\t// example:\n\t\t//\t| // is true\n\t\t//\t| dojo.some([1, 2, 3, 4], function(item){ return item>1; });\n\t\t// example:\n\t\t//\t| // is false\n\t\t//\t| dojo.some([1, 2, 3, 4], function(item){ return item<1; });\n\t};\n\tdojo.map = function(arr, callback, thisObject){\n\t\t// summary:\n\t\t//\t\tapplies callback to each element of arr and returns\n\t\t//\t\tan Array with the results\n\t\t// arr: Array|String\n\t\t//\t\tthe array to iterate on. If a string, operates on\n\t\t//\t\tindividual characters.\n\t\t// callback: Function|String\n\t\t//\t\ta function is invoked with three arguments, (item, index,\n\t\t//\t\tarray),\t and returns a value\n\t\t// thisObject: Object?\n\t\t//\t\tmay be used to scope the call to callback\n\t\t// returns: Array\n\t\t// description:\n\t\t//\t\tThis function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when\n\t\t//\t\trun over sparse arrays, this implementation passes the \"holes\" in the sparse array to\n\t\t//\t\tthe callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.\n\t\t//\t\tFor more details, see:\n\t\t//\t\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map\n\t\t// example:\n\t\t//\t| // returns [2, 3, 4, 5]\n\t\t//\t| dojo.map([1, 2, 3, 4], function(item){ return item+1 });\n\t};\n\tdojo.filter = function(arr, callback, thisObject){\n\t\t// summary:\n\t\t//\t\tReturns a new Array with those items from arr that match the\n\t\t//\t\tcondition implemented by callback.\n\t\t// arr: Array\n\t\t//\t\tthe array to iterate over.\n\t\t// callback: Function|String\n\t\t//\t\ta function that is invoked with three arguments (item,\n\t\t//\t\tindex, array). The return of this function is expected to\n\t\t//\t\tbe a boolean which determines whether the passed-in item\n\t\t//\t\twill be included in the returned array.\n\t\t// thisObject: Object?\n\t\t//\t\tmay be used to scope the call to callback\n\t\t// returns: Array\n\t\t// description:\n\t\t//\t\tThis function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when\n\t\t//\t\trun over sparse arrays, this implementation passes the \"holes\" in the sparse array to\n\t\t//\t\tthe callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.\n\t\t//\t\tFor more details, see:\n\t\t//\t\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter\n\t\t// example:\n\t\t//\t| // returns [2, 3, 4]\n\t\t//\t| dojo.filter([1, 2, 3, 4], function(item){ return item>1; });\n\t};\n\t=====*/\n\n\t// our old simple function builder stuff\n\tvar cache = {}, u, array; // the export object\n\n\tfunction clearCache(){\n\t\tcache = {};\n\t}\n\n\tfunction buildFn(fn){\n\t\treturn cache[fn] = new Function(\"item\", \"index\", \"array\", fn); // Function\n\t}\n\t// magic snippet: if(typeof fn == \"string\") fn = cache[fn] || buildFn(fn);\n\n\t// every & some\n\n\tfunction everyOrSome(some){\n\t\tvar every = !some;\n\t\treturn function(a, fn, o){\n\t\t\tvar i = 0, l = a && a.length || 0, result;\n\t\t\tif(l && typeof a == \"string\") a = a.split(\"\");\n\t\t\tif(typeof fn == \"string\") fn = cache[fn] || buildFn(fn);\n\t\t\tif(o){\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tresult = !fn.call(o, a[i], i, a);\n\t\t\t\t\tif(some ^ result){\n\t\t\t\t\t\treturn !result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tresult = !fn(a[i], i, a);\n\t\t\t\t\tif(some ^ result){\n\t\t\t\t\t\treturn !result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn every; // Boolean\n\t\t}\n\t}\n\t// var every = everyOrSome(false), some = everyOrSome(true);\n\n\t// indexOf, lastIndexOf\n\n\tfunction index(up){\n\t\tvar delta = 1, lOver = 0, uOver = 0;\n\t\tif(!up){\n\t\t\tdelta = lOver = uOver = -1;\n\t\t}\n\t\treturn function(a, x, from, last){\n\t\t\tif(last && delta > 0){\n\t\t\t\t// TODO: why do we use a non-standard signature? why do we need \"last\"?\n\t\t\t\treturn array.lastIndexOf(a, x, from);\n\t\t\t}\n\t\t\tvar l = a && a.length || 0, end = up ? l + uOver : lOver, i;\n\t\t\tif(from === u){\n\t\t\t\ti = up ? lOver : l + uOver;\n\t\t\t}else{\n\t\t\t\tif(from < 0){\n\t\t\t\t\ti = l + from;\n\t\t\t\t\tif(i < 0){\n\t\t\t\t\t\ti = lOver;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\ti = from >= l ? l + uOver : from;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(l && typeof a == \"string\") a = a.split(\"\");\n\t\t\tfor(; i != end; i += delta){\n\t\t\t\tif(a[i] == x){\n\t\t\t\t\treturn i; // Number\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1; // Number\n\t\t}\n\t}\n\t// var indexOf = index(true), lastIndexOf = index(false);\n\n\tfunction forEach(a, fn, o){\n\t\tvar i = 0, l = a && a.length || 0;\n\t\tif(l && typeof a == \"string\") a = a.split(\"\");\n\t\tif(typeof fn == \"string\") fn = cache[fn] || buildFn(fn);\n\t\tif(o){\n\t\t\tfor(; i < l; ++i){\n\t\t\t\tfn.call(o, a[i], i, a);\n\t\t\t}\n\t\t}else{\n\t\t\tfor(; i < l; ++i){\n\t\t\t\tfn(a[i], i, a);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction map(a, fn, o, Ctr){\n\t\t// TODO: why do we have a non-standard signature here? do we need \"Ctr\"?\n\t\tvar i = 0, l = a && a.length || 0, out = new (Ctr || Array)(l);\n\t\tif(l && typeof a == \"string\") a = a.split(\"\");\n\t\tif(typeof fn == \"string\") fn = cache[fn] || buildFn(fn);\n\t\tif(o){\n\t\t\tfor(; i < l; ++i){\n\t\t\t\tout[i] = fn.call(o, a[i], i, a);\n\t\t\t}\n\t\t}else{\n\t\t\tfor(; i < l; ++i){\n\t\t\t\tout[i] = fn(a[i], i, a);\n\t\t\t}\n\t\t}\n\t\treturn out; // Array\n\t}\n\n\tfunction filter(a, fn, o){\n\t\t// TODO: do we need \"Ctr\" here like in map()?\n\t\tvar i = 0, l = a && a.length || 0, out = [], value;\n\t\tif(l && typeof a == \"string\") a = a.split(\"\");\n\t\tif(typeof fn == \"string\") fn = cache[fn] || buildFn(fn);\n\t\tif(o){\n\t\t\tfor(; i < l; ++i){\n\t\t\t\tvalue = a[i];\n\t\t\t\tif(fn.call(o, value, i, a)){\n\t\t\t\t\tout.push(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(; i < l; ++i){\n\t\t\t\tvalue = a[i];\n\t\t\t\tif(fn(value, i, a)){\n\t\t\t\t\tout.push(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn out; // Array\n\t}\n\n\tarray = {\n\t\tevery:       everyOrSome(false),\n\t\tsome:        everyOrSome(true),\n\t\tindexOf:     index(true),\n\t\tlastIndexOf: index(false),\n\t\tforEach:     forEach,\n\t\tmap:         map,\n\t\tfilter:      filter,\n\t\tclearCache:  clearCache\n\t};\n\n\t1 && lang.mixin(dojo, array);\n\n\t/*===== return dojo.array; =====*/\n\treturn array;\n});\n\n},\n'dojo/_base/json':function(){\ndefine([\"./kernel\", \"../json\"], function(dojo, json){\n  // module:\n  //    dojo/_base/json\n  // summary:\n  //    This module defines the dojo JSON API.\n\ndojo.fromJson = function(/*String*/ js){\n\t// summary:\n\t//\t\tParses a JavaScript expression and returns a JavaScript value.\n\t// description:\n\t//\t\tThrows for invalid JavaScript expressions. It does not use a strict JSON parser. It\n\t//\t\talways delegates to eval(). The content passed to this method must therefore come\n\t//\t\tfrom a trusted source.\n\t//\t\tIt is recommend that you use dojo/json's parse function for an\n\t//\t\timplementation uses the (faster) native JSON parse when available.\n\t// js:\n\t//\t\ta string literal of a JavaScript expression, for instance:\n\t//\t\t\t`'{ \"foo\": [ \"bar\", 1, { \"baz\": \"thud\" } ] }'`\n\n\treturn eval(\"(\" + js + \")\"); // Object\n};\n\n/*=====\ndojo._escapeString = function(){\n\t// summary:\n\t//\t\tAdds escape sequences for non-visual characters, double quote and\n\t//\t\tbackslash and surrounds with double quotes to form a valid string\n\t//\t\tliteral.\n};\n=====*/\ndojo._escapeString = json.stringify; // just delegate to json.stringify\n\ndojo.toJsonIndentStr = \"\\t\";\ndojo.toJson = function(/*Object*/ it, /*Boolean?*/ prettyPrint){\n\t// summary:\n\t//\t\tReturns a [JSON](http://json.org) serialization of an object.\n\t// description:\n\t//\t\tReturns a [JSON](http://json.org) serialization of an object.\n\t//\t\tNote that this doesn't check for infinite recursion, so don't do that!\n\t//\t\tIt is recommend that you use dojo/json's stringify function for an lighter\n\t//\t\tand faster implementation that matches the native JSON API and uses the\n\t//\t\tnative JSON serializer when available.\n\t// it:\n\t//\t\tan object to be serialized. Objects may define their own\n\t//\t\tserialization via a special \"__json__\" or \"json\" function\n\t//\t\tproperty. If a specialized serializer has been defined, it will\n\t//\t\tbe used as a fallback.\n\t//\t\tNote that in 1.6, toJson would serialize undefined, but this no longer supported\n\t//\t\tsince it is not supported by native JSON serializer.\n\t// prettyPrint:\n\t//\t\tif true, we indent objects and arrays to make the output prettier.\n\t//\t\tThe variable `dojo.toJsonIndentStr` is used as the indent string --\n\t//\t\tto use something other than the default (tab), change that variable\n\t//\t\tbefore calling dojo.toJson().\n\t//\t\tNote that if native JSON support is available, it will be used for serialization,\n\t//\t\tand native implementations vary on the exact spacing used in pretty printing.\n\t// returns:\n\t// \t\tA JSON string serialization of the passed-in object.\n\t// example:\n\t//\t\tsimple serialization of a trivial object\n\t//\t\t|\tvar jsonStr = dojo.toJson({ howdy: \"stranger!\", isStrange: true });\n\t//\t\t|\tdoh.is('{\"howdy\":\"stranger!\",\"isStrange\":true}', jsonStr);\n\t// example:\n\t//\t\ta custom serializer for an objects of a particular class:\n\t//\t\t|\tdojo.declare(\"Furby\", null, {\n\t//\t\t|\t\tfurbies: \"are strange\",\n\t//\t\t|\t\tfurbyCount: 10,\n\t//\t\t|\t\t__json__: function(){\n\t//\t\t|\t\t},\n\t//\t\t|\t});\n\n\t// use dojo/json\n\treturn json.stringify(it, function(key, value){\n\t\tif(value){\n\t\t\tvar tf = value.__json__||value.json;\n\t\t\tif(typeof tf == \"function\"){\n\t\t\t\treturn tf.call(value);\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}, prettyPrint && dojo.toJsonIndentStr);\t// String\n};\n\nreturn dojo;\n});\n\n},\n'dojo/dom-class':function(){\ndefine([\"./_base/lang\", \"./_base/array\", \"./dom\"], function(lang, array, dom){\n\t// module:\n\t//\t\tdojo/dom-class\n\t// summary:\n\t//\t\tThis module defines the core dojo DOM class API.\n\n\tvar className = \"className\";\n\n\t/* Part I of classList-based implementation is preserved here for posterity\n\tvar classList = \"classList\";\n\thas.add(\"dom-classList\", function(){\n\t\treturn classList in document.createElement(\"p\");\n\t});\n\t*/\n\n\t// =============================\n\t// (CSS) Class Functions\n\t// =============================\n\n\t/*=====\n\tdojo.hasClass = function(node, classStr){\n\t\t// summary:\n\t\t//\t\tReturns whether or not the specified classes are a portion of the\n\t\t//\t\tclass list currently applied to the node.\n\t\t//\n\t\t// node: String|DOMNode\n\t\t//\t\tString ID or DomNode reference to check the class for.\n\t\t//\n\t\t// classStr: String\n\t\t//\t\tA string class name to look for.\n\t\t//\n\t\t// returns: Boolean\n\t\t//\n\t\t// example:\n\t\t//\t\tDo something if a node with id=\"someNode\" has class=\"aSillyClassName\" present\n\t\t//\t|\tif(dojo.hasClass(\"someNode\",\"aSillyClassName\")){ ... }\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.addClass = function(node, classStr){\n\t\t// summary:\n\t\t//\t\tAdds the specified classes to the end of the class list on the\n\t\t//\t\tpassed node. Will not re-apply duplicate classes.\n\t\t//\n\t\t// node: String|DOMNode\n\t\t//\t\tString ID or DomNode reference to add a class string too\n\t\t//\n\t\t// classStr: String|Array\n\t\t//\t\tA String class name to add, or several space-separated class names,\n\t\t//\t\tor an array of class names.\n\t\t//\n\t\t// example:\n\t\t//\t\tAdd a class to some node:\n\t\t//\t|\tdojo.addClass(\"someNode\", \"anewClass\");\n\t\t//\n\t\t// example:\n\t\t//\t\tAdd two classes at once:\n\t\t//\t|\tdojo.addClass(\"someNode\", \"firstClass secondClass\");\n\t\t//\n\t\t// example:\n\t\t//\t\tAdd two classes at once (using array):\n\t\t//\t|\tdojo.addClass(\"someNode\", [\"firstClass\", \"secondClass\"]);\n\t\t//\n\t\t// example:\n\t\t//\t\tAvailable in `dojo.NodeList` for multiple additions\n\t\t//\t|\tdojo.query(\"ul > li\").addClass(\"firstLevel\");\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.removeClass = function(node, classStr){\n\t\t// summary:\n\t\t//\t\tRemoves the specified classes from node. No `dojo.hasClass`\n\t\t//\t\tcheck is required.\n\t\t//\n\t\t// node: String|DOMNode\n\t\t//\t\tString ID or DomNode reference to remove the class from.\n\t\t//\n\t\t// classStr: String|Array\n\t\t//\t\tAn optional String class name to remove, or several space-separated\n\t\t//\t\tclass names, or an array of class names. If omitted, all class names\n\t\t//\t\twill be deleted.\n\t\t//\n\t\t// example:\n\t\t//\t\tRemove a class from some node:\n\t\t//\t|\tdojo.removeClass(\"someNode\", \"firstClass\");\n\t\t//\n\t\t// example:\n\t\t//\t\tRemove two classes from some node:\n\t\t//\t|\tdojo.removeClass(\"someNode\", \"firstClass secondClass\");\n\t\t//\n\t\t// example:\n\t\t//\t\tRemove two classes from some node (using array):\n\t\t//\t|\tdojo.removeClass(\"someNode\", [\"firstClass\", \"secondClass\"]);\n\t\t//\n\t\t// example:\n\t\t//\t\tRemove all classes from some node:\n\t\t//\t|\tdojo.removeClass(\"someNode\");\n\t\t//\n\t\t// example:\n\t\t//\t\tAvailable in `dojo.NodeList()` for multiple removal\n\t\t//\t|\tdojo.query(\".foo\").removeClass(\"foo\");\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.replaceClass = function(node, addClassStr, removeClassStr){\n\t\t// summary:\n\t\t//\t\tReplaces one or more classes on a node if not present.\n\t\t//\t\tOperates more quickly than calling dojo.removeClass and dojo.addClass\n\t\t//\n\t\t// node: String|DOMNode\n\t\t//\t\tString ID or DomNode reference to remove the class from.\n\t\t//\n\t\t// addClassStr: String|Array\n\t\t//\t\tA String class name to add, or several space-separated class names,\n\t\t//\t\tor an array of class names.\n\t\t//\n\t\t// removeClassStr: String|Array?\n\t\t//\t\tA String class name to remove, or several space-separated class names,\n\t\t//\t\tor an array of class names.\n\t\t//\n\t\t// example:\n\t\t//\t|\tdojo.replaceClass(\"someNode\", \"add1 add2\", \"remove1 remove2\");\n\t\t//\n\t\t// example:\n\t\t//\tReplace all classes with addMe\n\t\t//\t|\tdojo.replaceClass(\"someNode\", \"addMe\");\n\t\t//\n\t\t// example:\n\t\t//\tAvailable in `dojo.NodeList()` for multiple toggles\n\t\t//\t|\tdojo.query(\".findMe\").replaceClass(\"addMe\", \"removeMe\");\n\t};\n\t=====*/\n\n\t/*=====\n\tdojo.toggleClass = function(node, classStr, condition){\n\t\t// summary:\n\t\t//\t\tAdds a class to node if not present, or removes if present.\n\t\t//\t\tPass a boolean condition if you want to explicitly add or remove.\n\t\t//      Returns the condition that was specified directly or indirectly.\n\t\t//\n\t\t// node: String|DOMNode\n\t\t//\t\tString ID or DomNode reference to toggle a class string\n\t\t//\n\t\t// classStr: String|Array\n\t\t//\t\tA String class name to toggle, or several space-separated class names,\n\t\t//\t\tor an array of class names.\n\t\t//\n\t\t// condition:\n\t\t//\t\tIf passed, true means to add the class, false means to remove.\n\t\t//      Otherwise dojo.hasClass(node, classStr) is used to detect the class presence.\n\t\t//\n\t\t// example:\n\t\t//\t|\tdojo.toggleClass(\"someNode\", \"hovered\");\n\t\t//\n\t\t// example:\n\t\t//\t\tForcefully add a class\n\t\t//\t|\tdojo.toggleClass(\"someNode\", \"hovered\", true);\n\t\t//\n\t\t// example:\n\t\t//\t\tAvailable in `dojo.NodeList()` for multiple toggles\n\t\t//\t|\tdojo.query(\".toggleMe\").toggleClass(\"toggleMe\");\n\t};\n\t=====*/\n\n\tvar cls, // exports object\n\t\tspaces = /\\s+/, a1 = [\"\"];\n\n\tfunction str2array(s){\n\t\tif(typeof s == \"string\" || s instanceof String){\n\t\t\tif(s && !spaces.test(s)){\n\t\t\t\ta1[0] = s;\n\t\t\t\treturn a1;\n\t\t\t}\n\t\t\tvar a = s.split(spaces);\n\t\t\tif(a.length && !a[0]){\n\t\t\t\ta.shift();\n\t\t\t}\n\t\t\tif(a.length && !a[a.length - 1]){\n\t\t\t\ta.pop();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\t// assumed to be an array\n\t\tif(!s){\n\t\t\treturn [];\n\t\t}\n\t\treturn array.filter(s, function(x){ return x; });\n\t}\n\n\t/* Part II of classList-based implementation is preserved here for posterity\n\tif(has(\"dom-classList\")){\n\t\t// new classList version\n\t\tcls = {\n\t\t\tcontains: function containsClass(node, classStr){\n\t\t\t\tvar clslst = classStr && dom.byId(node)[classList];\n\t\t\t\treturn clslst && clslst.contains(classStr); // Boolean\n\t\t\t},\n\n\t\t\tadd: function addClass(node, classStr){\n\t\t\t\tnode = dom.byId(node);\n\t\t\t\tclassStr = str2array(classStr);\n\t\t\t\tfor(var i = 0, len = classStr.length; i < len; ++i){\n\t\t\t\t\tnode[classList].add(classStr[i]);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tremove: function removeClass(node, classStr){\n\t\t\t\tnode = dom.byId(node);\n\t\t\t\tif(classStr === undefined){\n\t\t\t\t\tnode[className] = \"\";\n\t\t\t\t}else{\n\t\t\t\t\tclassStr = str2array(classStr);\n\t\t\t\t\tfor(var i = 0, len = classStr.length; i < len; ++i){\n\t\t\t\t\t\tnode[classList].remove(classStr[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\treplace: function replaceClass(node, addClassStr, removeClassStr){\n\t\t\t\tnode = dom.byId(node);\n\t\t\t\tif(removeClassStr === undefined){\n\t\t\t\t\tnode[className] = \"\";\n\t\t\t\t}else{\n\t\t\t\t\tremoveClassStr = str2array(removeClassStr);\n\t\t\t\t\tfor(var i = 0, len = removeClassStr.length; i < len; ++i){\n\t\t\t\t\t\tnode[classList].remove(removeClassStr[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddClassStr = str2array(addClassStr);\n\t\t\t\tfor(i = 0, len = addClassStr.length; i < len; ++i){\n\t\t\t\t\tnode[classList].add(addClassStr[i]);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\ttoggle: function toggleClass(node, classStr, condition){\n\t\t\t\tnode = dom.byId(node);\n\t\t\t\tif(condition === undefined){\n\t\t\t\t\tclassStr = str2array(classStr);\n\t\t\t\t\tfor(var i = 0, len = classStr.length; i < len; ++i){\n\t\t\t\t\t\tnode[classList].toggle(classStr[i]);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tcls[condition ? \"add\" : \"remove\"](node, classStr);\n\t\t\t\t}\n\t\t\t\treturn condition;   // Boolean\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\t// regular DOM version\n\tvar fakeNode = {};  // for effective replacement\n\tcls = {\n\t\tcontains: function containsClass(/*DomNode|String*/node, /*String*/classStr){\n\t\t\treturn ((\" \" + dom.byId(node)[className] + \" \").indexOf(\" \" + classStr + \" \") >= 0); // Boolean\n\t\t},\n\n\t\tadd: function addClass(/*DomNode|String*/node, /*String|Array*/classStr){\n\t\t\tnode = dom.byId(node);\n\t\t\tclassStr = str2array(classStr);\n\t\t\tvar cls = node[className], oldLen;\n\t\t\tcls = cls ? \" \" + cls + \" \" : \" \";\n\t\t\toldLen = cls.length;\n\t\t\tfor(var i = 0, len = classStr.length, c; i < len; ++i){\n\t\t\t\tc = classStr[i];\n\t\t\t\tif(c && cls.indexOf(\" \" + c + \" \") < 0){\n\t\t\t\t\tcls += c + \" \";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(oldLen < cls.length){\n\t\t\t\tnode[className] = cls.substr(1, cls.length - 2);\n\t\t\t}\n\t\t},\n\n\t\tremove: function removeClass(/*DomNode|String*/node, /*String|Array?*/classStr){\n\t\t\tnode = dom.byId(node);\n\t\t\tvar cls;\n\t\t\tif(classStr !== undefined){\n\t\t\t\tclassStr = str2array(classStr);\n\t\t\t\tcls = \" \" + node[className] + \" \";\n\t\t\t\tfor(var i = 0, len = classStr.length; i < len; ++i){\n\t\t\t\t\tcls = cls.replace(\" \" + classStr[i] + \" \", \" \");\n\t\t\t\t}\n\t\t\t\tcls = lang.trim(cls);\n\t\t\t}else{\n\t\t\t\tcls = \"\";\n\t\t\t}\n\t\t\tif(node[className] != cls){ node[className] = cls; }\n\t\t},\n\n\t\treplace: function replaceClass(/*DomNode|String*/node, /*String|Array*/addClassStr, /*String|Array?*/removeClassStr){\n\t\t\tnode = dom.byId(node);\n\t\t\tfakeNode[className] = node[className];\n\t\t\tcls.remove(fakeNode, removeClassStr);\n\t\t\tcls.add(fakeNode, addClassStr);\n\t\t\tif(node[className] !== fakeNode[className]){\n\t\t\t\tnode[className] = fakeNode[className];\n\t\t\t}\n\t\t},\n\n\t\ttoggle: function toggleClass(/*DomNode|String*/node, /*String|Array*/classStr, /*Boolean?*/condition){\n\t\t\tnode = dom.byId(node);\n\t\t\tif(condition === undefined){\n\t\t\t\tclassStr = str2array(classStr);\n\t\t\t\tfor(var i = 0, len = classStr.length, c; i < len; ++i){\n\t\t\t\t\tc = classStr[i];\n\t\t\t\t\tcls[cls.contains(node, c) ? \"remove\" : \"add\"](node, c);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tcls[condition ? \"add\" : \"remove\"](node, classStr);\n\t\t\t}\n\t\t\treturn condition;   // Boolean\n\t\t}\n\t};\n\n\treturn cls;\n});\n\n},\n'dojo/_base/window':function(){\ndefine([\"./kernel\", \"../has\", \"./sniff\"], function(dojo, has){\n\t// module:\n\t//\t\tdojo/window\n\t// summary:\n\t//\t\tThis module provides an API to save/set/restore the global/document scope.\n\n/*=====\ndojo.doc = {\n\t// summary:\n\t//\t\tAlias for the current document. 'dojo.doc' can be modified\n\t//\t\tfor temporary context shifting. Also see dojo.withDoc().\n\t// description:\n\t//\t\tRefer to dojo.doc rather\n\t//\t\tthan referring to 'window.document' to ensure your code runs\n\t//\t\tcorrectly in managed contexts.\n\t// example:\n\t//\t|\tn.appendChild(dojo.doc.createElement('div'));\n}\n=====*/\ndojo.doc = this[\"document\"] || null;\n\ndojo.body = function(){\n\t// summary:\n\t//\t\tReturn the body element of the document\n\t//\t\treturn the body object associated with dojo.doc\n\t// example:\n\t//\t|\tdojo.body().appendChild(dojo.doc.createElement('div'));\n\n\t// Note: document.body is not defined for a strict xhtml document\n\t// Would like to memoize this, but dojo.doc can change vi dojo.withDoc().\n\treturn dojo.doc.body || dojo.doc.getElementsByTagName(\"body\")[0]; // Node\n};\n\ndojo.setContext = function(/*Object*/globalObject, /*DocumentElement*/globalDocument){\n\t// summary:\n\t//\t\tchanges the behavior of many core Dojo functions that deal with\n\t//\t\tnamespace and DOM lookup, changing them to work in a new global\n\t//\t\tcontext (e.g., an iframe). The varibles dojo.global and dojo.doc\n\t//\t\tare modified as a result of calling this function and the result of\n\t//\t\t`dojo.body()` likewise differs.\n\tdojo.global = ret.global = globalObject;\n\tdojo.doc = ret.doc = globalDocument;\n};\n\ndojo.withGlobal = function(\t/*Object*/globalObject,\n\t\t\t\t\t\t\t/*Function*/callback,\n\t\t\t\t\t\t\t/*Object?*/thisObject,\n\t\t\t\t\t\t\t/*Array?*/cbArguments){\n\t// summary:\n\t//\t\tInvoke callback with globalObject as dojo.global and\n\t//\t\tglobalObject.document as dojo.doc.\n\t// description:\n\t//\t\tInvoke callback with globalObject as dojo.global and\n\t//\t\tglobalObject.document as dojo.doc. If provided, globalObject\n\t//\t\twill be executed in the context of object thisObject\n\t//\t\tWhen callback() returns or throws an error, the dojo.global\n\t//\t\tand dojo.doc will be restored to its previous state.\n\n\tvar oldGlob = dojo.global;\n\ttry{\n\t\tdojo.global = ret.global = globalObject;\n\t\treturn dojo.withDoc.call(null, globalObject.document, callback, thisObject, cbArguments);\n\t}finally{\n\t\tdojo.global = ret.global = oldGlob;\n\t}\n};\n\ndojo.withDoc = function(\t/*DocumentElement*/documentObject,\n\t\t\t\t\t\t\t/*Function*/callback,\n\t\t\t\t\t\t\t/*Object?*/thisObject,\n\t\t\t\t\t\t\t/*Array?*/cbArguments){\n\t// summary:\n\t//\t\tInvoke callback with documentObject as dojo.doc.\n\t// description:\n\t//\t\tInvoke callback with documentObject as dojo.doc. If provided,\n\t//\t\tcallback will be executed in the context of object thisObject\n\t//\t\tWhen callback() returns or throws an error, the dojo.doc will\n\t//\t\tbe restored to its previous state.\n\n\tvar oldDoc = dojo.doc,\n\t\toldQ = dojo.isQuirks,\n\t\toldIE = dojo.isIE, isIE, mode, pwin;\n\n\ttry{\n\t\tdojo.doc = ret.doc = documentObject;\n\t\t// update dojo.isQuirks and the value of the has feature \"quirks\"\n\t\tdojo.isQuirks = has.add(\"quirks\", dojo.doc.compatMode == \"BackCompat\", true, true); // no need to check for QuirksMode which was Opera 7 only\n\n\t\tif(has(\"ie\")){\n\t\t\tif((pwin = documentObject.parentWindow) && pwin.navigator){\n\t\t\t\t// re-run IE detection logic and update dojo.isIE / has(\"ie\")\n\t\t\t\t// (the only time parentWindow/navigator wouldn't exist is if we were not\n\t\t\t\t// passed an actual legitimate document object)\n\t\t\t\tisIE = parseFloat(pwin.navigator.appVersion.split(\"MSIE \")[1]) || undefined;\n\t\t\t\tmode = documentObject.documentMode;\n\t\t\t\tif(mode && mode != 5 && Math.floor(isIE) != mode){\n\t\t\t\t\tisIE = mode;\n\t\t\t\t}\n\t\t\t\tdojo.isIE = has.add(\"ie\", isIE, true, true);\n\t\t\t}\n\t\t}\n\n\t\tif(thisObject && typeof callback == \"string\"){\n\t\t\tcallback = thisObject[callback];\n\t\t}\n\n\t\treturn callback.apply(thisObject, cbArguments || []);\n\t}finally{\n\t\tdojo.doc = ret.doc = oldDoc;\n\t\tdojo.isQuirks = has.add(\"quirks\", oldQ, true, true);\n\t\tdojo.isIE = has.add(\"ie\", oldIE, true, true);\n\t}\n};\n\nvar ret = {\n\tglobal: dojo.global,\n\tdoc: dojo.doc,\n\tbody: dojo.body,\n\tsetContext: dojo.setContext,\n\twithGlobal: dojo.withGlobal,\n\twithDoc: dojo.withDoc\n};\n\nreturn ret;\n\n});\n\n},\n'dojo/_base/config':function(){\ndefine([\"../has\", \"require\"], function(has, require){\n\t// module:\n\t//\t\tdojo/_base/config\n\t// summary:\n\t//\t\tThis module defines the user configuration during bootstrap.\n\t// description:\n\t//\t\tBy defining user configuration as a module value, an entire configuration can be specified in a build,\n    //\t\tthereby eliminating the need for sniffing and or explicitly setting in the global variable dojoConfig.\n    //\t\tAlso, when multiple instances of dojo exist in a single application, each will necessarily be located\n\t//\t\tat an unique absolute module identifier as given by the package configuration. Implementing configuration\n\t//\t\tas a module allows for specifying unique, per-instance configurations.\n\t// example:\n\t//\t\tCreate a second instance of dojo with a different, instance-uniqe configuration (assume the loader and\n\t//\t\tdojo.js are already loaded).\n\t//\t\t|\t// specify a configuration that creates a new instance of dojo at the absolute module identifier \"myDojo\"\n\t//\t\t|\trequire({\n\t//\t\t|\t\tpackages:[{\n\t//\t\t|\t\t\tname:\"myDojo\",\n\t//\t\t|\t\t\tlocation:\".\", //assume baseUrl points to dojo.js\n\t//\t\t|\t    }]\n\t//\t\t|\t});\n\t//\t\t|\n\t//\t\t|\t// specify a configuration for the myDojo instance\n\t//\t\t|\tdefine(\"myDojo/config\", {\n\t//\t\t|\t\t// normal configuration variables go here, e.g.,\n\t//\t\t|\t\tlocale:\"fr-ca\"\n\t//\t\t|\t});\n\t//\t\t|\n\t//\t\t|\t// load and use the new instance of dojo\n\t//\t\t|\trequire([\"myDojo\"], function(dojo) {\n\t//\t\t|\t\t// dojo is the new instance of dojo\n\t//\t\t|\t\t// use as required\n\t//\t\t|\t});\n\n\tvar result = {};\n\tif(1){\n\t\t// must be the dojo loader; take a shallow copy of require.rawConfig\n\t\tvar src = require.rawConfig, p;\n\t\tfor(p in src){\n\t\t\tresult[p] = src[p];\n\t\t}\n\t}else{\n\t\tvar adviseHas = function(featureSet, prefix, booting){\n\t\t\tfor(p in featureSet){\n\t\t\t\tp!=\"has\" && has.add(prefix + p, featureSet[p], 0, booting);\n\t\t\t}\n\t\t};\n\t\tresult = 1 ?\n\t\t\t// must be a built version of the dojo loader; all config stuffed in require.rawConfig\n\t\t\trequire.rawConfig :\n\t\t\t// a foreign loader\n\t\t\tthis.dojoConfig || this.djConfig || {};\n\t\tadviseHas(result, \"config\", 1);\n\t\tadviseHas(result.has, \"\", 1);\n\t}\n\treturn result;\n\n/*=====\n// note:\n//\t\t'dojoConfig' does not exist under 'dojo.*' so that it can be set before the\n//\t\t'dojo' variable exists.\n// note:\n//\t\tSetting any of these variables *after* the library has loaded does\n//\t\tnothing at all.\n\n// FIXME: can we document these on dojo.config object and explain they must be set via djConfig/dojoConfig global prior to loading dojo.js\n\ndojoConfig = {\n\t// summary:\n\t//\t\tApplication code can set the global 'dojoConfig' prior to loading\n\t//\t\tthe library to control certain global settings for how dojo works.\n\t//\n\t// isDebug: Boolean\n\t//\t\tDefaults to `false`. If set to `true`, ensures that Dojo provides\n\t//\t\textended debugging feedback via Firebug. If Firebug is not available\n\t//\t\ton your platform, setting `isDebug` to `true` will force Dojo to\n\t//\t\tpull in (and display) the version of Firebug Lite which is\n\t//\t\tintegrated into the Dojo distribution, thereby always providing a\n\t//\t\tdebugging/logging console when `isDebug` is enabled. Note that\n\t//\t\tFirebug's `console.*` methods are ALWAYS defined by Dojo. If\n\t//\t\t`isDebug` is false and you are on a platform without Firebug, these\n\t//\t\tmethods will be defined as no-ops.\n\tisDebug: false,\n\t// locale: String\n\t//\t\tThe locale to assume for loading localized resources in this page,\n\t//\t\tspecified according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt).\n\t//\t\tMust be specified entirely in lowercase, e.g. `en-us` and `zh-cn`.\n\t//\t\tSee the documentation for `dojo.i18n` and `dojo.requireLocalization`\n\t//\t\tfor details on loading localized resources. If no locale is specified,\n\t//\t\tDojo assumes the locale of the user agent, according to `navigator.userLanguage`\n\t//\t\tor `navigator.language` properties.\n\tlocale: undefined,\n\t// extraLocale: Array\n\t//\t\tNo default value. Specifies additional locales whose\n\t//\t\tresources should also be loaded alongside the default locale when\n\t//\t\tcalls to `dojo.requireLocalization()` are processed.\n\textraLocale: undefined,\n\t// baseUrl: String\n\t//\t\tThe directory in which `dojo.js` is located. Under normal\n\t//\t\tconditions, Dojo auto-detects the correct location from which it\n\t//\t\twas loaded. You may need to manually configure `baseUrl` in cases\n\t//\t\twhere you have renamed `dojo.js` or in which `<base>` tags confuse\n\t//\t\tsome browsers (e.g. IE 6). The variable `dojo.baseUrl` is assigned\n\t//\t\teither the value of `djConfig.baseUrl` if one is provided or the\n\t//\t\tauto-detected root if not. Other modules are located relative to\n\t//\t\tthis path. The path should end in a slash.\n\tbaseUrl: undefined,\n\t// modulePaths: Object\n\t//\t\tA map of module names to paths relative to `dojo.baseUrl`. The\n\t//\t\tkey/value pairs correspond directly to the arguments which\n\t//\t\t`dojo.registerModulePath` accepts. Specifiying\n\t//\t\t`djConfig.modulePaths = { \"foo\": \"../../bar\" }` is the equivalent\n\t//\t\tof calling `dojo.registerModulePath(\"foo\", \"../../bar\");`. Multiple\n\t//\t\tmodules may be configured via `djConfig.modulePaths`.\n\tmodulePaths: {},\n\t// afterOnLoad: Boolean\n\t//\t\tIndicates Dojo was added to the page after the page load. In this case\n\t//\t\tDojo will not wait for the page DOMContentLoad/load events and fire\n\t//\t\tits dojo.addOnLoad callbacks after making sure all outstanding\n\t//\t\tdojo.required modules have loaded. Only works with a built dojo.js,\n\t//\t\tit does not work the dojo.js directly from source control.\n\tafterOnLoad: false,\n\t// addOnLoad: Function or Array\n\t//\t\tAdds a callback via dojo.addOnLoad. Useful when Dojo is added after\n\t//\t\tthe page loads and djConfig.afterOnLoad is true. Supports the same\n\t//\t\targuments as dojo.addOnLoad. When using a function reference, use\n\t//\t\t`djConfig.addOnLoad = function(){};`. For object with function name use\n\t//\t\t`djConfig.addOnLoad = [myObject, \"functionName\"];` and for object with\n\t//\t\tfunction reference use\n\t//\t\t`djConfig.addOnLoad = [myObject, function(){}];`\n\taddOnLoad: null,\n\t// require: Array\n\t//\t\tAn array of module names to be loaded immediately after dojo.js has been included\n\t//\t\tin a page.\n\trequire: [],\n\t// defaultDuration: Array\n\t//\t\tDefault duration, in milliseconds, for wipe and fade animations within dijits.\n\t//\t\tAssigned to dijit.defaultDuration.\n\tdefaultDuration: 200,\n\t// dojoBlankHtmlUrl: String\n\t//\t\tUsed by some modules to configure an empty iframe. Used by dojo.io.iframe and\n\t//\t\tdojo.back, and dijit popup support in IE where an iframe is needed to make sure native\n\t//\t\tcontrols do not bleed through the popups. Normally this configuration variable\n\t//\t\tdoes not need to be set, except when using cross-domain/CDN Dojo builds.\n\t//\t\tSave dojo/resources/blank.html to your domain and set `djConfig.dojoBlankHtmlUrl`\n\t//\t\tto the path on your domain your copy of blank.html.\n\tdojoBlankHtmlUrl: undefined,\n\t//\tioPublish: Boolean?\n\t//\t\tSet this to true to enable publishing of topics for the different phases of\n\t//\t\tIO operations. Publishing is done via dojo.publish. See dojo.__IoPublish for a list\n\t//\t\tof topics that are published.\n\tioPublish: false,\n\t//\tuseCustomLogger: Anything?\n\t//\t\tIf set to a value that evaluates to true such as a string or array and\n\t//\t\tisDebug is true and Firebug is not available or running, then it bypasses\n\t//\t\tthe creation of Firebug Lite allowing you to define your own console object.\n\tuseCustomLogger: undefined,\n\t// transparentColor: Array\n\t//\t\tArray containing the r, g, b components used as transparent color in dojo.Color;\n\t//\t\tif undefined, [255,255,255] (white) will be used.\n\ttransparentColor: undefined,\n\t// skipIeDomLoaded: Boolean\n\t//\t\tFor IE only, skip the DOMContentLoaded hack used. Sometimes it can cause an Operation\n\t//\t\tAborted error if the rest of the page triggers script defers before the DOM is ready.\n\t//\t\tIf this is config value is set to true, then dojo.addOnLoad callbacks will not be\n\t//\t\ttriggered until the page load event, which is after images and iframes load. If you\n\t//\t\twant to trigger the callbacks sooner, you can put a script block in the bottom of\n\t//\t\tyour HTML that calls dojo._loadInit();. If you are using multiversion support, change\n\t//\t\t\"dojo.\" to the appropriate scope name for dojo.\n\tskipIeDomLoaded: false\n}\n=====*/\n});\n\n\n},\n'dojo/_base/event':function(){\ndefine([\"./kernel\", \"../on\", \"../has\", \"../dom-geometry\"], function(dojo, on, has, dom){\n  //  module:\n  //    dojo/_base/event\n  //  summary:\n  //    This module defines dojo DOM event API.\n\tif(on._fixEvent){\n\t\tvar fixEvent = on._fixEvent;\n\t\ton._fixEvent = function(evt, se){\n\t\t\t// add some additional normalization for back-compat, this isn't in on.js because it is somewhat more expensive\n\t\t\tevt = fixEvent(evt, se);\n\t\t\tif(evt){\n\t\t\t\tdom.normalizeEvent(evt);\n\t\t\t}\n\t\t\treturn evt;\n\t\t};\t\t\n\t}\n\tdojo.fixEvent = function(/*Event*/ evt, /*DOMNode*/ sender){\n\t\t// summary:\n\t\t//\t\tnormalizes properties on the event object including event\n\t\t//\t\tbubbling methods, keystroke normalization, and x/y positions\n\t\t// evt: Event\n\t\t//\t\tnative event object\n\t\t// sender: DOMNode\n\t\t//\t\tnode to treat as \"currentTarget\"\n\t\tif(on._fixEvent){\n\t\t\treturn on._fixEvent(evt, sender);\n\t\t}\n\t\treturn evt;\t// Event\n\t};\n\t\n\tdojo.stopEvent = function(/*Event*/ evt){\n\t\t// summary:\n\t\t//\t\tprevents propagation and clobbers the default action of the\n\t\t//\t\tpassed event\n\t\t// evt: Event\n\t\t//\t\tThe event object. If omitted, window.event is used on IE.\n\t\tif(has(\"dom-addeventlistener\") || (evt && evt.preventDefault)){\n\t\t\tevt.preventDefault();\n\t\t\tevt.stopPropagation();\n\t\t}else{\n\t\t\tevt = evt || window.event;\n\t\t\tevt.cancelBubble = true;\n\t\t\ton._preventDefault.call(evt);\n\t\t}\n\t};\n\n\treturn {\n\t\tfix: dojo.fixEvent,\n\t\tstop: dojo.stopEvent\n\t};\n});\n\n},\n'dojo/main':function(){\ndefine([\n\t\"./_base/kernel\",\n\t\"./has\",\n\t\"require\",\n\t\"./_base/sniff\",\n\t\"./_base/lang\",\n\t\"./_base/array\",\n\t\"./ready\",\n\t\"./_base/declare\",\n\t\"./_base/connect\",\n\t\"./_base/Deferred\",\n\t\"./_base/json\",\n\t\"./_base/Color\",\n\t\"./has!dojo-firebug?./_firebug/firebug\",\n\t\"./_base/browser\",\n\t\"./_base/loader\"], function(dojo, has, require, sniff, lang, array, ready){\n\t// module:\n\t//\t\tdojo/main\n\t// summary:\n\t//\t\tThis is the package main module for the dojo package; it loads dojo base appropriate for the execution environment.\n\n\t// the preferred way to load the dojo firebug console is by setting has(\"dojo-firebug\") true in dojoConfig\n\t// the isDebug config switch is for backcompat and will work fine in sync loading mode; it works in\n\t// async mode too, but there's no guarantee when the module is loaded; therefore, if you need a firebug\n\t// console guarnanteed at a particular spot in an app, either set config.has[\"dojo-firebug\"] true before\n\t// loading dojo.js or explicitly include dojo/_firebug/firebug in a dependency list.\n\tif(dojo.config.isDebug){\n\t\trequire([\"./_firebug/firebug\"]);\n\t}\n\n\t// dojoConfig.require is deprecated; use the loader configuration property deps\n\ttrue || has.add(\"dojo-config-require\", 1);\n\tif(1){\n\t\tvar deps= dojo.config.require;\n\t\tif(deps){\n\t\t\t// dojo.config.require may be dot notation\n\t\t\tdeps= array.map(lang.isArray(deps) ? deps : [deps], function(item){ return item.replace(/\\./g, \"/\"); });\n\t\t\tif(dojo.isAsync){\n\t\t\t\trequire(deps);\n\t\t\t}else{\n\t\t\t\t// this is a bit janky; in 1.6- dojo is defined before these requires are applied; but in 1.7+\n\t\t\t\t// dojo isn't defined until returning from this module; this is only a problem in sync mode\n\t\t\t\t// since we're in sync mode, we know we've got our loader with its priority ready queue\n\t\t\t\tready(1, function(){require(deps);});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dojo;\n});\n\n},\n'dojo/ready':function(){\ndefine([\"./_base/kernel\", \"./has\", \"require\", \"./domReady\", \"./_base/lang\"], function(dojo, has, require, domReady, lang) {\n\t// module:\n\t//\t\tdojo/ready\n\t// summary:\n\t//\t\tThis module defines the dojo.ready API.\n\t//\n\t// note:\n\t//\t\tThis module should be unnecessary in dojo 2.0\n\tvar\n\t\t// truthy if DOMContentLoaded or better (e.g., window.onload fired) has been achieved\n\t\tisDomReady = 0,\n\n\t\t// a function to call to cause onLoad to be called when all requested modules have been loaded\n\t\trequestCompleteSignal,\n\n\t\t// The queue of functions waiting to execute as soon as dojo.ready conditions satisfied\n\t\tloadQ = [],\n\n\t\t// prevent recursion in onLoad\n\t\tonLoadRecursiveGuard = 0,\n\n\t\thandleDomReady = function(){\n\t\t\tisDomReady = 1;\n\t\t\tdojo._postLoad = dojo.config.afterOnLoad = true;\n\t\t\tif(loadQ.length){\n\t\t\t\trequestCompleteSignal(onLoad);\n\t\t\t}\n\t\t},\n\n\t\t// run the next function queued with dojo.ready\n\t\tonLoad = function(){\n\t\t\tif(isDomReady && !onLoadRecursiveGuard && loadQ.length){\n\t\t\t\t//guard against recursions into this function\n\t\t\t\tonLoadRecursiveGuard = 1;\n\t\t\t\tvar f = loadQ.shift();\n\t\t\t\t\ttry{\n\t\t\t\t\t\tf();\n\t\t\t\t\t}\n\t\t\t\t\t\t// FIXME: signal the error via require.on\n\t\t\t\t\tfinally{\n\t\t\t\t\t\tonLoadRecursiveGuard = 0;\n\t\t\t\t\t}\n\t\t\t\tonLoadRecursiveGuard = 0;\n\t\t\t\tif(loadQ.length){\n\t\t\t\t\trequestCompleteSignal(onLoad);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t// define requireCompleteSignal; impl depends on loader\n\tif(1){\n\t\trequire.on(\"idle\", onLoad);\n\t\trequestCompleteSignal = function(){\n\t\t\tif(require.idle()){\n\t\t\t\tonLoad();\n\t\t\t} // else do nothing, onLoad will be called with the next idle signal\n\t\t};\n\t}else{\n\t\t// RequireJS or similar\n\t\trequestCompleteSignal = function(){\n\t\t\t// the next function call will fail if you don't have a loader with require.ready\n\t\t\t// in that case, either fix your loader, use dojo's loader, or don't call dojo.ready;\n\t\t\trequire.ready(onLoad);\n\t\t};\n\t}\n\n\tvar ready = dojo.ready = dojo.addOnLoad = function(priority, context, callback){\n\t\t// summary: Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated.\n\t\t// priority: Integer?\n\t\t//\t\tThe order in which to exec this callback relative to other callbacks, defaults to 1000\n\t\t// context: Object?|Function\n\t\t//\t\tThe context in which to run execute callback, or a callback if not using context\n\t\t// callback: Function?\n\t\t//\t\tThe function to execute.\n\t\t//\n\t\t// example:\n\t\t//\tSimple DOM and Modules ready syntax\n\t\t//\t|\tdojo.ready(function(){ alert(\"Dom ready!\"); });\n\t\t//\n\t\t// example:\n\t\t//\tUsing a priority\n\t\t//\t|\tdojo.ready(2, function(){ alert(\"low priority ready!\"); })\n\t\t//\n\t\t// example:\n\t\t//\tUsing context\n\t\t//\t|\tdojo.ready(foo, function(){\n\t\t//\t|\t\t// in here, this == foo\n\t\t//\t|\t})\n\t\t//\n\t\t// example:\n\t\t//\tUsing dojo.hitch style args:\n\t\t//\t|\tvar foo = { dojoReady: function(){ console.warn(this, \"dojo dom and modules ready.\"); } };\n\t\t//\t|\tdojo.ready(foo, \"dojoReady\");\n\n\t\tvar hitchArgs = lang._toArray(arguments);\n\t\tif(typeof priority != \"number\"){\n\t\t\tcallback = context;\n\t\t\tcontext = priority;\n\t\t\tpriority = 1000;\n\t\t}else{\n\t\t\thitchArgs.shift();\n\t\t}\n\t\tcallback = callback ?\n\t\t\tlang.hitch.apply(dojo, hitchArgs) :\n\t\t\tfunction(){\n\t\t\t\tcontext();\n\t\t\t};\n\t\tcallback.priority = priority;\n\t\tfor(var i = 0; i < loadQ.length && priority >= loadQ[i].priority; i++){}\n\t\tloadQ.splice(i, 0, callback);\n\t\trequestCompleteSignal();\n\t};\n\n\ttrue || has.add(\"dojo-config-addOnLoad\", 1);\n\tif(1){\n\t\tvar dca = dojo.config.addOnLoad;\n\t\tif(dca){\n\t\t\tready[(lang.isArray(dca) ? \"apply\" : \"call\")](dojo, dca);\n\t\t}\n\t}\n\n\tif(1 && dojo.config.parseOnLoad && !dojo.isAsync){\n\t\tready(99, function(){\n\t\t\tif(!dojo.parser){\n\t\t\t\tdojo.deprecated(\"Add explicit require(['dojo/parser']);\", \"\", \"2.0\");\n\t\t\t\trequire([\"dojo/parser\"]);\n\t\t\t}\n\t\t});\n\t}\n\n\tif(1){\n\t\tdomReady(handleDomReady);\n\t}else{\n\t\thandleDomReady();\n\t}\n\n\treturn ready;\n});\n\n},\n'dojo/aspect':function(){\ndefine([], function(){\n\n// TODOC: after/before/around return object\n// TODOC: after/before/around param types. \n\n/*=====\n\tdojo.aspect = {\n\t\t// summary: provides aspect oriented programming functionality, allowing for\n\t\t//\t\tone to add before, around, or after advice on existing methods.\n\t\t//\n\t\t// example:\n\t\t//\t|\tdefine([\"dojo/aspect\"], function(aspect){\n\t\t//\t|\t\tvar signal = aspect.after(targetObject, \"methodName\", function(someArgument){\n\t\t//\t|\t\t\tthis will be called when targetObject.methodName() is called, after the original function is called\n\t\t//\t|\t\t});\n\t\t//\n\t\t// example:\n\t\t//\tThe returned signal object can be used to cancel the advice.\n\t\t//\t|\tsignal.remove(); // this will stop the advice from being executed anymore\n\t\t//\t|\taspect.before(targetObject, \"methodName\", function(someArgument){\n\t\t//\t|\t\t// this will be called when targetObject.methodName() is called, before the original function is called\n\t\t//\t|\t });\n\t\t\n\t\tafter: function(target, methodName, advice, receiveArguments){\n\t\t\t// summary: The \"after\" export of the aspect module is a function that can be used to attach\n\t\t\t//\t\t\"after\" advice to a method. This function will be executed after the original method\n\t\t\t//\t\tis executed. By default the function will be called with a single argument, the return\n\t\t\t//\t\tvalue of the original method, or the the return value of the last executed advice (if a previous one exists).\n\t\t\t//\t\tThe fourth (optional) argument can be set to true to so the function receives the original\n\t\t\t//\t\targuments (from when the original method was called) rather than the return value.\n\t\t\t//\t\tIf there are multiple \"after\" advisors, they are executed in the order they were registered.\n\t\t\t// target: Object\n\t\t\t//\t\tThis is the target object\n\t\t\t// methodName: String\n\t\t\t//\t\tThis is the name of the method to attach to.\n\t\t\t// advice: Function\n\t\t\t//\t\tThis is function to be called after the original method\n\t\t\t// receiveArguments: Boolean?\n\t\t\t//\t\tIf this is set to true, the advice function receives the original arguments (from when the original mehtod\n\t\t\t//\t\twas called) rather than the return value of the original/previous method.\n\t\t\t// returns:\n\t\t\t//\t\tA signal object that can be used to cancel the advice. If remove() is called on this signal object, it will\n\t\t\t//\t\tstop the advice function from being executed.\n\t\t},\n\t\t\n\t\tbefore: function(target, methodName, advice){\n\t\t\t// summary: The \"before\" export of the aspect module is a function that can be used to attach\n\t\t\t//\t\t\"before\" advice to a method. This function will be executed before the original method\n\t\t\t//\t\tis executed. This function will be called with the arguments used to call the method.\n\t\t\t//\t\tThis function may optionally return an array as the new arguments to use to call\n\t\t\t//\t\tthe original method (or the previous, next-to-execute before advice, if one exists).\n\t\t\t//\t\tIf the before method doesn't return anything (returns undefined) the original arguments\n\t\t\t//\t\twill be preserved.\n\t\t\t//\t\tIf there are multiple \"before\" advisors, they are executed in the reverse order they were registered.\n\t\t\t//\n\t\t\t// target: Object\n\t\t\t//\t\tThis is the target object\n\t\t\t// methodName: String\n\t\t\t//\t\tThis is the name of the method to attach to.\n\t\t\t// advice: Function\n\t\t\t//\t\tThis is function to be called before the original method\t \n\t\t},\n\n\t\taround: function(target, methodName, advice){\n\t\t\t// summary: The \"around\" export of the aspect module is a function that can be used to attach\n\t\t\t//\t\t\"around\" advice to a method. The advisor function is immediately executed when\n\t\t\t//\t\tthe around() is called, is passed a single argument that is a function that can be\n\t\t\t//\t\tcalled to continue execution of the original method (or the next around advisor).\n\t\t\t//\t\tThe advisor function should return a function, and this function will be called whenever\n\t\t\t//\t\tthe method is called. It will be called with the arguments used to call the method.\n\t\t\t//\t\tWhatever this function returns will be returned as the result of the method call (unless after advise changes it).\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tIf there are multiple \"around\" advisors, the most recent one is executed first,\n\t\t\t//\t\twhich can then delegate to the next one and so on. For example:\n\t\t\t//\t\t|\taround(obj, \"foo\", function(originalFoo){\n\t\t\t//\t\t|\t\treturn function(){\n\t\t\t//\t\t|\t\t\tvar start = new Date().getTime();\n\t\t\t//\t\t|\t\t\tvar results = originalFoo.apply(this, arguments); // call the original\n\t\t\t//\t\t|\t\t\tvar end = new Date().getTime();\n\t\t\t//\t\t|\t\t\tconsole.log(\"foo execution took \" + (end - start) + \" ms\");\n\t\t\t//\t\t|\t\t\treturn results;\n\t\t\t//\t\t|\t\t};\n\t\t\t//\t\t|\t});\n\t\t\t//\n\t\t\t// target: Object\n\t\t\t//\t\tThis is the target object\n\t\t\t// methodName: String\n\t\t\t//\t\tThis is the name of the method to attach to.\n\t\t\t// advice: Function\n\t\t\t//\t\tThis is function to be called around the original method\n\t\t}\n\n\t};\n=====*/\n\n\t\"use strict\";\n\tfunction advise(dispatcher, type, advice, receiveArguments){\n\t\tvar previous = dispatcher[type];\n\t\tvar around = type == \"around\";\n\t\tvar signal;\n\t\tif(around){\n\t\t\tvar advised = advice(function(){\n\t\t\t\treturn previous.advice(this, arguments);\n\t\t\t});\n\t\t\tsignal = {\n\t\t\t\tremove: function(){\n\t\t\t\t\tsignal.cancelled = true;\n\t\t\t\t},\n\t\t\t\tadvice: function(target, args){\n\t\t\t\t\treturn signal.cancelled ?\n\t\t\t\t\t\tprevious.advice(target, args) : // cancelled, skip to next one\n\t\t\t\t\t\tadvised.apply(target, args);\t// called the advised function\n\t\t\t\t}\n\t\t\t};\n\t\t}else{\n\t\t\t// create the remove handler\n\t\t\tsignal = {\n\t\t\t\tremove: function(){\n\t\t\t\t\tvar previous = signal.previous;\n\t\t\t\t\tvar next = signal.next;\n\t\t\t\t\tif(!next && !previous){\n\t\t\t\t\t\tdelete dispatcher[type];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(previous){\n\t\t\t\t\t\t\tprevious.next = next;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdispatcher[type] = next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(next){\n\t\t\t\t\t\t\tnext.previous = previous;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tadvice: advice,\n\t\t\t\treceiveArguments: receiveArguments\n\t\t\t};\n\t\t}\n\t\tif(previous && !around){\n\t\t\tif(type == \"after\"){\n\t\t\t\t// add the listener to the end of the list\n\t\t\t\tvar next = previous;\n\t\t\t\twhile(next){\n\t\t\t\t\tprevious = next;\n\t\t\t\t\tnext = next.next;\n\t\t\t\t}\n\t\t\t\tprevious.next = signal;\n\t\t\t\tsignal.previous = previous;\n\t\t\t}else if(type == \"before\"){\n\t\t\t\t// add to beginning\n\t\t\t\tdispatcher[type] = signal;\n\t\t\t\tsignal.next = previous;\n\t\t\t\tprevious.previous = signal;\n\t\t\t}\n\t\t}else{\n\t\t\t// around or first one just replaces\n\t\t\tdispatcher[type] = signal;\n\t\t}\n\t\treturn signal;\n\t}\n\tfunction aspect(type){\n\t\treturn function(target, methodName, advice, receiveArguments){\n\t\t\tvar existing = target[methodName], dispatcher;\n\t\t\tif(!existing || existing.target != target){\n\t\t\t\t// no dispatcher in place\n\t\t\t\tdispatcher = target[methodName] = function(){\n\t\t\t\t\t// before advice\n\t\t\t\t\tvar args = arguments;\n\t\t\t\t\tvar before = dispatcher.before;\n\t\t\t\t\twhile(before){\n\t\t\t\t\t\targs = before.advice.apply(this, args) || args;\n\t\t\t\t\t\tbefore = before.next;\n\t\t\t\t\t}\n\t\t\t\t\t// around advice\n\t\t\t\t\tif(dispatcher.around){\n\t\t\t\t\t\tvar results = dispatcher.around.advice(this, args);\n\t\t\t\t\t}\n\t\t\t\t\t// after advice\n\t\t\t\t\tvar after = dispatcher.after;\n\t\t\t\t\twhile(after){\n\t\t\t\t\t\tresults = after.receiveArguments ? after.advice.apply(this, args) || results :\n\t\t\t\t\t\t\t\tafter.advice.call(this, results);\n\t\t\t\t\t\tafter = after.next;\n\t\t\t\t\t}\n\t\t\t\t\treturn results;\n\t\t\t\t};\n\t\t\t\tif(existing){\n\t\t\t\t\tdispatcher.around = {advice: function(target, args){\n\t\t\t\t\t\treturn existing.apply(target, args);\n\t\t\t\t\t}};\n\t\t\t\t}\n\t\t\t\tdispatcher.target = target;\n\t\t\t}\n\t\t\tvar results = advise((dispatcher || existing), type, advice, receiveArguments);\n\t\t\tadvice = null;\n\t\t\treturn results;\n\t\t};\n\t}\n\treturn {\n\t\tbefore: aspect(\"before\"),\n\t\taround: aspect(\"around\"),\n\t\tafter: aspect(\"after\")\n\t};\n});\n\n},\n'dojo/_base/connect':function(){\ndefine([\"./kernel\", \"../on\", \"../topic\", \"../aspect\", \"./event\", \"../mouse\", \"./sniff\", \"./lang\", \"../keys\"], function(kernel, on, hub, aspect, eventModule, mouse, has, lang){\n//  module:\n//    dojo/_base/connect\n//  summary:\n//    This module defines the dojo.connect API.\n//\t\tThis modules also provides keyboard event handling helpers.\n//\t\tThis module exports an extension event for emulating Firefox's keypress handling.\n//\t\tHowever, this extension event exists primarily for backwards compatibility and\n//\t\tis not recommended. WebKit and IE uses an alternate keypress handling (only\n//\t\tfiring for printable characters, to distinguish from keydown events), and most\n//\t\tconsider the WebKit/IE behavior more desirable.\nhas.add(\"events-keypress-typed\", function(){ // keypresses should only occur a printable character is hit\n\tvar testKeyEvent = {charCode: 0};\n\ttry{\n\t\ttestKeyEvent = document.createEvent(\"KeyboardEvent\");\n\t\t(testKeyEvent.initKeyboardEvent || testKeyEvent.initKeyEvent).call(testKeyEvent, \"keypress\", true, true, null, false, false, false, false, 9, 3);\n\t}catch(e){}\n\treturn testKeyEvent.charCode == 0 && !has(\"opera\");\n});\n\nfunction connect_(obj, event, context, method, dontFix){\n\tmethod = lang.hitch(context, method);\n\tif(!obj || !(obj.addEventListener || obj.attachEvent)){\n\t\t// it is a not a DOM node and we are using the dojo.connect style of treating a\n\t\t// method like an event, must go right to aspect\n\t\treturn aspect.after(obj || kernel.global, event, method, true);\n\t}\n\tif(typeof event == \"string\" && event.substring(0, 2) == \"on\"){\n\t\tevent = event.substring(2);\n\t}\n\tif(!obj){\n\t\tobj = kernel.global;\n\t}\n\tif(!dontFix){\n\t\tswitch(event){\n\t\t\t// dojo.connect has special handling for these event types\n\t\t\tcase \"keypress\":\n\t\t\t\tevent = keypress;\n\t\t\t\tbreak;\n\t\t\tcase \"mouseenter\":\n\t\t\t\tevent = mouse.enter;\n\t\t\t\tbreak;\n\t\t\tcase \"mouseleave\":\n\t\t\t\tevent = mouse.leave;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn on(obj, event, method, dontFix);\n}\n\nvar _punctMap = {\n\t106:42,\n\t111:47,\n\t186:59,\n\t187:43,\n\t188:44,\n\t189:45,\n\t190:46,\n\t191:47,\n\t192:96,\n\t219:91,\n\t220:92,\n\t221:93,\n\t222:39,\n\t229:113\n};\nvar evtCopyKey = has(\"mac\") ? \"metaKey\" : \"ctrlKey\";\n\n\nvar _synthesizeEvent = function(evt, props){\n\tvar faux = lang.mixin({}, evt, props);\n\tsetKeyChar(faux);\n\t// FIXME: would prefer to use lang.hitch: lang.hitch(evt, evt.preventDefault);\n\t// but it throws an error when preventDefault is invoked on Safari\n\t// does Event.preventDefault not support \"apply\" on Safari?\n\tfaux.preventDefault = function(){ evt.preventDefault(); };\n\tfaux.stopPropagation = function(){ evt.stopPropagation(); };\n\treturn faux;\n};\nfunction setKeyChar(evt){\n\tevt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';\n\tevt.charOrCode = evt.keyChar || evt.keyCode;\n}\nvar keypress;\nif(has(\"events-keypress-typed\")){\n\t// this emulates Firefox's keypress behavior where every keydown can correspond to a keypress\n\tvar _trySetKeyCode = function(e, code){\n\t\ttry{\n\t\t\t// squelch errors when keyCode is read-only\n\t\t\t// (e.g. if keyCode is ctrl or shift)\n\t\t\treturn (e.keyCode = code);\n\t\t}catch(e){\n\t\t\treturn 0;\n\t\t}\n\t};\n\tkeypress = function(object, listener){\n\t\tvar keydownSignal = on(object, \"keydown\", function(evt){\n\t\t\t// munge key/charCode\n\t\t\tvar k=evt.keyCode;\n\t\t\t// These are Windows Virtual Key Codes\n\t\t\t// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/WinUI/WindowsUserInterface/UserInput/VirtualKeyCodes.asp\n\t\t\tvar unprintable = (k!=13 || (has(\"ie\") >= 9 && !has(\"quirks\"))) && k!=32 && (k!=27||!has(\"ie\")) && (k<48||k>90) && (k<96||k>111) && (k<186||k>192) && (k<219||k>222) && k!=229;\n\t\t\t// synthesize keypress for most unprintables and CTRL-keys\n\t\t\tif(unprintable||evt.ctrlKey){\n\t\t\t\tvar c = unprintable ? 0 : k;\n\t\t\t\tif(evt.ctrlKey){\n\t\t\t\t\tif(k==3 || k==13){\n\t\t\t\t\t\treturn listener.call(evt.currentTarget, evt); // IE will post CTRL-BREAK, CTRL-ENTER as keypress natively\n\t\t\t\t\t}else if(c>95 && c<106){\n\t\t\t\t\t\tc -= 48; // map CTRL-[numpad 0-9] to ASCII\n\t\t\t\t\t}else if((!evt.shiftKey)&&(c>=65&&c<=90)){\n\t\t\t\t\t\tc += 32; // map CTRL-[A-Z] to lowercase\n\t\t\t\t\t}else{\n\t\t\t\t\t\tc = _punctMap[c] || c; // map other problematic CTRL combinations to ASCII\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// simulate a keypress event\n\t\t\t\tvar faux = _synthesizeEvent(evt, {type: 'keypress', faux: true, charCode: c});\n\t\t\t\tlistener.call(evt.currentTarget, faux);\n\t\t\t\tif(has(\"ie\")){\n\t\t\t\t\t_trySetKeyCode(evt, faux.keyCode);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tvar keypressSignal = on(object, \"keypress\", function(evt){\n\t\t\tvar c = evt.charCode;\n\t\t\tc = c>=32 ? c : 0;\n\t\t\tevt = _synthesizeEvent(evt, {charCode: c, faux: true});\n\t\t\treturn listener.call(this, evt);\n\t\t});\n\t\treturn {\n\t\t\tremove: function(){\n\t\t\t\tkeydownSignal.remove();\n\t\t\t\tkeypressSignal.remove();\n\t\t\t}\n\t\t};\n\t};\n}else{\n\tif(has(\"opera\")){\n\t\tkeypress = function(object, listener){\n\t\t\treturn on(object, \"keypress\", function(evt){\n\t\t\t\tvar c = evt.which;\n\t\t\t\tif(c==3){\n\t\t\t\t\tc=99; // Mozilla maps CTRL-BREAK to CTRL-c\n\t\t\t\t}\n\t\t\t\t// can't trap some keys at all, like INSERT and DELETE\n\t\t\t\t// there is no differentiating info between DELETE and \".\", or INSERT and \"-\"\n\t\t\t\tc = c<32 && !evt.shiftKey ? 0 : c;\n\t\t\t\tif(evt.ctrlKey && !evt.shiftKey && c>=65 && c<=90){\n\t\t\t\t\t// lowercase CTRL-[A-Z] keys\n\t\t\t\t\tc += 32;\n\t\t\t\t}\n\t\t\t\treturn listener.call(this, _synthesizeEvent(evt, { charCode: c }));\n\t\t\t});\n\t\t};\n\t}else{\n\t\tkeypress = function(object, listener){\n\t\t\treturn on(object, \"keypress\", function(evt){\n\t\t\t\tsetKeyChar(evt);\n\t\t\t\treturn listener.call(this, evt);\n\t\t\t});\n\t\t};\n\t}\n}\n\nvar connect = {\n\t_keypress:keypress,\n\n\tconnect:function(obj, event, context, method, dontFix){\n\t\t// normalize arguments\n\t\tvar a=arguments, args=[], i=0;\n\t\t// if a[0] is a String, obj was omitted\n\t\targs.push(typeof a[0] == \"string\" ? null : a[i++], a[i++]);\n\t\t// if the arg-after-next is a String or Function, context was NOT omitted\n\t\tvar a1 = a[i+1];\n\t\targs.push(typeof a1 == \"string\" || typeof a1 == \"function\" ? a[i++] : null, a[i++]);\n\t\t// absorb any additional arguments\n\t\tfor(var l=a.length; i<l; i++){\targs.push(a[i]); }\n\t\treturn connect_.apply(this, args);\n\t},\n\n\tdisconnect:function(handle){\n\t\tif(handle){\n\t\t\thandle.remove();\n\t\t}\n\t},\n\n\tsubscribe:function(topic, context, method){\n\t\treturn hub.subscribe(topic, lang.hitch(context, method));\n\t},\n\n\tpublish:function(topic, args){\n\t\treturn hub.publish.apply(hub, [topic].concat(args));\n\t},\n\n\tconnectPublisher:function(topic, obj, event){\n\t\tvar pf = function(){ connect.publish(topic, arguments); };\n\t\treturn event ? connect.connect(obj, event, pf) : connect.connect(obj, pf); //Handle\n\t},\n\n\tisCopyKey: function(e){\n\t\treturn e[evtCopyKey];\t// Boolean\n\t}\n};\nconnect.unsubscribe = connect.disconnect;\n\n1 && lang.mixin(kernel, connect);\nreturn connect;\n\n/*=====\ndojo.connect = function(obj, event, context, method, dontFix){\n\t// summary:\n\t//\t\t`dojo.connect` is the core event handling and delegation method in\n\t//\t\tDojo. It allows one function to \"listen in\" on the execution of\n\t//\t\tany other, triggering the second whenever the first is called. Many\n\t//\t\tlisteners may be attached to a function, and source functions may\n\t//\t\tbe either regular function calls or DOM events.\n\t//\n\t// description:\n\t//\t\tConnects listeners to actions, so that after event fires, a\n\t//\t\tlistener is called with the same arguments passed to the original\n\t//\t\tfunction.\n\t//\n\t//\t\tSince `dojo.connect` allows the source of events to be either a\n\t//\t\t\"regular\" JavaScript function or a DOM event, it provides a uniform\n\t//\t\tinterface for listening to all the types of events that an\n\t//\t\tapplication is likely to deal with though a single, unified\n\t//\t\tinterface. DOM programmers may want to think of it as\n\t//\t\t\"addEventListener for everything and anything\".\n\t//\n\t//\t\tWhen setting up a connection, the `event` parameter must be a\n\t//\t\tstring that is the name of the method/event to be listened for. If\n\t//\t\t`obj` is null, `kernel.global` is assumed, meaning that connections\n\t//\t\tto global methods are supported but also that you may inadvertently\n\t//\t\tconnect to a global by passing an incorrect object name or invalid\n\t//\t\treference.\n\t//\n\t//\t\t`dojo.connect` generally is forgiving. If you pass the name of a\n\t//\t\tfunction or method that does not yet exist on `obj`, connect will\n\t//\t\tnot fail, but will instead set up a stub method. Similarly, null\n\t//\t\targuments may simply be omitted such that fewer than 4 arguments\n\t//\t\tmay be required to set up a connection See the examples for details.\n\t//\n\t//\t\tThe return value is a handle that is needed to\n\t//\t\tremove this connection with `dojo.disconnect`.\n\t//\n\t// obj: Object|null:\n\t//\t\tThe source object for the event function.\n\t//\t\tDefaults to `kernel.global` if null.\n\t//\t\tIf obj is a DOM node, the connection is delegated\n\t//\t\tto the DOM event manager (unless dontFix is true).\n\t//\n\t// event: String:\n\t//\t\tString name of the event function in obj.\n\t//\t\tI.e. identifies a property `obj[event]`.\n\t//\n\t// context: Object|null\n\t//\t\tThe object that method will receive as \"this\".\n\t//\n\t//\t\tIf context is null and method is a function, then method\n\t//\t\tinherits the context of event.\n\t//\n\t//\t\tIf method is a string then context must be the source\n\t//\t\tobject object for method (context[method]). If context is null,\n\t//\t\tkernel.global is used.\n\t//\n\t// method: String|Function:\n\t//\t\tA function reference, or name of a function in context.\n\t//\t\tThe function identified by method fires after event does.\n\t//\t\tmethod receives the same arguments as the event.\n\t//\t\tSee context argument comments for information on method's scope.\n\t//\n\t// dontFix: Boolean?\n\t//\t\tIf obj is a DOM node, set dontFix to true to prevent delegation\n\t//\t\tof this connection to the DOM event manager.\n\t//\n\t// example:\n\t//\t\tWhen obj.onchange(), do ui.update():\n\t//\t|\tdojo.connect(obj, \"onchange\", ui, \"update\");\n\t//\t|\tdojo.connect(obj, \"onchange\", ui, ui.update); // same\n\t//\n\t// example:\n\t//\t\tUsing return value for disconnect:\n\t//\t|\tvar link = dojo.connect(obj, \"onchange\", ui, \"update\");\n\t//\t|\t...\n\t//\t|\tdojo.disconnect(link);\n\t//\n\t// example:\n\t//\t\tWhen onglobalevent executes, watcher.handler is invoked:\n\t//\t|\tdojo.connect(null, \"onglobalevent\", watcher, \"handler\");\n\t//\n\t// example:\n\t//\t\tWhen ob.onCustomEvent executes, customEventHandler is invoked:\n\t//\t|\tdojo.connect(ob, \"onCustomEvent\", null, \"customEventHandler\");\n\t//\t|\tdojo.connect(ob, \"onCustomEvent\", \"customEventHandler\"); // same\n\t//\n\t// example:\n\t//\t\tWhen ob.onCustomEvent executes, customEventHandler is invoked\n\t//\t\twith the same scope (this):\n\t//\t|\tdojo.connect(ob, \"onCustomEvent\", null, customEventHandler);\n\t//\t|\tdojo.connect(ob, \"onCustomEvent\", customEventHandler); // same\n\t//\n\t// example:\n\t//\t\tWhen globalEvent executes, globalHandler is invoked\n\t//\t\twith the same scope (this):\n\t//\t|\tdojo.connect(null, \"globalEvent\", null, globalHandler);\n\t//\t|\tdojo.connect(\"globalEvent\", globalHandler); // same\n}\n=====*/\n\n/*=====\ndojo.disconnect = function(handle){\n\t// summary:\n\t//\t\tRemove a link created by dojo.connect.\n\t// description:\n\t//\t\tRemoves the connection between event and the method referenced by handle.\n\t// handle: Handle:\n\t//\t\tthe return value of the dojo.connect call that created the connection.\n}\n=====*/\n\n/*=====\ndojo.subscribe = function(topic, context, method){\n\t//\tsummary:\n\t//\t\tAttach a listener to a named topic. The listener function is invoked whenever the\n\t//\t\tnamed topic is published (see: dojo.publish).\n\t//\t\tReturns a handle which is needed to unsubscribe this listener.\n\t//\ttopic: String:\n\t//\t\tThe topic to which to subscribe.\n\t//\tcontext: Object|null:\n\t//\t\tScope in which method will be invoked, or null for default scope.\n\t//\tmethod: String|Function:\n\t//\t\tThe name of a function in context, or a function reference. This is the function that\n\t//\t\tis invoked when topic is published.\n\t//\texample:\n\t//\t|\tdojo.subscribe(\"alerts\", null, function(caption, message){ alert(caption + \"\\n\" + message); });\n\t//\t|\tdojo.publish(\"alerts\", [ \"read this\", \"hello world\" ]);\n}\n=====*/\n\n/*=====\ndojo.unsubscribe = function(handle){\n\t//\tsummary:\n\t//\t\tRemove a topic listener.\n\t//\thandle: Handle\n\t//\t\tThe handle returned from a call to subscribe.\n\t//\texample:\n\t//\t|\tvar alerter = dojo.subscribe(\"alerts\", null, function(caption, message){ alert(caption + \"\\n\" + message); };\n\t//\t|\t...\n\t//\t|\tdojo.unsubscribe(alerter);\n}\n=====*/\n\n/*=====\ndojo.publish = function(topic, args){\n\t//\tsummary:\n\t//\t\tInvoke all listener method subscribed to topic.\n\t//\ttopic: String:\n\t//\t\tThe name of the topic to publish.\n\t//\targs: Array?\n\t//\t\tAn array of arguments. The arguments will be applied\n\t//\t\tto each topic subscriber (as first class parameters, via apply).\n\t//\texample:\n\t//\t|\tdojo.subscribe(\"alerts\", null, function(caption, message){ alert(caption + \"\\n\" + message); };\n\t//\t|\tdojo.publish(\"alerts\", [ \"read this\", \"hello world\" ]);\n}\n=====*/\n\n/*=====\ndojo.connectPublisher = function(topic, obj, event){\n\t//\tsummary:\n\t//\t\tEnsure that every time obj.event() is called, a message is published\n\t//\t\ton the topic. Returns a handle which can be passed to\n\t//\t\tdojo.disconnect() to disable subsequent automatic publication on\n\t//\t\tthe topic.\n\t//\ttopic: String:\n\t//\t\tThe name of the topic to publish.\n\t//\tobj: Object|null:\n\t//\t\tThe source object for the event function. Defaults to kernel.global\n\t//\t\tif null.\n\t//\tevent: String:\n\t//\t\tThe name of the event function in obj.\n\t//\t\tI.e. identifies a property obj[event].\n\t//\texample:\n\t//\t|\tdojo.connectPublisher(\"/ajax/start\", dojo, \"xhrGet\");\n}\n=====*/\n\n/*=====\ndojo.isCopyKey = function(e){\n\t// summary:\n\t//\t\tChecks an event for the copy key (meta on Mac, and ctrl anywhere else)\n\t// e: Event\n\t//\t\tEvent object to examine\n}\n=====*/\n\n});\n\n\n\n}}});\n\n(function(){\n\t// must use this.require to make this work in node.js\n\tvar require = this.require;\n\t// consume the cached dojo layer\n\trequire({cache:{}});\n\t!require.async && require([\"dojo\"]);\n\trequire.boot && require.apply(null, require.boot);\n})();",
  "name": "idontknow",
  "interpreter": "javascript",
  "extension": "js"
}