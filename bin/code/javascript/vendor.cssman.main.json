{
  "code": "/*\n * Copyright (C) 2015 Pavel Savshenko\n * Copyright (C) 2011 Google Inc.  All rights reserved.\n * Copyright (C) 2007, 2008 Apple Inc.  All rights reserved.\n * Copyright (C) 2008 Matt Lilek <webkit@mattlilek.com>\n * Copyright (C) 2009 Joseph Pecoraro\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1.  Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n * 2.  Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n * 3.  Neither the name of Apple Computer, Inc. (\"Apple\") nor the names of\n *     its contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar UTILS = {};\n\nUTILS.cssPath = function(node, optimized)\n{\n    if (node.nodeType !== Node.ELEMENT_NODE)\n        return \"\";\n    var steps = [];\n    var contextNode = node;\n    while (contextNode) {\n        var step = UTILS._cssPathStep(contextNode, !!optimized, contextNode === node);\n        if (!step)\n            break; // Error - bail out early.\n        steps.push(step);\n        if (step.optimized)\n            break;\n        contextNode = contextNode.parentNode;\n    }\n    steps.reverse();\n    return steps.join(\" > \");\n}\nUTILS._cssPathStep = function(node, optimized, isTargetNode)\n{\n    if (node.nodeType !== Node.ELEMENT_NODE)\n        return null;\n\n    var id = node.getAttribute(\"id\");\n    if (optimized) {\n        if (id)\n            return new UTILS.DOMNodePathStep(idSelector(id), true);\n        var nodeNameLower = node.nodeName.toLowerCase();\n        if (nodeNameLower === \"body\" || nodeNameLower === \"head\" || nodeNameLower === \"html\")\n            return new UTILS.DOMNodePathStep(node.nodeName.toLowerCase(), true);\n \t}\n    var nodeName = node.nodeName.toLowerCase();\n\n    if (id)\n        return new UTILS.DOMNodePathStep(nodeName.toLowerCase() + idSelector(id), true);\n    var parent = node.parentNode;\n    if (!parent || parent.nodeType === Node.DOCUMENT_NODE)\n        return new UTILS.DOMNodePathStep(nodeName.toLowerCase(), true);\n\n    /**\n     * @param {UTILS.DOMNode} node\n     * @return {Array.<string>}\n     */\n    function prefixedElementClassNames(node)\n    {\n        var classAttribute = node.getAttribute(\"class\");\n        if (!classAttribute)\n            return [];\n\n        return classAttribute.split(/\\s+/g).filter(Boolean).map(function(name) {\n            // The prefix is required to store \"__proto__\" in a object-based map.\n            return \"$\" + name;\n        });\n     }\n\n    /**\n     * @param {string} id\n     * @return {string}\n     */\n    function idSelector(id)\n    {\n        return \"#\" + escapeIdentifierIfNeeded(id);\n    }\n\n    /**\n     * @param {string} ident\n     * @return {string}\n     */\n    function escapeIdentifierIfNeeded(ident)\n    {\n        if (isCSSIdentifier(ident))\n            return ident;\n        var shouldEscapeFirst = /^(?:[0-9]|-[0-9-]?)/.test(ident);\n        var lastIndex = ident.length - 1;\n        return ident.replace(/./g, function(c, i) {\n            return ((shouldEscapeFirst && i === 0) || !isCSSIdentChar(c)) ? escapeAsciiChar(c, i === lastIndex) : c;\n        });\n    }\n\n    /**\n     * @param {string} c\n     * @param {boolean} isLast\n     * @return {string}\n     */\n    function escapeAsciiChar(c, isLast)\n    {\n        return \"\\\\\" + toHexByte(c) + (isLast ? \"\" : \" \");\n    }\n\n    /**\n     * @param {string} c\n     */\n    function toHexByte(c)\n    {\n        var hexByte = c.charCodeAt(0).toString(16);\n        if (hexByte.length === 1)\n          hexByte = \"0\" + hexByte;\n        return hexByte;\n    }\n\n    /**\n     * @param {string} c\n     * @return {boolean}\n     */\n    function isCSSIdentChar(c)\n    {\n        if (/[a-zA-Z0-9_-]/.test(c))\n            return true;\n        return c.charCodeAt(0) >= 0xA0;\n    }\n\n    /**\n     * @param {string} value\n     * @return {boolean}\n     */\n    function isCSSIdentifier(value)\n    {\n        return /^-?[a-zA-Z_][a-zA-Z0-9_-]*$/.test(value);\n    }\n\n    var prefixedOwnClassNamesArray = prefixedElementClassNames(node);\n    var needsClassNames = false;\n    var needsNthChild = false;\n    var ownIndex = -1;\n    var siblings = parent.children;\n    for (var i = 0; (ownIndex === -1 || !needsNthChild) && i < siblings.length; ++i) {\n        var sibling = siblings[i];\n        if (sibling === node) {\n            ownIndex = i;\n            continue;\n        }\n        if (needsNthChild)\n            continue;\n        if (sibling.nodeName.toLowerCase() !== nodeName.toLowerCase())\n            continue;\n\n        needsClassNames = true;\n        var ownClassNames = prefixedOwnClassNamesArray;\n        var ownClassNameCount = 0;\n        for (var name in ownClassNames)\n            ++ownClassNameCount;\n        if (ownClassNameCount === 0) {\n            needsNthChild = true;\n            continue;\n        }\n        var siblingClassNamesArray = prefixedElementClassNames(sibling);\n        for (var j = 0; j < siblingClassNamesArray.length; ++j) {\n            var siblingClass = siblingClassNamesArray[j];\n            if (ownClassNames.indexOf(siblingClass))\n                continue;\n            delete ownClassNames[siblingClass];\n            if (!--ownClassNameCount) {\n                needsNthChild = true;\n                break;\n            }\n        }\n    }\n\n    var result = nodeName.toLowerCase();\n    if (isTargetNode && nodeName.toLowerCase() === \"input\" && node.getAttribute(\"type\") && !node.getAttribute(\"id\") && !node.getAttribute(\"class\"))\n        result += \"[type=\\\"\" + node.getAttribute(\"type\") + \"\\\"]\";\n    if (needsNthChild) {\n        result += \":nth-child(\" + (ownIndex + 1) + \")\";\n    } else if (needsClassNames) {\n        for (var prefixedName in prefixedOwnClassNamesArray)\n        // for (var prefixedName in prefixedOwnClassNamesArray.keySet())\n            result += \".\" + escapeIdentifierIfNeeded(prefixedOwnClassNamesArray[prefixedName].substr(1));\n    }\n\n    return new UTILS.DOMNodePathStep(result, false);\n}\n\n/**\n * @constructor\n * @param {string} value\n * @param {boolean} optimized\n */\nUTILS.DOMNodePathStep = function(value, optimized)\n{\n    this.value = value;\n    this.optimized = optimized || false;\n}\n\nUTILS.DOMNodePathStep.prototype = {\n    /**\n     * @return {string}\n     */\n    toString: function()\n    {\n        return this.value;\n    }\n}\n\nvar csspath = (UTILS.cssPath);\n//module.exports = UTILS.cssPath;",
  "name": "idontknow",
  "interpreter": "javascript",
  "extension": "js"
}