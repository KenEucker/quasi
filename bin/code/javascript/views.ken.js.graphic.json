{
  "code": "/// Modified from http://rectangleworld.com/demos/MorphingCurve/MorphingCurve_RadialGradient.html \n\n// RAF polyfill\n(function() {\n    var lastTime = 0;\n    var vendors = ['ms', 'moz', 'webkit', 'o'];\n    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];\n        window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame']\n                                   || window[vendors[x]+'CancelRequestAnimationFrame'];\n    }\n \n    if (!window.requestAnimationFrame)\n        window.requestAnimationFrame = function(callback, element) {\n            var currTime = new Date().getTime();\n            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n            var id = window.setTimeout(function() { callback(currTime + timeToCall); },\n              timeToCall);\n            lastTime = currTime + timeToCall;\n            return id;\n        };\n \n    if (!window.cancelAnimationFrame)\n        window.cancelAnimationFrame = function(id) {\n            clearTimeout(id);\n        };\n}());\n\nwindow.addEventListener(\"load\", windowLoadHandler, false);\n\n//for debug messages while testing code\nvar Debugger = function() { };\nDebugger.log = function(message) {\n\ttry {\n\t\tconsole.log(message);\n\t}\n\tcatch (exception) {\n\t\treturn;\n\t}\n}\n\nfunction windowLoadHandler() {\n    createGrowingCanvasGraphic(\"displayCanvas\", window.innerWidth, window.innerHeight);\n}\n\nfunction createGrowingCanvasGraphic(id, width, height, orientation = \"horizontal\") {\n    document.querySelector('html').attributes.class = \"js flexbox canvas canvastext webgl no-touch geolocation postmessage websqldatabase indexeddb hashchange history draganddrop websockets rgba hsla multiplebgs backgroundsize borderimage borderradius boxshadow textshadow opacity cssanimations csscolumns cssgradients cssreflections csstransforms csstransforms3d csstransitions fontface generatedcontent video audio localstorage sessionstorage webworkers applicationcache svg inlinesvg smil svgclippaths gr__rectangleworld_com\";\n    var div = document.createElement('div');\n    div.innerHTML = '<canvas id=\"' + id + '\" width=\"' + width + '\" height=\"' + height + '\">';\n    document.querySelector('body').appendChild(div.firstChild);\n\n\tcanvasApp(id, width, height, orientation);\n}\n\nfunction canvasSupport() {\n\treturn Modernizr.canvas;\n}\n\nfunction canvasApp(id, displayWidth = window.innerWidth, displayHeight = window.innerHeight, orientation) {\n\tif (!canvasSupport()) {\n\t\treturn;\n\t}\n\t\n\tvar displayCanvas = document.getElementById(id);\n\tvar context = displayCanvas.getContext(\"2d\");\n\t\n\t//off screen canvas used only when exporting image\n\tvar exportCanvas = document.createElement('canvas');\n\texportCanvas.width = displayWidth;\n\texportCanvas.height = displayHeight;\n\tvar exportCanvasContext = exportCanvas.getContext(\"2d\");\n\t\n\t//var exportImage = document.createElement('img');\n\t\n\t//buttons\n\t// var btnExport = document.getElementById(\"btnExport\");\n\t// btnExport.addEventListener(\"click\", exportPressed, false);\n\t\n\t// var btnRegenerate = document.getElementById(\"btnRegenerate\");\n\t// btnRegenerate.addEventListener(\"click\", regeneratePressed, false);\n\t\n\tvar numCircles;\n\tvar maxMaxRad;\n\tvar minMaxRad;\n\tvar minRadFactor;\n\tvar circles;\n\tvar iterations;\n\tvar timer;\n\tvar drawsPerFrame;\n\tvar drawCount;\n\tvar bgColor,urlColor;\n\tvar TWO_PI = 2*Math.PI;\n\tvar lineWidth;\n\t\n\tvar stop = false;\n\tvar frameCount = 0;\n\tvar fps, fpsInterval, startTime, now, then, elapsed;\n\n\tfunction startAnimating(fps) {\n\t\tfpsInterval = 1000 / fps;\n\t\tthen = Date.now();\n\t\tstartTime = then;\n\t\tconsole.log(startTime);\n\t\tanimate();\n\t}\n\n\n\tfunction animate() {\n\n\t\t// stop\n\t\tif (stop) {\n\t\t\treturn;\n\t\t}\n\n\t\t// request another frame\n\n\t\trequestAnimationFrame(animate);\n\n\t\t// calc elapsed time since last loop\n\n\t\tnow = Date.now();\n\t\telapsed = now - then;\n\n\t\t// if enough time has elapsed, draw the next frame\n\n\t\tif (elapsed > fpsInterval) {\n\n\t\t\t// Get ready for next frame by setting then=now, but...\n\t\t\t// Also, adjust for fpsInterval not being multiple of 16.67\n\t\t\tthen = now - (elapsed % fpsInterval);\n\n\t\t\t// draw stuff here\n\t\t\tdraw();\n\n\t\t\t// TESTING...Report #seconds since start and achieved fps.\n\t\t\t// var sinceStart = now - startTime;\n\t\t\t// var currentFps = Math.round(1000 / (sinceStart / ++frameCount) * 100) / 100;\n\t\t\t// $results.text(\"Elapsed time= \" + Math.round(sinceStart / 1000 * 100) / 100 + \" secs @ \" + currentFps + \" fps.\");\n\n\t\t}\n\t}\n\n\tinit();\n\t\n\tfunction init() {\n\t\t/*\n\t\tIn other experiments, you may wish to use more fractal curves (\"circles\")\n\t\tand allow the radius of them to vary. If so, modify the next three variables.\n\t\t*/\n\t\tnumCircles = 1;\n\t\tmaxMaxRad = 200;\n\t\tminMaxRad = 200;\n\t\t\n\t\t/*\n\t\tWe draw closed curves with varying radius. The factor below should be set between 0 and 1,\n\t\trepresenting the size of the smallest radius with respect to the largest possible.\n\t\t*/ \n\t\tminRadFactor = 0;\n\t\t\n\t\t/*\n\t\tThe number of subdividing steps to take when creating a single fractal curve. \n\t\tCan use more, but anything over 10 (thus 1024 points) is overkill for a moderately sized canvas.\n\t\t*/\n\t\titerations = 8;\n\t\t\n\t\t//number of curves to draw on every tick of the timer\n\t\tdrawsPerFrame = 4;\n\t\t\n\t\tbgColor = \"#FFFFFF\";\n\t\turlColor = \"#EEEEEE\";\n\t\t\n\t\tlineWidth = 1.01;\n\n\t\tdrawCount = 0;\n\t\tcontext.setTransform(1,0,0,1,0,0);\n\t\t\n\t\tcontext.clearRect(0,0,displayWidth,displayHeight);\n\t\t\n\t\tsetCircles();\n\t\t\n        startAnimating(1);\n\t}\n\t\n    function animLoop( render, element ) {\n        var running, lastFrame = +new Date,\n            raf = window.mozRequestAnimationFrame    ||\n                window.webkitRequestAnimationFrame ||\n                window.msRequestAnimationFrame     ||\n                window.oRequestAnimationFrame;\n        function loop( now ) {\n            // stop the loop if render returned false\n            if ( running !== false ) {\n                raf( loop, element );\n                var deltaT = now - lastFrame;\n                if ( deltaT < 160 ) {\n                    running = render( deltaT );\n                }\n                lastFrame = now;\n            }\n        }\n        loop( lastFrame );\n    }\n\t\n\tfunction setCircles() {\n\t\tvar i;\n\t\tvar r,g,b,a;\n\t\tvar maxR, minR;\n\t\tvar grad;\n\t\t\n\t\tcircles = [];\n\t\t\n\t\tfor (i = 0; i < numCircles; i++) {\n\t\t\tmaxR = minMaxRad+Math.random()*(maxMaxRad-minMaxRad);\n\t\t\tminR = minRadFactor*maxR;\n\t\t\t\n\t\t\t//define gradient\n            /// BLUE\n\t\t\t// grad = context.createRadialGradient(0,0,minR,0,0,maxR);\n\t\t\t// grad.addColorStop(1,\"rgba(0,170,200,0.2)\");\n\t\t\t// grad.addColorStop(0,\"rgba(0,20,170,0.2)\");\n\n            /// BLUE WITH PURPLE\n\t\t\tgrad = context.createRadialGradient(0,0,0.9*minR,0,0,0.9*maxR);\n\t\t\tgrad.addColorStop(1,\"rgba(0,100,200,0.2)\");\n\t\t\tgrad.addColorStop(0.5,\"rgba(200,0,200,0.2)\");\n\t\t\tgrad.addColorStop(0,\"rgba(200,0,0,0.2)\");\n\t\t\t\n\t\t\tvar newCircle = {\n\t\t\t\tcenterX: -maxR,\n\t\t\t\tcenterY: displayHeight/2-50,\n\t\t\t\tmaxRad : maxR,\n\t\t\t\tminRad : minR,\n\t\t\t\tcolor: grad, //can set a gradient or solid color here.\n\t\t\t\t//fillColor: \"rgba(0,0,0,1)\",\n\t\t\t\tparam : 0,\n\t\t\t\tchangeSpeed : 1/250,\n\t\t\t\tphase : Math.random()*TWO_PI, //the phase to use for a single fractal curve.\n\t\t\t\tglobalPhase: Math.random()*TWO_PI //the curve as a whole will rise and fall by a sinusoid.\n\t\t\t\t};\n\t\t\tcircles.push(newCircle);\n\t\t\tnewCircle.pointList1 = setLinePoints(iterations);\n\t\t\tnewCircle.pointList2 = setLinePoints(iterations);\n\t\t}\n\t}\n\t\n\tfunction draw() {\n        //timer = setTimeout(function() {\n            var i,j;\n            var c;\n            var rad;\n            var point1,point2;\n            var x0,y0;\n            var cosParam;\n            \n            var xSqueeze = 0.75; //cheap 3D effect by shortening in x direction.\n            \n            var yOffset;\n            \n            //draw circles\n            for (j = 0; j < drawsPerFrame; j++) {\n                \n                drawCount++;\n                \n                for (i = 0; i < numCircles; i++) {\n                    c = circles[i];\n                    c.param += c.changeSpeed;\n                    if (c.param >= 1) {\n                        c.param = 0;\n                        \n                        c.pointList1 = c.pointList2;\n                        c.pointList2 = setLinePoints(iterations);\n                    }\n                    cosParam = 0.5-0.5*Math.cos(Math.PI*c.param);\n                    \n                    context.strokeStyle = c.color;\n                    context.lineWidth = lineWidth;\n                    //context.fillStyle = c.fillColor;\n                    context.beginPath();\n                    point1 = c.pointList1.first;\n                    point2 = c.pointList2.first;\n                    \n                    //slowly rotate\n                    c.phase += 0.0002;\n                    \n                    theta = c.phase;\n                    rad = c.minRad + (point1.y + cosParam*(point2.y-point1.y))*(c.maxRad - c.minRad);\n                    \n                    //move center\n                    c.centerX += 0.5;\n                    c.centerY += 0.04;\n                    yOffset = 40*Math.sin(c.globalPhase + drawCount/1000*TWO_PI);\n                    //stop when off screen\n                    if (c.centerX > displayWidth + maxMaxRad) {\n                        // clearTimeout(timer);\n                        // timer = null;\n\t\t\t\t\t\treturn;\n                    }\n                    \n                    //we are drawing in new position by applying a transform. We are doing this so the gradient will move with the drawing.\n                    context.setTransform(xSqueeze,0,0,1,c.centerX,c.centerY+yOffset)\n                    \n                    //Drawing the curve involves stepping through a linked list of points defined by a fractal subdivision process.\n                    //It is like drawing a circle, except with varying radius.\n                    x0 = xSqueeze*rad*Math.cos(theta);\n                    y0 = rad*Math.sin(theta);\n                    context.lineTo(x0, y0);\n                    while (point1.next != null) {\n                        point1 = point1.next;\n                        point2 = point2.next;\n                        theta = TWO_PI*(point1.x + cosParam*(point2.x-point1.x)) + c.phase;\n                        rad = c.minRad + (point1.y + cosParam*(point2.y-point1.y))*(c.maxRad - c.minRad);\n                        x0 = xSqueeze*rad*Math.cos(theta);\n                        y0 = rad*Math.sin(theta);\n                        context.lineTo(x0, y0);\n                    }\n                    context.closePath();\n                    context.stroke();\n                    //context.fill();\t\t\n                        \n                }\n            }\n        //}, 1000 / 15);    \n        requestAnimationFrame(draw);        \n\t}\n\t\t\n\t//Here is the function that defines a noisy (but not wildly varying) data set which we will use to draw the curves.\n\tfunction setLinePoints(iterations) {\n\t\tvar pointList = {};\n\t\tpointList.first = {x:0, y:1};\n\t\tvar lastPoint = {x:1, y:1}\n\t\tvar minY = 1;\n\t\tvar maxY = 1;\n\t\tvar point;\n\t\tvar nextPoint;\n\t\tvar dx, newX, newY;\n\t\tvar ratio;\n\t\t\n\t\tvar minRatio = 0.5;\n\t\t\t\t\n\t\tpointList.first.next = lastPoint;\n\t\tfor (var i = 0; i < iterations; i++) {\n\t\t\tpoint = pointList.first;\n\t\t\twhile (point.next != null) {\n\t\t\t\tnextPoint = point.next;\n\t\t\t\t\n\t\t\t\tdx = nextPoint.x - point.x;\n\t\t\t\tnewX = 0.5*(point.x + nextPoint.x);\n\t\t\t\tnewY = 0.5*(point.y + nextPoint.y);\n\t\t\t\tnewY += dx*(Math.random()*2 - 1);\n\t\t\t\t\n\t\t\t\tvar newPoint = {x:newX, y:newY};\n\t\t\t\t\n\t\t\t\t//min, max\n\t\t\t\tif (newY < minY) {\n\t\t\t\t\tminY = newY;\n\t\t\t\t}\n\t\t\t\telse if (newY > maxY) {\n\t\t\t\t\tmaxY = newY;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//put between points\n\t\t\t\tnewPoint.next = nextPoint;\n\t\t\t\tpoint.next = newPoint;\n\t\t\t\t\n\t\t\t\tpoint = nextPoint;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//normalize to values between 0 and 1\n\t\tif (maxY != minY) {\n\t\t\tvar normalizeRate = 1/(maxY - minY);\n\t\t\tpoint = pointList.first;\n\t\t\twhile (point != null) {\n\t\t\t\tpoint.y = normalizeRate*(point.y - minY);\n\t\t\t\tpoint = point.next;\n\t\t\t}\n\t\t}\n\t\t//unlikely that max = min, but could happen if using zero iterations. In this case, set all points equal to 1.\n\t\telse {\n\t\t\tpoint = pointList.first;\n\t\t\twhile (point != null) {\n\t\t\t\tpoint.y = 1;\n\t\t\t\tpoint = point.next;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn pointList;\t\t\n\t}\n\t\t\n\tfunction exportPressed(evt) {\n\t\t//background - otherwise background will be transparent.\n\t\texportCanvasContext.fillStyle = bgColor;\n\t\texportCanvasContext.fillRect(0,0,displayWidth,displayHeight);\n\t\t\n\t\t//draw\n\t\texportCanvasContext.drawImage(displayCanvas, 0,0,displayWidth,displayHeight,0,0,displayWidth,displayHeight);\n\t\t\n\t\t//add printed url to image\n\t\texportCanvasContext.fillStyle = urlColor;\n\t\texportCanvasContext.font = 'bold italic 16px Helvetica, Arial, sans-serif';\n\t\texportCanvasContext.textBaseline = \"top\";\n\t\tvar metrics = exportCanvasContext.measureText(\"rectangleworld.com\");\n\t\texportCanvasContext.fillText(\"rectangleworld.com\", displayWidth - metrics.width - 10, 5);\n\t\t\n\t\t//we will open a new window with the image contained within:\t\t\n\t\t//retrieve canvas image as data URL:\n\t\tvar dataURL = exportCanvas.toDataURL(\"image/png\");\n\t\t//open a new window of appropriate size to hold the image:\n\t\tvar imageWindow = window.open(\"\", \"fractalLineImage\", \"left=0,top=0,width=\"+displayWidth+\",height=\"+displayHeight+\",toolbar=0,resizable=0\");\n\t\t//write some html into the new window, creating an empty image:\n\t\timageWindow.document.write(\"<title>Export Image</title>\")\n\t\timageWindow.document.write(\"<img id='exportImage'\"\n\t\t\t\t\t\t\t\t\t+ \" alt=''\"\n\t\t\t\t\t\t\t\t\t+ \" height='\" + displayHeight + \"'\"\n\t\t\t\t\t\t\t\t\t+ \" width='\"  + displayWidth  + \"'\"\n\t\t\t\t\t\t\t\t\t+ \" style='position:absolute;left:0;top:0'/>\");\n\t\timageWindow.document.close();\n\t\t//copy the image into the empty img in the newly opened window:\n\t\tvar exportImage = imageWindow.document.getElementById(\"exportImage\");\n\t\texportImage.src = dataURL;\n\t}\t\n}",
  "name": "idontknow",
  "interpreter": "html",
  "extension": "html",
  "scripts": {
    "headStart": ["<link rel='stylesheet' href='index.css'>"],
    "headEnd": [],
    "bodyStart": [],
    "bodyEnd": []
  }
}