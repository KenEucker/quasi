{
  "code": "/*! Sly v1.0rc2 <http://sly.digitarald.com> - (C) 2009 Harald Kirschner <http://digitarald.de> - Open source under MIT License */\n\n/**\n * Credits\n * \n * Sly's code and pattern are inspired by several open source developers.\n * \n * Valerio Proietti & MooTools contributors\n *  - Idea of modular combinator and pseudo filters\n *  - Code for several pseudo filters\n *  - Slickspeed benchmark framework\n * Steven Levithan\n *  - Improved Sly.parse expression\n * Diego Perini\n *  - Research on querySelectorAll and browser quirks\n *  - Patches for Sly.parse expression\n *  - Combined tests from jQuery and Prototype\n * Thomas Aylott & Slick contributors\n *   - Idea of using regular expressions in attribute filter.\n * John Resig & jQuery/Sizzle contributors\n *  - Browser feature/quirks detection\n *  - Additional pseudo filters\n *  - Extensive Unit Tests, (c) 2008 John Resig, Jörn Zaefferer, MIT/GPL dual license\n * Sam Stephenson & Prototype contributors\n *  - Extensive Unit Tests, (c) 2005-2008 Sam Stephenson, MIT-style license\n * Alan Kang & JSSpec contributors\n *  - JSSpec BDD framework\n * \n * Kudos to every single one of them for supporting the open web.\n */\n\nvar Sly = (function() {\n\nvar cache = {};\n\n/**\n * Sly::constructor\n * \n * Acts also as shortcut for Sly::search if context argument is given.\n */\nvar Sly = function(text, context, results, options) {\n\t// normalise\n\ttext = (typeof(text) == 'string') ? text.replace(/^\\s+|\\s+$/, '') : '';\n\t\n\tvar cls = cache[text] || (cache[text] = new Sly.initialize(text));\n\treturn (context == null) ? cls : cls.search(context, results, options);\n};\n\nSly.initialize = function(text) {\n\tthis.text = text;\n};\n\nvar proto = Sly.initialize.prototype = Sly.prototype;\n\n\n/**\n * Sly.implement\n */\nSly.implement = function(key, properties) {\n\tfor (var prop in properties) Sly[key][prop] = properties[prop];\n};\n\n\n/**\n * Sly.support\n *\n * Filled with experiment results.\n */\nvar support = Sly.support = {};\n\n// Checks similar to NWMatcher, Sizzle\n(function() {\n\t\n\t// Our guinea pig\n\tvar testee = document.createElement('div'), id = (new Date()).getTime();\n\ttestee.innerHTML = '<a name=\"' + id + '\" class=\"€ b\"></a>';\n\ttestee.appendChild(document.createComment(''));\n\t\n\t// IE returns comment nodes for getElementsByTagName('*')\n\tsupport.byTagAddsComments = (testee.getElementsByTagName('*').length > 1);\n\t\n\t// Safari can't handle uppercase or unicode characters when in quirks mode.\n\tsupport.hasQsa = !!(testee.querySelectorAll && testee.querySelectorAll('.€').length);\n\t\n\tsupport.hasByClass = (function() {\n\t\tif (!testee.getElementsByClassName || !testee.getElementsByClassName('b').length) return false;\n\t\ttestee.firstChild.className = 'c';\n\t\treturn (testee.getElementsByClassName('c').length == 1);\n\t})();\n\t\n\tvar root = document.documentElement;\n\troot.insertBefore(testee, root.firstChild);\n\t\n\t// IE returns named nodes for getElementById(name)\n\tsupport.byIdAddsName = !!(document.getElementById(id));\n\t\n\troot.removeChild(testee);\n\t\n})();\n\n\nvar locateFast = function() {\n\treturn true;\n};\n\n/**\n * Sly::search\n */\nproto.search = function(context, results, options) {\n\toptions = options || {};\n\t\n\tvar iterate, i, item;\n\n\tif (!context) {\n\t\tcontext = document;\n\t} else if (context.nodeType != 1 && context.nodeType != 9) {\n\t\tif (typeof(context) == 'string') {\n\t\t\tcontext = Sly.search(context);\n\t\t\titerate = true;\n\t\t} else if (Object.prototype.toString.call(context) == '[object Array]' || (typeof(context.length) == 'number' && context.item)) { // simple isArray\n\t\t\tvar filtered = [];\n\t\t\tfor (i = 0; (item = context[i]); i++) {\n\t\t\t\tif (item.nodeType == 1 || item.nodeType == 9) filtered.push(item);\n\t\t\t}\n\t\t\titerate = (filtered.length > 1);\n\t\t\tcontext = (iterate) ? filtered : (filtered[0] || document);\n\t\t}\n\t}\n\t\n\tvar mixed, // results need to be sorted, comma\n\t\tcombined, // found nodes from one iteration process\n\t\tnodes, // context nodes from one iteration process\n\t\tall = {}, // unique ids for overall result\n\t\tstate = {}; // matchers temporary state\n\tvar current = all; // unique ids for one iteration process\n\n\t// unifiers\n\tvar getUid = Sly.getUid;\n\tvar locateCurrent = function(node) {\n\t\tvar uid = getUid(node);\n\t\treturn (current[uid]) ? null : (current[uid] = true);\n\t};\n\t\n\tif (results && results.length) { // fills unique ids, does not alter the given results\n\t\tfor (i = 0; (item = results[i]); i++) locateCurrent(item);\n\t}\n\n\tif (support.hasQsa && !iterate && context.nodeType == 9 && !(/\\[/).test(this.text)) {\n\t\ttry {\n\t\t\tvar query = context.querySelectorAll(this.text);\n\t\t} catch(e) {}\n\t\tif (query) {\n\t\t\tif (!results) return Sly.toArray(query);\n\t\t\tfor (i = 0; (item = query[i]); i++) {\n\t\t\t\tif (locateCurrent(item)) results.push(item);\n\t\t\t}\n\t\t\tif (!options.unordered) results.sort(Sly.compare);\n\t\t\treturn results;\n\t\t}\n\t}\n\n\tvar parsed = this.parse();\n\tif (!parsed.length) return [];\n\n\tfor (var i = 0, selector; (selector = parsed[i]); i++) {\n\n\t\tvar locate = locateCurrent;\n\n\t\tif (selector.first) {\n\t\t\tif (!results) locate = locateFast;\n\t\t\telse mixed = true;\n\t\t\tif (iterate) nodes = context;\n\t\t\telse if (selector.combinator) nodes = [context]; // allows combinators before selectors\n\t\t}\n\n\t\tif (selector.last && results) {\n\t\t\tcurrent = all;\n\t\t\tcombined = results;\n\t\t} else {\n\t\t\t// default stack\n\t\t\tcurrent = {};\n\t\t\tcombined = [];\n\t\t}\n\n\t\tif (!selector.combinator && !iterate) {\n\t\t\t// without prepended combinator\n\t\t\tcombined = selector.combine(combined, context, selector, state, locate, !(combined.length));\n\t\t} else {\n\t\t\t// with prepended combinators\n\t\t\tfor (var k = 0, l = nodes.length; k < l; k++) {\n\t\t\t\tcombined = selector.combine(combined, nodes[k], selector, state, locate);\n\t\t\t}\n\t\t}\n\n\t\tif (selector.last) {\n\t\t\tif (combined.length) results = combined;\n\t\t} else {\n\t\t\tnodes = combined;\n\t\t}\n\t}\n\n\tif (!options.unordered && mixed && results) results.sort(Sly.compare);\n\n\treturn results || [];\n};\n\n/**\n * Sly::find\n */\nproto.find = function(context, results, options) {\n\treturn this.search(context, results, options)[0];\n};\n\n\n/**\n * Sly::match\n */\nproto.match = function(node, parent) {\n\tvar parsed = this.parse();\n\tif (parsed.length == 1) return !!(this.parse()[0].match(node, {}));\n\tif (!parent) {\n\t\tparent = node;\n\t\twhile (parent.parentNode) parent = parent.parentNode\n\t}\n\tvar found = this.search(parent), i = found.length;\n\tif (!i--) return false;\n\twhile (i--) {\n\t\tif (found[i] == node) return true;\n\t}\n\treturn false;\n};\n\n\n/**\n * Sly::filter\n */\nproto.filter = function(nodes) {\n\tvar results = [], match = this.parse()[0].match;\n\tfor (var i = 0, node; (node = nodes[i]); i++) {\n\t\tif (match(node)) results.push(node);\n\t}\n\treturn results;\n};\n\n\n/**\n * Sly.recompile()\n */\nvar pattern;\n\nSly.recompile = function() {\n\n\tvar key, combList = [','], operList = ['!'];\n\n\tfor (key in combinators) {\n\t\tif (key != ' ') {\n\t\t\tcombList[(key.length > 1) ? 'unshift' : 'push'](Sly.escapeRegExp(key));\n\t\t}\n\t}\n\tfor (key in operators) operList.push(key);\n\n\t/**\n\t\tThe regexp is a group of every possible selector part including combinators.\n\t\t\"|\" separates the possible selectors.\n\n\t\tCapturing parentheses:\n\t\t1 - Combinator (only requires to allow multiple-character combinators)\n\t\t2 - Attribute name\n\t\t3 - Attribute operator\n\t\t4, 5, 6 - The value\n\t\t7 - Pseudo name\n\t\t8, 9, 10 - The value\n\t */\n\n\tpattern = new RegExp(\n\t\t// A tagname\n\t\t'[\\\\w\\\\u00a1-\\\\uFFFF][\\\\w\\\\u00a1-\\\\uFFFF-]*|' +\n\n\t\t// An id or the classname\n\t\t'[#.](?:[\\\\w\\\\u00a1-\\\\uFFFF-]|\\\\\\\\:|\\\\\\\\.)+|' +\n\n\t\t// Whitespace (descendant combinator)\n\t\t'[ \\\\t\\\\r\\\\n\\\\f](?=[\\\\w\\\\u00a1-\\\\uFFFF*#.[:])|' +\n\n\t\t// Other combinators and the comma\n\t\t'[ \\\\t\\\\r\\\\n\\\\f]*(' + combList.join('|') + ')[ \\\\t\\\\r\\\\n\\\\f]*|' +\n\n\t\t// An attribute, with the various and optional value formats ([name], [name=value], [name=\"value\"], [name='value']\n\t\t'\\\\[([\\\\w\\\\u00a1-\\\\uFFFF-]+)[ \\\\t\\\\r\\\\n\\\\f]*(?:([' + operList.join('') + ']?=)[ \\\\t\\\\r\\\\n\\\\f]*(?:\"([^\"]*)\"|\\'([^\\']*)\\'|([^\\\\]]*)))?]|' +\n\n\t\t// A pseudo-class, with various formats\n\t\t':([-\\\\w\\\\u00a1-\\\\uFFFF]+)(?:\\\\((?:\"([^\"]*)\"|\\'([^\\']*)\\'|([^)]*))\\\\))?|' +\n\n\t\t// The universial selector, not process\n\t\t'\\\\*|(.+)', 'g'\n\t);\n};\n\n\n// I prefer it outside, not sure if this is faster\nvar create = function(combinator) {\n\treturn {\n\t\tident: [],\n\t\tclasses: [],\n\t\tattributes: [],\n\t\tpseudos: [],\n\t\tcombinator: combinator\n\t};\n};\n\nvar blank = function($0) {\n\treturn $0;\n};\n\n/**\n * Sly::parse\n *\n * Returns an array with one object for every selector:\n *\n * {\n *   tag: (String) Tagname (defaults to null for universal *)\n *   id: (String) Id\n *   classes: (Array) Classnames\n *   attributes: (Array) Attribute objects with \"name\", \"operator\" and \"value\"\n *   pseudos: (Array) Pseudo objects with \"name\" and \"value\"\n *   operator: (Char) The prepended operator (not comma)\n *   first: (Boolean) true if it is the first selector or the first after a comma\n *   last: (Boolean) true if it is the last selector or the last before a comma\n *   ident: (Array) All parsed matches, can be used as cache identifier.\n * }\n */\nproto.parse = function(plain) {\n\tvar save = (plain) ? 'plain' : 'parsed';\n\tif (this[save]) return this[save];\n\t\n\tvar text = this.text;\n\tvar compute = (plain) ? blank : this.compute;\n\n\tvar parsed = [], current = create(null);\n\tcurrent.first = true;\n\n\tvar refresh = function(combinator) {\n\t\tparsed.push(compute(current));\n\t\tcurrent = create(combinator);\n\t};\n\n\tpattern.lastIndex = 0; // to fix some weird behavior\n\tvar match, $0;\n\t\n\twhile ((match = pattern.exec(text))) {\n\t\t\n\t\tif (match[11]) {\n\t\t\tif (Sly.verbose) throw SyntaxError('Syntax error, \"' + $0 + '\" unexpected at #' + pattern.lastIndex + ' in \"' + text + '\"');\n\t\t\treturn (this[save] = []);\n\t\t}\n\t\t\n\t\t$0 = match[0];\n\t\t\n\t\tswitch ($0.charAt(0)) {\n\t\t\tcase '.':\n\t\t\t\tcurrent.classes.push($0.slice(1).replace(/\\\\/g, ''));\n\t\t\t\tbreak;\n\t\t\tcase '#':\n\t\t\t\tcurrent.id = $0.slice(1).replace(/\\\\/g, '');\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tcurrent.attributes.push({\n\t\t\t\t\tname: match[2],\n\t\t\t\t\toperator: match[3] || null,\n\t\t\t\t\tvalue: match[4] || match[5] || match[6] || null\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase ':':\n\t\t\t\tcurrent.pseudos.push({\n\t\t\t\t\tname: match[7],\n\t\t\t\t\tvalue: match[8] || match[9] || match[10] || null\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase ' ': case '\\t': case '\\r': case '\\n': case '\\f':\n\t\t\t\tmatch[1] = match[1] || ' ';\n\t\t\tdefault:\n\t\t\t\tvar combinator = match[1];\n\t\t\t\tif (combinator) {\n\t\t\t\t\tif (combinator == ',') {\n\t\t\t\t\t\tcurrent.last = true;\n\t\t\t\t\t\trefresh(null);\n\t\t\t\t\t\tcurrent.first = true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (current.first && !current.ident.length) current.combinator = combinator;\n\t\t\t\t\telse refresh(combinator);\n\t\t\t\t} else {\n\t\t\t\t\tif ($0 != '*') current.tag = $0;\n\t\t\t\t}\n\t\t}\n\t\tcurrent.ident.push($0);\n\t}\n\n\tcurrent.last = true;\n\tparsed.push(compute(current));\n\n\treturn (this[save] = parsed);\n};\n\n\n// chains two given functions\n\nfunction chain(prepend, append, aux, unshift) {\n\treturn (prepend) ? ((unshift) ? function(node, state) {\n\t\treturn append(node, aux, state) && prepend(node, state);\n\t} : function(node, state) {\n\t\treturn prepend(node, state) && append(node, aux, state);\n\t}) : function(node, state) {\n\t\treturn append(node, aux, state);\n\t};\n\t// fn.$slyIndex = (prepend) ? (prepend.$slyIndex + 1) : 0;\n};\n\n\n// prepared match comperators, probably needs namespacing\nvar empty = function() {\n\treturn true;\n};\n\nvar matchId = function(node, id) {\n\treturn (node.id == id);\n};\n\nvar matchTag = function(node, tag) {\n\treturn (node.nodeName.toUpperCase() == tag);\n};\n\nvar prepareClass = function(name) {\n\treturn (new RegExp('(?:^|[ \\\\t\\\\r\\\\n\\\\f])' + name + '(?:$|[ \\\\t\\\\r\\\\n\\\\f])'));\n};\n\nvar matchClass = function(node, expr) {\n\treturn node.className && expr.test(node.className);\n};\n\nvar prepareAttribute = function(attr) {\n\tattr.getter = Sly.lookupAttribute(attr.name) || Sly.getAttribute;\n\tif (!attr.operator || !attr.value) return attr;\n\tvar parser = operators[attr.operator];\n\tif (parser) { // @todo: Allow functions, not only regex\n\t\tattr.escaped = Sly.escapeRegExp(attr.value);\n\t\tattr.pattern = new RegExp(parser(attr.value, attr.escaped, attr));\n\t}\n\treturn attr;\n};\n\nvar matchAttribute = function(node, attr) {\n\tvar read = attr.getter(node, attr.name);\n\tswitch (attr.operator) {\n\t\tcase null: return read;\n\t\tcase '=': return (read == attr.value);\n\t\tcase '!=': return (read != attr.value);\n\t}\n\tif (!read && attr.value) return false;\n\treturn attr.pattern.test(read);\n};\n\n\n/**\n * Sly::compute\n *\n * Attaches the following methods to the selector object:\n *\n * {\n *   search: Uses the most convinient properties (id, tag and/or class) of the selector as search.\n *   matchAux: If search does not contain all selector properties, this method matches an element against the rest.\n *   match: Matches an element against all properties.\n *   simple: Set when matchAux is not needed.\n *   combine: The callback for the combinator\n * }\n */\nproto.compute = function(selector) {\n\n\tvar i, item, match, search, matchSearch, tagged,\n\t\ttag = selector.tag,\n\t\tid = selector.id,\n\t\tclasses = selector.classes;\n\n\tvar nodeName = (tag) ? tag.toUpperCase() : null;\n\n\tif (id) {\n\t\ttagged = true;\n\n\t\tmatchSearch = chain(null, matchId, id);\n\n\t\tsearch = function(context) {\n\t\t\tif (context.getElementById) {\n\t\t\t\tvar el = context.getElementById(id);\n\t\t\t\treturn (el\n\t\t\t\t\t&& (!nodeName || el.nodeName.toUpperCase() == nodeName)\n\t\t\t\t\t&& (!support.getIdAdds || el.id == id))\n\t\t\t\t\t\t? [el]\n\t\t\t\t\t\t: [];\n\t\t\t}\n\n\t\t\tvar query = context.getElementsByTagName(tag || '*');\n\t\t\tfor (var j = 0, node; (node = query[j]); j++) {\n\t\t\t\tif (node.id == id) return [node];\n\t\t\t}\n\t\t\treturn [];\n\t\t};\n\t}\n\n\tif (classes.length > 0) {\n\n\t\tif (!search && support.hasByClass) {\n\n\t\t\tfor (i = 0; (item = classes[i]); i++) {\n\t\t\t\tmatchSearch = chain(matchSearch, matchClass, prepareClass(item));\n\t\t\t}\n\n\t\t\tvar joined = classes.join(' ');\n\t\t\tsearch = function(context) {\n\t\t\t\treturn context.getElementsByClassName(joined);\n\t\t\t};\n\n\t\t} else if (!search && classes.length == 1) { // optimised for typical .one-class-only\n\n\t\t\ttagged = true;\n\n\t\t\tvar expr = prepareClass(classes[0]);\n\t\t\tmatchSearch = chain(matchSearch, matchClass, expr);\n\n\t\t\tsearch = function(context) {\n\t\t\t\tvar query = context.getElementsByTagName(tag || '*');\n\t\t\t\tvar found = [];\n\t\t\t\tfor (var i = 0, node; (node = query[i]); i++) {\n\t\t\t\t\tif (node.className && expr.test(node.className)) found.push(node);\n\t\t\t\t}\n\t\t\t\treturn found;\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tfor (i = 0; (item = classes[i]); i++) {\n\t\t\t\tmatch = chain(match, matchClass, prepareClass(item));\n\t\t\t}\n\n\t\t}\n\t}\n\n\tif (tag) {\n\n\t\tif (!search) {\n\t\t\tmatchSearch = chain(matchSearch, matchTag, nodeName);\n\n\t\t\tsearch = function(context) {\n\t\t\t\treturn context.getElementsByTagName(tag);\n\t\t\t};\n\t\t} else if (!tagged) { // search does not filter by tag yet\n\t\t\tmatch = chain(match, matchTag, nodeName);\n\t\t}\n\n\t} else if (!search) { // default engine\n\n\t\tsearch = function(context) {\n\t\t\tvar query = context.getElementsByTagName('*');\n\t\t\tif (!support.byTagAddsComments) return query;\n\t\t\tvar found = [];\n\t\t\tfor (var i = 0, node; (node = query[i]); i++) {\n\t\t\t\tif (node.nodeType === 1) found.push(node);\n\t\t\t}\n\t\t\treturn found;\n\t\t};\n\n\t}\n\n\tfor (i = 0; (item = selector.pseudos[i]); i++) {\n\n\t\tif (item.name == 'not') { // optimised :not(), fast as possible\n\t\t\tvar not = Sly(item.value);\n\t\t\tmatch = chain(match, function(node, not) {\n\t\t\t\treturn !not.match(node);\n\t\t\t}, (not.parse().length == 1) ? not.parsed[0] : not);\n\t\t} else {\n\t\t\tvar parser = pseudos[item.name];\n\t\t\tif (parser) match = chain(match, parser, item.value);\n\t\t}\n\n\t}\n\n\tfor (i = 0; (item = selector.attributes[i]); i++) {\n\t\tmatch = chain(match, matchAttribute, prepareAttribute(item));\n\t}\n\n\tif ((selector.simple = !(match))) {\n\t\tselector.matchAux = empty;\n\t} else {\n\t\tselector.matchAux = match;\n\t\tmatchSearch = chain(matchSearch, match);\n\t}\n\n\tselector.match = matchSearch || empty;\n\n\tselector.combine = Sly.combinators[selector.combinator || ' '];\n\n\tselector.search = search;\n\n\treturn selector;\n};\n\n// Combinators/Pseudos partly from MooTools 1.2-pre, (c) 2006-2009 Valerio Proietti, MIT License\n\n/**\n * Combinators\n */\nvar combinators = Sly.combinators = {\n\n\t' ': function(combined, context, selector, state, locate, fast) {\n\t\tvar nodes = selector.search(context);\n\t\tif (fast && selector.simple) return Sly.toArray(nodes);\n\t\tfor (var i = 0, node, aux = selector.matchAux; (node = nodes[i]); i++) {\n\t\t\tif (locate(node) && aux(node, state)) combined.push(node);\n\t\t}\n\t\treturn combined;\n\t},\n\n\t'>': function(combined, context, selector, state, locate) {\n\t\tvar nodes = selector.search(context);\n\t\tfor (var i = 0, node; (node = nodes[i]); i++) {\n\t\t\tif (node.parentNode == context && locate(node) && selector.matchAux(node, state)) combined.push(node);\n\t\t}\n\t\treturn combined;\n\t},\n\n\t'+': function(combined, context, selector, state, locate) {\n\t\twhile ((context = context.nextSibling)) {\n\t\t\tif (context.nodeType == 1) {\n\t\t\t\tif (locate(context) && selector.match(context, state)) combined.push(context);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\treturn combined;\n\t},\n\n\t'~': function(combined, context, selector, state, locate) {\n\t\twhile ((context = context.nextSibling)) {\n\t\t\tif (context.nodeType == 1) {\n\t\t\t\tif (!locate(context)) break;\n\t\t\t\tif (selector.match(context, state)) combined.push(context);\n\t\t\t}\n\t\t}\n\t\treturn combined;\n\t}\n\n};\n\n\n/**\n * Pseudo-Classes\n */\nvar pseudos = Sly.pseudos = {\n\n\t// w3c pseudo classes\n\n\t'first-child': function(node) {\n\t\treturn pseudos.index(node, 0);\n\t},\n\n\t'last-child': function(node) {\n\t\twhile ((node = node.nextSibling)) {\n\t\t\tif (node.nodeType === 1) return false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t'only-child': function(node) {\n\t\tvar prev = node;\n\t\twhile ((prev = prev.previousSibling)) {\n\t\t\tif (prev.nodeType === 1) return false;\n\t\t}\n\t\tvar next = node;\n\t\twhile ((next = next.nextSibling)) {\n\t\t\tif (next.nodeType === 1) return false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t'nth-child': function(node, value, state) {\n\t\tvar parsed = Sly.parseNth(value || 'n');\n\t\tif (parsed.special != 'n') return pseudos[parsed.special](node, parsed.a, state);\n\t\tstate = state || {}; // just to be sure\n\t\tstate.positions = state.positions || {};\n\t\tvar uid = Sly.getUid(node) ;\n\t\tif (!state.positions[uid]) {\n\t\t\tvar count = 0;\n\t\t\twhile ((node = node.previousSibling)) {\n\t\t\t\tif (node.nodeType != 1) continue;\n\t\t\t\tcount++;\n\t\t\t\tvar position = state.positions[Sly.getUid(node)];\n\t\t\t\tif (position != undefined) {\n\t\t\t\t\tcount = position + count;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstate.positions[uid] = count;\n\t\t}\n\t\treturn (state.positions[uid] % parsed.a == parsed.b);\n\t},\n\n\t'empty': function(node) {\n\t\treturn !(node.innerText || node.textContent || '').length;\n\t},\n\n\t'contains': function(node, text) {\n\t\treturn (node.innerText || node.textContent || '').indexOf(text) != -1;\n\t},\n\n\t'index': function(node, index) {\n\t\tvar count = 1;\n\t\twhile ((node = node.previousSibling)) {\n\t\t\tif (node.nodeType == 1 && ++count > index) return false;\n\t\t}\n\t\treturn (count == index);\n\t},\n\n\t'even': function(node, value, state) {\n\t\treturn pseudos['nth-child'](node, '2n+1', state);\n\t},\n\n\t'odd': function(node, value, state) {\n\t\treturn pseudos['nth-child'](node, '2n', state);\n\t}\n\n};\n\npseudos.first = pseudos['first-child'];\npseudos.last = pseudos['last-child'];\npseudos.nth = pseudos['nth-child'];\npseudos.eq = pseudos.index;\n\n\n/**\n * Attribute operators\n */\nvar operators = Sly.operators = {\n\n\t'*=': function(value, escaped) {\n\t\treturn escaped;\n\t},\n\n\t'^=': function(value, escaped) {\n\t\treturn '^' + escaped;\n\t},\n\n\t'$=': function(value, escaped) {\n\t\treturn value + '$';\n\t},\n\n\t'~=': function(value, escaped) {\n\t\treturn '(?:^|[ \\\\t\\\\r\\\\n\\\\f])' + escaped + '(?:$|[ \\\\t\\\\r\\\\n\\\\f])';\n\t},\n\n\t'|=': function(value, escaped) {\n\t\treturn '(?:^|\\\\|)' + escaped + '(?:$|\\\\|)';\n\t}\n\n};\n\n\n// public, overridable\n\n/**\n * Sly.getAttribute & Sly.lookupAttribute\n * \n * @todo add more translations\n */\nvar translate = {\n\t'class': 'className'\n}\n\nSly.lookupAttribute = function(name) {\n\tvar prop = translate[name];\n\tif (prop) {\n\t\treturn function(node) {\n\t\t\treturn node[prop];\n\t\t}\n\t}\n\tvar flag = /^(?:src|href|action)$/.test(name) ? 2 : 0;\n\treturn function(node) {\n\t\treturn node.getAttribute(name, flag);\n\t}\n};\n\nSly.getAttribute = function(node, name) {\n\treturn node.getAttribute(name);\n};\n\n/**\n * Sly.toArray\n */\nvar toArray = Array.slice || function(nodes) {\n\treturn Array.prototype.slice.call(nodes);\n};\n\ntry {\n\ttoArray(document.documentElement.childNodes);\n} catch (e) {\n\ttoArray = function(nodes) {\n\t\tif (nodes instanceof Array) return nodes;\n\t\tvar i = nodes.length, results = new Array(i);\n\t\twhile (i--) results[i] = nodes[i];\n\t\treturn results;\n\t};\n}\n\nSly.toArray = toArray;\n\nSly.compare = (document.compareDocumentPosition) ? function (a, b) {\n\treturn (3 - (a.compareDocumentPosition(b) & 6));\n} : function (a, b) {\n\treturn (a.sourceIndex - b.sourceIndex);\n};\n\n/**\n * Sly.getUid\n */\nvar nextUid = 1;\n\nSly.getUid = (window.ActiveXObject) ? function(node) {\n\treturn (node.$slyUid || (node.$slyUid = {id: nextUid++})).id;\n} : function(node) {\n\treturn node.$slyUid || (node.$slyUid = nextUid++);\n};\n\n\nvar nthCache = {};\n\nSly.parseNth = function(value) {\n\tif (nthCache[value]) return nthCache[value];\n\n\tvar parsed = value.match(/^([+-]?\\d*)?([a-z]+)?([+-]?\\d*)?$/);\n\tif (!parsed) return false;\n\n\tvar a = parseInt(parsed[1], 10), b = (parseInt(parsed[3], 10) || 0) - 1;\n\n\tif ((a = (isNaN(a)) ? 1 : a)) {\n\t\twhile (b < 1) b += a;\n\t\twhile (b >= a) b -= a;\n\t}\n\tswitch (parsed[2]) {\n\t\tcase 'n': parsed = {a: a, b: b, special: 'n'}; break;\n\t\tcase 'odd': parsed = {a: 2, b: 0, special: 'n'}; break;\n\t\tcase 'even': parsed = {a: 2, b: 1, special: 'n'}; break;\n\t\tcase 'first': parsed = {a: 0, special: 'index'}; break;\n\t\tcase 'last': parsed = {special: 'last-child'}; break;\n\t\tcase 'only': parsed = {special: 'only-child'}; break;\n\t\tdefault: parsed = {a: (a) ? (a - 1) : b, special: 'index'};\n\t}\n\n\treturn (nthCache[value] = parsed);\n};\n\n\nSly.escapeRegExp = function(text) {\n\treturn text.replace(/[-.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&');\n};\n\n\n// generic accessors\n\nSly.generise = function(name) {\n\tSly[name] = function(text) {\n\t\tvar cls = Sly(text);\n\t\treturn cls[name].apply(cls, Array.prototype.slice.call(arguments, 1));\n\t}\n};\n\nvar generics = ['parse', 'search', 'find', 'match', 'filter'];\nfor (var i = 0; generics[i]; i++) Sly.generise(generics[i]);\n\n\n// compile pattern for the first time\n\nSly.recompile();\n\n// FIN\n\nreturn Sly;\n\n})();",
  "name": "idontknow",
  "interpreter": "javascript",
  "extension": "js"
}